<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小天才的杂货铺</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blogs.littlegenius.xin/"/>
  <updated>2019-08-29T05:12:25.643Z</updated>
  <id>https://blogs.littlegenius.xin/</id>
  
  <author>
    <name>MA Haozhe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【数据结构】（六）不相交集类</title>
    <link href="https://blogs.littlegenius.xin/2019/08/29/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%85%AD%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86%E7%B1%BB/"/>
    <id>https://blogs.littlegenius.xin/2019/08/29/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%85%AD%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86%E7%B1%BB/</id>
    <published>2019-08-29T04:14:30.000Z</published>
    <updated>2019-08-29T05:12:25.643Z</updated>
    
    <content type="html"><![CDATA[<h1 id="等价关系"><a href="#等价关系" class="headerlink" title="等价关系"></a>等价关系</h1><p>在离散数学（Discrete Mathematics）中提到过<strong>等价关系</strong>（equivalence relation）,等价关系是对于任意一对元素 (a,b)，存在一个关系R满足以下三个属性：</p><ul><li>自反性：对于所有的元素a，a R a</li><li>对称性：a R b == b R a</li><li>传递性：若 a R b 且 b R c 则 a R c</li></ul><p>比如空间中的相互平行的线就满足等价关系，线与自身平行、两条平行线相互平行，如果a平行于b，b平行于c，a也就平行于c，所以平行关系是等价关系。</p><p>一个集合S上的元素之间存在的等价关系是对集合S的一个划分，相互等价的元素可以划分到一个子集中，而没有等价关系的两个元素肯定不会被分到同一个子集中，所以按照等价关系划分可以将S划分为多个子集，每个子集中的元素都相互等价，这些子集是不相交的，而且他们的并正好是集合S。具有这种特性的集合可以视为一个<strong>不相交集类</strong>（The Disjoint Sets Class）</p><p>不相交集类的适合用于查找，有两个重要的操作：<code>find</code>和<code>union</code>：</p><ul><li><code>find</code>：查找操作，<code>find(x)</code>是返回x所在的子集的名字</li><li><code>union</code>：合并操作，如果我们发现两个元素a和b相互等价，但是他们没有在同一个子集中，那么很显然，a所在的子集和b所在的子集中的所有元素都相互等价，我们可以将其合并成一个新的子集</li></ul><h1 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h1><p>如果不要求find操作返回任意特定的名字，而是要求当且仅当两个元素属于相同的子集时，则作用在这两个元素上的find操作能返回相同的明自。那么我就需要对集合S进行划分，并且每一个子集都有唯一的名字。</p><p>一种简单的实现方式时是哟个森林，森林中的树就是一个子集，节点就是元素，同一棵树上的所有节点就都属于这个子集，显然可以将子集的名字存储到树的根节点中。这种方式很简单，使用数组就可以实现。比如我们有一个8元素的集合，他们分别是0 1 2 3 4 5 6 7，最初始的时候就是每个节点都单独成树，根节点中存储-1来代表这个时根节点，然后使用union方法来合并集合。像下边这样（union(a,b)默认将b挂到a上）：</p><p>初始的一个森林</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure7-1.png" alt="一个不相交集类的基本实现" title="">                </div>                <div class="image-caption">一个不相交集类的基本实现</div>            </figure><p>进行<code>union(4,5)</code>操作：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure7-2.png" alt="一个不相交集类的基本实现" title="">                </div>                <div class="image-caption">一个不相交集类的基本实现</div>            </figure><p>进行<code>union(6,7)</code>操作：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure7-3.png" alt="一个不相交集类的基本实现" title="">                </div>                <div class="image-caption">一个不相交集类的基本实现</div>            </figure><p>进行<code>union(4,6)</code>操作：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure7-4.png" alt="一个不相交集类的基本实现" title="">                </div>                <div class="image-caption">一个不相交集类的基本实现</div>            </figure><p>最终的存储这个不相交集类的数组如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure7-5.png" alt="一个不相交集类的基本实现" title="">                </div>                <div class="image-caption">一个不相交集类的基本实现</div>            </figure><h1 id="从union操作改进"><a href="#从union操作改进" class="headerlink" title="从union操作改进"></a>从union操作改进</h1><h2 id="按大小求并（union-by-size）"><a href="#按大小求并（union-by-size）" class="headerlink" title="按大小求并（union-by-size）"></a>按大小求并（union-by-size）</h2><p>这个思想是打破随意将一个集合接到另一个集合上的做法，而是根据大小将树合并，即永远将小的集合挂到大的集合上，这种实现方式很简单，并且使得森林中树的结构都不会特别复杂，避免了最坏情况的发生，存储时，<strong>将树的根节点的内容存储为此时树的大小的负数</strong>，比如继续上边的不相交集类，进行<code>union(3,4)</code>操作：</p><p>依旧按照原来的union方式合并：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure7-6.png" alt="依照一般的union方式合并" title="">                </div>                <div class="image-caption">依照一般的union方式合并</div>            </figure><p>按照小树并大树的方式进行union合并：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure7-7.png" alt="按照大小合并" title="">                </div>                <div class="image-caption">按照大小合并</div>            </figure><p>按照大小合并后的存储数组：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure7-8.png" alt="按照大小合并的存储数组" title="">                </div>                <div class="image-caption">按照大小合并的存储数组</div>            </figure><h2 id="按高度求并（union-by-height）"><a href="#按高度求并（union-by-height）" class="headerlink" title="按高度求并（union-by-height）"></a>按高度求并（union-by-height）</h2><p>根据高度将树合并，即永远将矮的集合挂到高的集合上，存储时，<strong>将树的根节点的内容存储为此时树的高度的负数</strong>，比如继续上边的不相交集类，进行按照高度的<code>union(3,4)</code>操作会得到：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure7-9.png" alt="按照高度合并" title="">                </div>                <div class="image-caption">按照高度合并</div>            </figure><p>存储数据的数组内容：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure7-10.png" alt="按照高度合并的存储数组" title="">                </div>                <div class="image-caption">按照高度合并的存储数组</div>            </figure><h1 id="从find操作改进"><a href="#从find操作改进" class="headerlink" title="从find操作改进"></a>从find操作改进</h1><p>在对union进行改进后可以对find进行改进，find改进的一种典型方式是<strong>路径压缩</strong>（Pass Compression）。即在每一次find后，将find的数据到根节点的沿途的每个节点都挂到根节点上，从而对路径进行压缩，而下次查找同一个元素或者其同子集下的元素就会非常省时间。</p><p>例如一个不相交集类如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure7-11.png" alt="一个不相交集类" title="">                </div>                <div class="image-caption">一个不相交集类</div>            </figure><p>在这个不太好的结构上进行find(14)后进行路径压缩可以得到：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure7-12.png" alt="对这个不相交集类进行路径压缩" title="">                </div>                <div class="image-caption">对这个不相交集类进行路径压缩</div>            </figure><p>这样就使得整棵树的高度、一些数据的路径深度（12、13、14、15）都得到了降低。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;等价关系&quot;&gt;&lt;a href=&quot;#等价关系&quot; class=&quot;headerlink&quot; title=&quot;等价关系&quot;&gt;&lt;/a&gt;等价关系&lt;/h1&gt;&lt;p&gt;在离散数学（Discrete Mathematics）中提到过&lt;strong&gt;等价关系&lt;/strong&gt;（equivalen
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://blogs.littlegenius.xin/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习笔记" scheme="https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/tags/C/"/>
    
      <category term="数据结构" scheme="https://blogs.littlegenius.xin/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【C++温故知新】（九）文件的输入与输出</title>
    <link href="https://blogs.littlegenius.xin/2019/08/28/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E4%B9%9D%E6%96%87%E4%BB%B6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"/>
    <id>https://blogs.littlegenius.xin/2019/08/28/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E4%B9%9D%E6%96%87%E4%BB%B6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/</id>
    <published>2019-08-28T14:47:10.000Z</published>
    <updated>2019-08-28T15:19:38.344Z</updated>
    
    <content type="html"><![CDATA[<p>文件的输入与输出也是基于<strong>流</strong>（stream）的，和<code>cout</code>、<code>cin</code>的操作类似。</p><h1 id="文件的写入"><a href="#文件的写入" class="headerlink" title="文件的写入"></a>文件的写入</h1><h2 id="基本条件"><a href="#基本条件" class="headerlink" title="基本条件"></a>基本条件</h2><ul><li>必须包含头文件 <code>fstream</code> </li><li>头文件 <code>fstream</code> 定义了一个用于处理输出的 <code>ofstream</code> 类</li><li>需要声明一个或多个 <code>ofstream</code> 变量（对象），并命名</li><li>必须指明名称空间 <code>std</code></li><li>需要将 <code>ofstream</code> 对象与文件关联起来。方法之一是使用 <code>open()</code> 方法</li><li>使用完文件后，应使用方法 <code>close()</code> 将其关闭</li><li>可结合使用 <code>ofstream</code> 对象和运算符 <code>&lt;&lt;</code> 来输出各种类型的数据</li></ul><h2 id="一个文件写入的实例"><a href="#一个文件写入的实例" class="headerlink" title="一个文件写入的实例"></a>一个文件写入的实例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> myString = <span class="string">"hello world!"</span>;</span><br><span class="line"></span><br><span class="line">    ofstream ourFile;</span><br><span class="line">    outFile.<span class="built_in">open</span>(<span class="string">"myFile.txt"</span>);</span><br><span class="line">    outFile &lt;&lt; myString;</span><br><span class="line">    outFile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="文件的读取"><a href="#文件的读取" class="headerlink" title="文件的读取"></a>文件的读取</h1><h2 id="基本条件-1"><a href="#基本条件-1" class="headerlink" title="基本条件"></a>基本条件</h2><ul><li>必须包含头文件 <code>fstream</code></li><li>头文件 <code>fstream</code> 定义了一个用于处理输入的 <code>ifstream</code> 类</li><li>需要声明一个或多个 <code>ifstream</code> 变量（对象），并命名</li><li>需要将 <code>ifstream</code> 对象与文件关联起来。方法之一是使用 <code>open()</code> 方法</li><li>读取完文件后，应使用方法 <code>close()</code> 将其关闭</li><li>可结合使用 <code>ifstream</code> 对象和运算符 <code>&gt;&gt;</code> 来读取各种类型的数据</li><li>可以使用 <code>ifstream</code> 对象和 <code>get()</code> 方法来读取一个字符，使用 <code>ifstream</code> 对象和 <code>getline()</code> 来读取一行字符</li><li>可以结合使用 <code>ifstream</code> 和 <code>cof()</code>、<code>fai()</code> 等方法来判断输入是否成功</li><li><code>ifstream</code> 对象本身被用作测试条件时，如果最后一个读取操作成功，它将被转换为布尔值 <code>true</code>，否则被转换为 <code>false</code></li></ul><h2 id="一个文件读取的实例"><a href="#一个文件读取的实例" class="headerlink" title="一个文件读取的实例"></a>一个文件读取的实例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> fileName = <span class="string">"myFile.txt"</span>;</span><br><span class="line"></span><br><span class="line">    ifstream inFile;</span><br><span class="line">    inFile.<span class="built_in">open</span>(fileName);</span><br><span class="line">    <span class="keyword">if</span> (!inFile.is_open())</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Can't open the file: "</span> &lt;&lt; fileName;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> readText;</span><br><span class="line">    inFile &gt;&gt; readText;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inFile.eof())</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"End of file reached.\n"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (inFile.fail())</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Input terminated by data mismatch.\n"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Input terminated for other reasons.\n"</span>;</span><br><span class="line"></span><br><span class="line">    inFile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文件的输入与输出也是基于&lt;strong&gt;流&lt;/strong&gt;（stream）的，和&lt;code&gt;cout&lt;/code&gt;、&lt;code&gt;cin&lt;/code&gt;的操作类似。&lt;/p&gt;
&lt;h1 id=&quot;文件的写入&quot;&gt;&lt;a href=&quot;#文件的写入&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/categories/C/"/>
    
    
      <category term="学习笔记" scheme="https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【C++温故知新】（八）异常处理</title>
    <link href="https://blogs.littlegenius.xin/2019/08/28/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E5%85%AB%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>https://blogs.littlegenius.xin/2019/08/28/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E5%85%AB%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</id>
    <published>2019-08-28T14:46:56.000Z</published>
    <updated>2019-08-28T14:53:16.689Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异常的抛出与捕获"><a href="#异常的抛出与捕获" class="headerlink" title="异常的抛出与捕获"></a>异常的抛出与捕获</h1><p>异常是程序在执行期间产生的问题，比如尝试除以零的操作。异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：<code>try</code>、<code>catch</code>、<code>throw</code>。</p><ul><li><code>throw</code>：当问题出现时，程序抛出一个异常</li><li><code>catch</code>：在想要处理问题的地方，通过异常处理程序捕获异常</li><li><code>try</code>：try块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。</li></ul><p>使用throw可以在一些特定的时候令程序抛出异常，比如当遇到除数是0的时候：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(division == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="string">"division by zero condition!"</span>;</span><br></pre></td></tr></table></figure><p>一个<code>try……catch</code>的写法通常是这这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// protected codes</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>( ExceptionName e1 )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// catch block</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>( ExceptionName e2 )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// catch block</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要捕获所有的异常，则需要在<code>catch</code>的括号中使用省略号：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// protected codes</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>( … )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// catch block</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="定义新的异常"><a href="#定义新的异常" class="headerlink" title="定义新的异常"></a>定义新的异常</h1><p>可以通过继承和重载<code>exception</code>类来定义新的异常，比如像下边这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyException</span> :</span> <span class="keyword">public</span> exception</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="title">throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"New Exception"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> MyException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> ( MyException&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"MyException caught"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (exception&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// other exceptions</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;异常的抛出与捕获&quot;&gt;&lt;a href=&quot;#异常的抛出与捕获&quot; class=&quot;headerlink&quot; title=&quot;异常的抛出与捕获&quot;&gt;&lt;/a&gt;异常的抛出与捕获&lt;/h1&gt;&lt;p&gt;异常是程序在执行期间产生的问题，比如尝试除以零的操作。异常提供了一种转移程序控制权的方式。C
      
    
    </summary>
    
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/categories/C/"/>
    
    
      <category term="学习笔记" scheme="https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【C++温故知新】（七）类的继承</title>
    <link href="https://blogs.littlegenius.xin/2019/08/28/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E4%B8%83%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/"/>
    <id>https://blogs.littlegenius.xin/2019/08/28/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E4%B8%83%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/</id>
    <published>2019-08-28T14:39:06.000Z</published>
    <updated>2019-08-28T14:54:17.937Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类继承的语法"><a href="#类继承的语法" class="headerlink" title="类继承的语法"></a>类继承的语法</h1><p>类的继承允许通过继承的方式生成新类，继承自的类为<strong>基类</strong>，继承自基类的类成为派生类，类的继承写法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derivedClass</span> :</span> <span class="keyword">public</span>/protect/<span class="keyword">private</span> baseClass</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// statements</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中基类前有一个访问限定符，不写的时候默认为private，但是我们主要使用public，又称作公有继承，三个不同的访问限定词的区别在于：</p><ul><li>公有继承（<code>public</code>）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问</li><li>保护继承（<code>protecte</code>）：      当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员</li><li>私有继承（<code>private</code>）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员</li></ul><p>例如我们定义一个基类再定义一个派生类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">baseClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    baseInt;</span><br><span class="line">    baseDouble;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    baseClass(<span class="keyword">const</span> <span class="keyword">int</span> pInt = <span class="number">1</span>, cosnt <span class="keyword">double</span> pDouble = <span class="number">2.5</span>);</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">(<span class="keyword">double</span> d)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">baseClass :: baseClass(<span class="keyword">const</span> <span class="keyword">int</span> pInt = <span class="number">1</span>, cosnt <span class="keyword">double</span> pDouble = <span class="number">2.5</span>)</span><br><span class="line">&#123;</span><br><span class="line">    baseInt = pInt;</span><br><span class="line">    baseDouble = pDouble;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">baseClass :: function(<span class="keyword">double</span> d)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derivedClass</span> :</span> <span class="keyword">public</span> baseClass</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">derivedChar;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    derivedClass(<span class="keyword">const</span> <span class="keyword">int</span> pInt, <span class="keyword">const</span> <span class="keyword">double</span> pDouble, <span class="keyword">const</span> <span class="keyword">char</span> pChar);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">anotherFunction</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">derivedClass :: derivedClass(<span class="keyword">const</span> <span class="keyword">int</span> pInt, <span class="keyword">const</span> <span class="keyword">double</span> pDouble, <span class="keyword">const</span> <span class="keyword">char</span> pChar) : baseClass(pInt,pDouble)</span><br><span class="line">&#123;</span><br><span class="line">derivedChar = pChar;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> derivedClass :: anotherFunction()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"I am the derived class."</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个例子中，我们可以看到，基类有两个私有变量，<code>baseInt</code>和<code>baseDouble</code>，两个方法，一个构造函数用于给两个私有变量赋值，一个用于充数。派生类继承自基类，于是派生类<code>derivedClass</code>就拥有了基类的两个公有方法，但是它不能访问基类的两个私有变量。派生类又定义了自己的一个新私有变量，同时有自己的构造函数和一个用于充数的函数。可见继承的作用在于方便地进行代码的重用以及组织管理项目设计。</p><h1 id="基类和派生类的关系"><a href="#基类和派生类的关系" class="headerlink" title="基类和派生类的关系"></a>基类和派生类的关系</h1><p>类的继承是“is-a”的关系，或者说是“is-a-kind-of”，即派生类对象也是一个基类对象。</p><ul><li>派生类是可以调用基类的<code>protected</code>和<code>public</code>修饰的成员变量和方法的，而派生类也可以定义自己的变量和方法。</li><li>同时，派生类还可以重载基类的方法，即声明一个和基类中相同名称的成员变量，但是在派生类中对其进行重新的定义。如果基类和派生类同时拥有同名同变量参数同返回值但是定义不同的函数，在使用基类对象调用该函数时，调用的是基类的函数，在使用派生类的对象调用该函数时，调用的是派生类的定义。</li><li>基类指针可以在不进行显式类型转换的情况下指向派生类对象；基类引用可以在不进行显式类型转换的情况下引用派生类对象。C++要求的引用和指针类型与赋给的类型匹配的规则对继承来说例外。然而，这种例外只是单向的，不可以将基类对象和地址赋给派生类引用和指针。基类指针或引用只能用于调用基类方法。</li></ul><h1 id="多态公有继承"><a href="#多态公有继承" class="headerlink" title="多态公有继承"></a>多态公有继承</h1><p>多态即一个派生类继承自一个基类后，希望可以定义一个和基类中相同名称、参数列表、返回值的函数，但这个函数的定义却与基类中的不同，即一种派生类对基类方法的重载。</p><p>首先，派生类可以重载基类的方法，如果派生类使用基类相同的函数和函数定义，那么就不需要再在派生类中声明该函数，即共有的函数需要放在基类中。如果派生类想对基类的函数进行新的定义，则需要在派生类中对其再次进行声明并定义，定义时也需要表明定义的是那个类的函数。如 <code>baseClass::function()</code> 和 <code>derivedClass::function()</code> 这样。</p><p><strong>虚方法</strong>（virtual method），需要使用关键词 <code>virtual</code> 修饰基类中的函数，如下面这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br></pre></td></tr></table></figure><p>它的作用如下：当基类和派生类都有定义过某个相同方法后，我们需要确定调用的是哪个类下的方法，特别是当方法是通过引用或指针而不是对象调用的。</p><ul><li>如果没有使用关键字 <code>virtual</code> ，程序将根据引用类型或指针类型选择方法</li><li>如果使用了关键字 <code>virtual</code> ，程序将根据引用或指针指向的对象的类型来选择方法</li><li>如果有派生类重载了基类的方法，一般需要将基类的析构函数设置成virtual的以保证释放派生类对象时能够按照正确的顺序调用析构函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用virtual</span></span><br><span class="line"><span class="function">BaseClass <span class="title">baseClass</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">DerivedClass <span class="title">derivedClass</span><span class="params">()</span></span>;</span><br><span class="line">BaseClass &amp; reference1 = baseClass; <span class="comment">// 指向baseClass的类型是BaseClass的引用变量</span></span><br><span class="line">BaseClass &amp; reference2 = derivedClass; <span class="comment">// 指向derivedClass的但是类型是BaseClass的引用变量</span></span><br><span class="line">reference1.function(); <span class="comment">// 会根据引用的类型即BaseClass调用BaseClass下的function方法</span></span><br><span class="line">reference2.function(); <span class="comment">// 会根据引用的类型即BaseClass调用BaseClass下的function方法</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用virtual</span></span><br><span class="line"><span class="function">BaseClass <span class="title">baseClass</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">DerivedClass <span class="title">derivedClass</span><span class="params">()</span></span>;</span><br><span class="line">BaseClass &amp; reference1 = baseClass; <span class="comment">// 指向baseClass的类型是BaseClass的引用变量</span></span><br><span class="line">BaseClass &amp; reference2 = derivedClass; <span class="comment">// 指向derivedClass的但是类型是BaseClass的引用变量</span></span><br><span class="line">reference1.function(); <span class="comment">// 会根据引用指向的类型即BaseClass调用BaseClass下的function方法</span></span><br><span class="line">reference2.function(); <span class="comment">// 会根据引用指向的类型即DerivedClass调用BaseClass下的function方法</span></span><br></pre></td></tr></table></figure><h1 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h1><p><strong>抽象基类</strong>（abstract base class，ABC）是一种特殊的基类，从概念上讲，将所有派生类的公用的方法进行抽象汇总声明（定义）到的一个类中，这种设计下的类可以视作一个抽象基类。但是真正的抽象基类应该是至少包含了一个<strong>纯虚函数</strong>（pure virtual function）的类，<strong>这种类不能声明对应的对象</strong>，只能作为基类。</p><p>纯虚函数是一种只在抽象基类中给出原型，但是部给出定义的函数，更像是一个接口，由所有的派生类对纯虚函数根据自己类的需求来实现其定义。纯虚函数的写法是在虚函数后面以 =0 结尾</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">pureVirtualFunction</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>应用这种方式，可以将所有派生类共有但是却又各自有着不同实现的方法抽象到一个基类中，提供其原型但是不对其进行定义（也只有纯虚函数C++允许不给出定义），然后使得各个派生类自己给出其定义。</p><h1 id="私有继承"><a href="#私有继承" class="headerlink" title="私有继承"></a>私有继承</h1><p>私有继承即继承的基类使用private修饰符修饰的继承，如果没有访问限定符的修饰，默认也是私有继承，私有继承是一种“has-a”的关系。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClass</span> :</span> <span class="keyword">private</span> BaseClass&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClass</span> :</span> BaseClass&#123; &#125;</span><br></pre></td></tr></table></figure><p>私有继承使得基类的公有成员、保护成员都被成为派生类的私有成员，这就使得基类的那些方法都不能再被派生类的实例化对象使用，而只能被派生类的成员函数在类内部使用。即派生类部继承基类的接口。</p><p>这里比较了三种继承之间的区别：</p><table><thead><tr><th align="center">特征</th><th align="center">公有继承</th><th align="center">保护继承</th><th align="center">私有继承</th></tr></thead><tbody><tr><td align="center">公有成员变成</td><td align="center">派生类的公有成员</td><td align="center">派生类的保护成员</td><td align="center">派生类的私有成员</td></tr><tr><td align="center">保护成员变成</td><td align="center">派生类的保护成员</td><td align="center">派生类的保护成员</td><td align="center">派生类的私有成员</td></tr><tr><td align="center">私有成员变成</td><td align="center">只能通过基类接口访问</td><td align="center">只能通过基类接口访问</td><td align="center">只能通过基类接口访问</td></tr><tr><td align="center">能否隐式向上转换</td><td align="center">能</td><td align="center">只能在派生类中</td><td align="center">不能</td></tr></tbody></table><h1 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h1><p><strong>多重继承</strong>（Multiple Inheritance）也是“is-a”的关系，它允许一个类继承自多个类，只需要将继承的类使用逗号隔开即可，像下面这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClass</span> :</span> <span class="keyword">public</span> BaseClass1, <span class="keyword">public</span> BaseClass2 &#123;……&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClass</span> :</span> <span class="keyword">public</span> BaseClass1, BaseClass2 &#123;……&#125; <span class="comment">// BaseClass2 is a private base</span></span><br></pre></td></tr></table></figure><p>多重继承中每一个被继承的基类都需要设置访问限定符，根据需要可以使用不同的访问限定符，不写默认为<code>private</code></p><p>例如设置一个基类Worker表示工人，然后工人可以是歌手也可以是服务员，我们使用两个类继承自这个基类，Singer和Waiter，最后，我们可以定义一个既是歌手有时服务员的类，所以它同时继承自Singer和Waiter，他们的关系就像下边这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> &#123;</span>……&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span> :</span> <span class="keyword">public</span> Worker &#123;……&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Waiter</span> :</span> <span class="keyword">public</span> Worker &#123;……&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingingWaiter</span> :</span> <span class="keyword">public</span> Singer, <span class="keyword">public</span> Waiter &#123;……&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/CPP7-1.png" alt="一个多重继承" title="">                </div>                <div class="image-caption">一个多重继承</div>            </figure><h2 id="虚基类"><a href="#虚基类" class="headerlink" title="虚基类"></a>虚基类</h2><p>首先多重继承导致了一个问题就是，当一个SingingWaiter的实例继承自Singer和Waiter时，也就间接地两次继承了Worker，也就是说一个SingingWaiter的实例结构应该是如下这样的：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/CPP7-2.png" alt="在不使用虚基类的时候" title="">                </div>                <div class="image-caption">在不使用虚基类的时候</div>            </figure><p>这样引发的问题就是，当我们把派生类对象的地址赋给一个基类的指针时就无法区分是赋给哪个基类，导致二义性：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SingingWaiter sw；</span><br><span class="line">Worker * psw = &amp;sw;</span><br></pre></td></tr></table></figure><p>因为sw中包含两个Worker对象，从而有两给地址可以选择，于是正确的写法应该是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Worker * psw1 = (Waiter *) &amp;sw;</span><br><span class="line">Worker * psw2 = (Singer *) &amp;sw;</span><br></pre></td></tr></table></figure><p>所以<strong>虚基类</strong>（Virtual Base Classes）将解决这个问题。虚基类使得从多个类派生出的对象只继承一个基类对象，需要在类继承的声明中使用virtual关键词，virtual和public的次序无所谓：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Worker &#123;……&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Waiter</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> Worker &#123;……&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingingWaiter</span> :</span> <span class="keyword">public</span> Singer, <span class="keyword">public</span> Waiter &#123;……&#125;</span><br></pre></td></tr></table></figure><p>现在，SingingWaiter对象就只包含Worker对象的一个副本，从本质上说是，继承的Singer和Waiter共享一个Worker对象，而不是各自引入一个Worker对象的副本，从而可以使用多态。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/CPP7-3.png" alt="在使用虚基类的时候" title="">                </div>                <div class="image-caption">在使用虚基类的时候</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;类继承的语法&quot;&gt;&lt;a href=&quot;#类继承的语法&quot; class=&quot;headerlink&quot; title=&quot;类继承的语法&quot;&gt;&lt;/a&gt;类继承的语法&lt;/h1&gt;&lt;p&gt;类的继承允许通过继承的方式生成新类，继承自的类为&lt;strong&gt;基类&lt;/strong&gt;，继承自基类的类成为派
      
    
    </summary>
    
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/categories/C/"/>
    
    
      <category term="学习笔记" scheme="https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【C++温故知新】（六）类和对象</title>
    <link href="https://blogs.littlegenius.xin/2019/08/27/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E5%85%AD%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <id>https://blogs.littlegenius.xin/2019/08/27/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E5%85%AD%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</id>
    <published>2019-08-27T08:41:15.000Z</published>
    <updated>2019-08-28T14:39:52.941Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类与接口"><a href="#类与接口" class="headerlink" title="类与接口"></a>类与接口</h1><p>类是一种将抽象转换为用户定义类型的C++工具，它将数据表示和操作数据的方法组合成一个整洁的包。接口提供给我们从外部访问类与类内的成员和方法的一个途径。</p><p>一般对一个类的典型的实现策略是：<strong>将接口（类的定义）放在头文件中，将其实现（类方法的代码）放在源代码文件中</strong></p><h2 id="类的声明框架"><a href="#类的声明框架" class="headerlink" title="类的声明框架"></a>类的声明框架</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// some private variables and functions</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// some public variables and functions</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p>访问限定符有三个：<code>private</code>、<code>public</code>、<code>protected</code>，它们规定了修饰的变量和方法能够被访问的范围，在没有声明时，默认是private的。</p><p>这里先对三个访问限定词做一个比较全面的介绍：</p><ul><li><code>private</code> :<ul><li>类（基类）自身的成员函数</li><li>类（基类）友元的成员函数</li></ul></li><li><code>public</code> :<ul><li>基类自身的成员函数</li><li>基类友元的成员函数</li><li>基类所产生派生类的成员函数</li><li>基类所产生的派生类的友元函数</li><li>其他的全局函数</li></ul></li><li><code>protected</code> :<ul><li>基类的成员函数</li><li>基类的友元函数</li><li>基类派生类的成员函数</li></ul></li></ul><p>例如一个类：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/CPP6-1.png" alt="一个类的结构" title="">                </div>                <div class="image-caption">一个类的结构</div>            </figure><h2 id="类的成员函数的实现"><a href="#类的成员函数的实现" class="headerlink" title="类的成员函数的实现"></a>类的成员函数的实现</h2><p>类的成员函数和一般的函数实现基本相同，还要增添如下两点：</p><ul><li>需要使用 <code>::</code> 符号（作用域解析运算符）来标识这个函数是属于哪一个类的，因为不同的类可以有相同名称的函数</li><li>类的方法可以访问类内的 <code>private</code> 的组件</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ClassName::myFunction(<span class="keyword">double</span> a);</span><br></pre></td></tr></table></figure><ul><li>类的成员函数也可以是内联的，只要加上关键词 <code>inline</code> 即可</li><li>类的成员函数可以在类内定义时同时完成逻辑，也可以在类的外部定义</li></ul><h2 id="类的使用"><a href="#类的使用" class="headerlink" title="类的使用"></a>类的使用</h2><p>类的实例化和一般的数据类型相同，调用类实例下的某个成员函数或者变量使用 <code>.</code> 点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassName myClassInstance;</span><br><span class="line">myClassInstance.aFunction();</span><br></pre></td></tr></table></figure><h1 id="类的构造函数和析构函数"><a href="#类的构造函数和析构函数" class="headerlink" title="类的构造函数和析构函数"></a>类的构造函数和析构函数</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>类的构造函数需要和类同名，是在类实例化的时候调用的，在实例化一个类的时候，虽然我们没有显示地声明，但是还是调用了构造函数，而C++对每一个类都有默认的构造函数，就是不接受任何参数，什么都不做，也无返回值。我们可以定义自己的构造函数并且调用它。</p><p>例如一个类MyClass的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> myInt;</span><br><span class="line">    <span class="keyword">double</span> myDouble;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass(<span class="keyword">int</span> mi, <span class="keyword">double</span> md) &#123; myInt = mi; myDouble = md;&#125;;</span><br><span class="line">    MyClass() &#123; myInt = <span class="number">1</span>; myDouble = <span class="number">0.2</span>;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们使用了一个包含两个参数的构造函数，它的作用是对两个private的成员变量赋值。</p><p>构造函数不能像其他成员函数一样使用对象（类的实例）来用点调用，因为构造函数是在实例化类的时候就调用的，比如如下的调用方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyClass myClass = MyClass(<span class="number">1</span>, <span class="number">0.2</span>);</span><br><span class="line"><span class="function">MyClass <span class="title">myClass</span><span class="params">(<span class="number">1</span>, <span class="number">0.2</span>)</span></span>;</span><br><span class="line">MyClass * myClassPoint = <span class="keyword">new</span> MyClass(<span class="number">1</span>, <span class="number">0.2</span>);</span><br></pre></td></tr></table></figure><p>如果是使用的默认构造函数或者构造函数没有参数的话，可以直接声明对象而不显示地调用构造函数，比如我们的类中还有一个重载的没有参数的构造函数，它可以这样被调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyClass myClass; <span class="comment">// 隐式调用</span></span><br><span class="line">MyClass myClass = MyClass(); <span class="comment">// 显示调用</span></span><br><span class="line">MyClass * myClass = <span class="keyword">new</span> MyClass(); <span class="comment">// 隐式调用</span></span><br><span class="line"><span class="function">MyClass <span class="title">myClassFunction</span><span class="params">()</span></span>; <span class="comment">// 这是一个返回值是MyClass的函数</span></span><br></pre></td></tr></table></figure><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>用构造函数创建对象后，程序负责跟踪该对象，直到其过期为止，对象过期时，程序将自动调用一个特殊的成员函数，即析构函数。</p><p>析构函数用于完成清理工作，所以非常有用，例如如果构造函数用<code>new</code>分配了内存，则可以在析构函数中用<code>delete</code>释放内存。</p><p>默认的析构函数是什么都不做的。我们以可以显示地定义自己析构函数，析构函数是一个~符号加上类名来定义的，析构函数何时调用是取决于编译器的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> myInt;</span><br><span class="line">    <span class="keyword">double</span> myDouble;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass(<span class="keyword">int</span> mi, <span class="keyword">double</span> md) &#123; myInt = mi; myDouble = md;&#125;;</span><br><span class="line">    MyClass() &#123; myInt = <span class="number">1</span>; myDouble = <span class="number">0.2</span>;&#125;;</span><br><span class="line">    ~MyClass() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"bye!"</span>; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h1><p>const成员函数是指，保证该成员函数不会改变调用的对象，声明和定义const成员函数需要将const限定符加在成员函数的后边：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">void</span> MyClass::show() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// function body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以这种方式声明和定义的类函数即const成员函数，应该尽可能地将成员函数修饰为const，只要该类的方法不修改调用对象。</p><h1 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h1><p><code>this</code>指针在类的成员函数中，用来作为指向<strong>调用类对象自身</strong>的指针，即它指向自己的类的地址。我们上面的构造函数中的 <code>myInt = mi;</code> 这一语句，其实这里的 <code>myInt</code> 就是 <code>this-&gt;myInt</code> 的简写，因为在类中，可以直接用成员变量简单地替换 <code>this-&gt;</code> 成员变量。</p><p>this指针在只操作自身类内成员的时候不会有特别多的作用，因为都可以省略它，但是一旦我们的成员函数涉及到两个及以上的类的对象时，this就发挥了很大的作用。例如我们有一个compare函数，用于比较两个MyClass类的实例的哪一个的myInt值更大，那么我们必然需要另一个MyClass的实例作为参数，然后让它的myInt和自己的myInt比较，然后返回myInt较大的那个MyClass的引用，所以可以这样声明这个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass &amp; MyClass::compare(<span class="keyword">const</span> MyClass &amp; myClass) <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure><p>函数定义中涉及到三个const：</p><ul><li>第一个const：表明返回值是一个MyClass，显然不能被改变，所以可以时const的</li><li>第二个const：传入的MyClass实例只是用于比较的，不需要改变，所以使用const</li><li>第三个const：由于成员函数不改变调用类对象，所以是const的成员函数</li></ul><p>比较myInt的函数可以使用this来这样实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass &amp; MyClass::compare(<span class="keyword">const</span> MyClass &amp; myClass) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(myClass.myInt &gt; <span class="keyword">this</span>-&gt;myInt)</span><br><span class="line">    <span class="keyword">return</span> myClass;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然，上边的 <code>this-&gt;myInt</code> 可以使用 <code>myInt</code> 直接简写，而返回自己调用类对象的时候，就只能用 this 来称呼了，而且需要注意的是，返回的是一个MyClass的引用，从而需要使用<code>*this</code>而不是直接返回<code>this</code>，因为<code>this</code>是<strong>指针</strong></p><h1 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h1><p>类和其他数据结构一样，都可以创建数组，对象的数组即可以存储多个类对象，只需要像下边这样声明它们：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyClass myClasses[<span class="number">3</span>];</span><br><span class="line">myClasses[<span class="number">0</span>].show();</span><br><span class="line">myClasses[<span class="number">1</span>].compare(myClasses[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><p>运算符重载即将C++中的运算符重载扩展到用户自定义的类型，例如，+这个运算符，只能用于整形、浮点型、字符串等基本的数据结构相加，但是我们可以通过用户的定义，将其用于两个类的对象相加，两个数组相加等等，编译器会根据操作数和目的数的类型决定使用哪种定义。</p><h2 id="运算符重载的写法"><a href="#运算符重载的写法" class="headerlink" title="运算符重载的写法"></a>运算符重载的写法</h2><p>运算符重载的格式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">op</span> <span class="params">(arguments)</span></span>;</span><br></pre></td></tr></table></figure><p>比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> +( ); <span class="comment">// 重载+运算符</span></span><br><span class="line"><span class="keyword">operator</span> *( ); <span class="comment">// 重载*运算符</span></span><br><span class="line"><span class="keyword">operator</span> [ ]( ); <span class="comment">// 重载[]运算符</span></span><br></pre></td></tr></table></figure><h2 id="一个运算符重载的例子"><a href="#一个运算符重载的例子" class="headerlink" title="一个运算符重载的例子"></a>一个运算符重载的例子</h2><p>假设我们有一个时间类Time，由两个私有成员变量 hours、minutes 来代表小时和分钟，我们来实现Time类对象的相加逻辑。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> hours;</span><br><span class="line">    <span class="keyword">int</span> minutes;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Time;</span><br><span class="line">    Time(<span class="keyword">int</span> h, <span class="keyword">int</span> m=<span class="number">0</span>);</span><br><span class="line">    Time <span class="keyword">operator</span> + (<span class="keyword">const</span> Time &amp; t) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Time::Time()</span><br><span class="line">&#123;</span><br><span class="line">hours = minutes = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Time::Time(<span class="keyword">int</span> h, <span class="keyword">int</span> m)</span><br><span class="line">&#123;</span><br><span class="line">    hours = h;</span><br><span class="line">    minutes = m;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Time Time::<span class="keyword">operator</span> + (<span class="keyword">const</span> Time &amp; t) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Time sum;</span><br><span class="line">    sum.minutes = minutes + t.minutes;</span><br><span class="line">    sum.hours = hours + t.hours + sum.minutes / <span class="number">60</span>;</span><br><span class="line">    sum.minutes %= <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这个重载的+运算符可以将两个Time的对象像其他一般数据类型一样进行相加：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Time time1;</span><br><span class="line">Time time2;</span><br><span class="line">Time total = time1 + time2;</span><br></pre></td></tr></table></figure><h2 id="运算符重载的限制"><a href="#运算符重载的限制" class="headerlink" title="运算符重载的限制"></a>运算符重载的限制</h2><p>多数C++运算符都可以用这样的方式重载。重载的运算符（有些例外情况）不必是成员函数，但必须至少有一个操作数是用户定义的类型。C++运算符重载的限制如下：</p><ul><li>重载后的运算符必须至少有一个操作数是用户定义的类型，这将防止用户为标准类型重载运算符因此，例如不能将减法运算符重载为计算两个 double 值的和，而不是它们的差。</li><li>使用运算符时不能违反运算符原来的句法规则。例如，不能将求模运算符（%）重载成使用一个操作数的运算</li><li>不能修改运算符的优先级。例如，如果将加号运算符重载成将两个类相加，则新的运算符与原来的加号具有相同的优先级</li><li>不能创建新运算符。例如，不能定义 <code>operator **()</code> 函数来表示求幂</li><li>不能重载下面的运算符<ul><li><code>sizeof</code> ：sizeof 运算符</li><li><code>.</code> ：成员运算符</li><li><code>*</code> ：成员指针运算符</li><li><code>::</code> ：作用域解析运算符</li><li><code>? :</code> ：条件运算符</li><li><code>typeid</code>：一个RTTI运算符</li><li><code>const_cast</code>：强制类型转换运算符</li><li><code>dynamic_cast</code>：强制类型转换运算符</li><li><code>reinterpret_cast</code>：强制类型转换运算符</li><li><code>static_cast</code>：强制类型转换运算符</li></ul></li><li>大多数运算符都可以通过成员函数或者非成员函数进行重载，但是如下的运算符只能通过成员函数进行重载：<ul><li><code>=</code>：赋值运算符</li><li><code>( )</code>：函数调用运算符</li><li><code>[ ]</code>：下标运算符</li><li><code>-&gt;</code>：通过指针访问类成员运算符</li></ul></li></ul><p>可以重载的运算符</p><table><thead><tr><th><code>+</code></th><th><code>-</code></th><th><code>*</code></th><th><code>/</code></th><th><code>%</code></th><th><code>^</code></th></tr></thead><tbody><tr><td><code>&amp;</code></td><td>`</td><td>`</td><td><code>~=</code></td><td><code>!</code></td><td><code>=</code></td></tr><tr><td><code>&gt;</code></td><td><code>+=</code></td><td><code>-=</code></td><td><code>*=</code></td><td><code>/=</code></td><td><code>%=</code></td></tr><tr><td><code>^=</code></td><td><code>&amp;=</code></td><td>`</td><td>=`</td><td><code>&lt;&lt;</code></td><td><code>&gt;&gt;</code></td></tr><tr><td><code>&lt;&lt;=</code></td><td><code>==</code></td><td><code>!=</code></td><td><code>&lt;=</code></td><td><code>&gt;=</code></td><td><code>&amp;&amp;</code></td></tr><tr><td>`</td><td></td><td>`</td><td><code>++</code></td><td><code>--</code></td><td><code>,</code></td></tr><tr><td><code>()</code></td><td><code>[]</code></td><td><code>new</code></td><td><code>delete</code></td><td><code>new[]</code></td><td><code>delete[]</code></td></tr></tbody></table><h1 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h1><p>类的友元函数是非成员函数，其访问权限与成员函数相同。</p><h2 id="一个友元函数的例子"><a href="#一个友元函数的例子" class="headerlink" title="一个友元函数的例子"></a>一个友元函数的例子</h2><p>回到上面的Time类，我们重载<em>运算符：将</em>运算符重载成一个double值乘以一个Time类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Time Time::<span class="keyword">operator</span> * (<span class="keyword">const</span> <span class="keyword">double</span> d) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Time result;</span><br><span class="line">    <span class="keyword">long</span> totalMinutes = hours * d * <span class="number">60</span> + minutes * d;</span><br><span class="line">    result.hours = totalMinutes / <span class="number">60</span>;</span><br><span class="line">    result.minutes = totalMinutes % <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然调用上述<code>*</code>的重载需要这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Time <span class="title">A</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Time <span class="title">B</span><span class="params">(<span class="number">1</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">A = B * <span class="number">2.5</span>;</span><br></pre></td></tr></table></figure><p>相当于调用了这样的运算符重载的成员函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = B.<span class="keyword">operator</span>*(<span class="number">2.5</span>);</span><br></pre></td></tr></table></figure><p>但是，问题来了，如果使用 A = 2.5 * B 就无法成功，这似乎违背了乘法的分配律，这一点虽然并不有违于C++的语法，但是貌似并不用户友好，我们需要告诉使用的人只能用第一种方式而不能用第二种方式。解决这个问题有两个方法：</p><ul><li>使用一个非成员函数来定义反写的情况：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Time <span class="keyword">operator</span> * (<span class="keyword">double</span> d, <span class="keyword">const</span> Time &amp; t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> t * m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这种方式不失为是一种非常好的方法，而且如果有所修改，只需要修改类内的运算符重载即可。</p><ul><li>使用友元函数<br>和上述的思想类似，我们可以定义一个非成员函数，然后这样的重载运算符，从而定义一个double乘以一个Time类对象的操作：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Time <span class="keyword">operator</span> * (<span class="keyword">double</span> d, <span class="keyword">const</span> Time &amp; t);</span><br></pre></td></tr></table></figure><p>但是问题在于类外的非成员函数无法访问类的私有变量。所以友元函数的作用在于可以访问类的私有成员，但是他是一个非成员函数。</p><h2 id="创建友元函数"><a href="#创建友元函数" class="headerlink" title="创建友元函数"></a>创建友元函数</h2><p>创建友元函数的第一步是将其原型放在<strong>类声明</strong>中，并在原型声明前加上关键字 friend：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> Time <span class="keyword">operator</span>*(<span class="keyword">double</span> m, <span class="keyword">const</span> Time t);</span><br></pre></td></tr></table></figure><p>该原型意味着下面两点：</p><ul><li>虽然 <code>operator*()</code> 函数是在类声明中声明的，但它不是成员函数，因此不能使用成员运算符来调用</li><li>虽然 <code>operator*()</code> 函数不是成员函数，但它与成员函数的访问权限相同</li></ul><p>第二步是编写函数定义。因为它不是成员函数，所以不要使用 <code>Time::</code> 限定符。另外，不能在定义中使用关键字 <code>friend</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Time <span class="keyword">operator</span> * (<span class="keyword">double</span> d, <span class="keyword">const</span> Time &amp; t)</span><br><span class="line">&#123;</span><br><span class="line">    Time result;</span><br><span class="line">    <span class="keyword">long</span> totalMinutes = hours * d * <span class="number">60</span> + minutes * d;</span><br><span class="line">    result.hours = totalMinutes / <span class="number">60</span>;</span><br><span class="line">    result.minutes = totalMinutes % <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述定义后即可使用如下的语句来使用乘法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">2.5</span> * B;</span><br></pre></td></tr></table></figure><p>相当于调用友元函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="keyword">operator</span>*(<span class="number">2.5</span>, B);</span><br></pre></td></tr></table></figure><h2 id="成员函数和非成员函数的选择"><a href="#成员函数和非成员函数的选择" class="headerlink" title="成员函数和非成员函数的选择"></a>成员函数和非成员函数的选择</h2><p>对于一般的运算符重载，比如+和-这种不会出现乘法那种左右交换的问题的，有两种解决方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time <span class="keyword">operator</span> + (<span class="keyword">const</span> Time &amp; t) <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">friend</span> Time <span class="keyword">operator</span> + (<span class="keyword">const</span> Time &amp; t1, <span class="keyword">const</span> Time &amp; t2);</span><br></pre></td></tr></table></figure><p>第一种方式是通过this隐式地传递一个参数，另一个使用函数参数显示地传递；第二种方式是两个参数都显示地通过参数传递。在调用 T1 = T2 + T3 时，会分别编译成如下的形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T1 = T2.<span class="keyword">operator</span>+(T3);</span><br><span class="line">T1 = <span class="keyword">operator</span>+(T2, T3);</span><br></pre></td></tr></table></figure><p>但是，<strong>两种方式不能同时定义</strong>，只能选择其中一个，否则会引发二义性的编译错误，基于乘法的例子，显然使用友元函数比较通用。</p><h1 id="类的自动转换和强制类型转换"><a href="#类的自动转换和强制类型转换" class="headerlink" title="类的自动转换和强制类型转换"></a>类的自动转换和强制类型转换</h1><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>C++允许一些强制类型转换，比如强制将double值转换成int值，把double的2.5转换成int会成为2从而丢失0.5。但是如果用户希望进行强制转换只需要使用如下的方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">targetType valueName = (targetType) value;</span><br><span class="line">targetType valueName = targetType (value);</span><br></pre></td></tr></table></figure><h2 id="使用构造函数进行类的自动转换"><a href="#使用构造函数进行类的自动转换" class="headerlink" title="使用构造函数进行类的自动转换"></a>使用构造函数进行类的自动转换</h2><p>假设我们有一个类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> myInt;</span><br><span class="line">    <span class="keyword">double</span> myDouble;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass(<span class="keyword">double</span> d);</span><br><span class="line">    MyClass(<span class="keyword">int</span> i, <span class="keyword">double</span> d);</span><br><span class="line">    MyClass();</span><br><span class="line">    ~MyClass();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">MyClass::MyClass(<span class="keyword">double</span> d)</span><br><span class="line">&#123;</span><br><span class="line">    myDouble = d;</span><br><span class="line">    myInt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">MyClass::MyClass(<span class="keyword">int</span> i, <span class="keyword">double</span> d)</span><br><span class="line">&#123;</span><br><span class="line">    myDouble = d;</span><br><span class="line">    myInt = i;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">MyClass::MyClass()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们尝试将一个double值赋给一个MyClass类对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass myClass;</span><br><span class="line">myClass = <span class="number">2.5</span>;</span><br></pre></td></tr></table></figure><p>这是可以的，首先创建了一个MyClass的对象，然后使用2.5将其初始化，实际上是使用了第一个构造函数 MyClass(double)，这是一个隐式转换的过程，不需要进行强制转换。</p><p>只有接受一个参数的构造函数才能作为转换函数，如果像第二个构造函数那样有两个参数，不能用来转换类型，但是如果第二个参数有默认参数，就可以：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass(<span class="keyword">int</span> i, <span class="keyword">double</span> d = <span class="number">1.5</span>);</span><br></pre></td></tr></table></figure><p>这个可以将一个int值隐式地转换成MyClass类型。</p><p>如果不希望编辑器进行这种隐式转换，可以使用explicit关键词修饰构造函数，这样就无法使用该构造函数进行类型转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="keyword">double</span> d)</span></span>;</span><br></pre></td></tr></table></figure><p>这样会关闭隐式转换，但依然允许显示转换，即使用显式地强制转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyClass myClass;</span><br><span class="line">myClass = MyClass(<span class="number">2.5</span>);</span><br><span class="line">myClass = (MyClass)<span class="number">2.5</span>;</span><br></pre></td></tr></table></figure><h2 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h2><p>上边提到了隐式或者显式地将基本数据类型的数据转换成类对象，接下来的问题是如何将一个类对象转换成其他的基本数据类型，这一点可以通过转换函数来实现。转换函数是用户定义的强制类型转换，需要这样定义：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">operator dateType()；</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ul><li>转换函数必须是类方法</li><li>转换函数不能指定返回类型</li><li>转换函数不能有参数</li></ul><p>比如我们将MyClass转换为一个double类型的变量，需要这样一个成员函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">MyClass::<span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> myDoble;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以这样使用类型转换了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyClass <span class="title">myClass</span><span class="params">(<span class="number">1</span>, <span class="number">2.5</span>)</span></span>;</span><br><span class="line"><span class="keyword">double</span> myDouble = (<span class="keyword">double</span>) myClass;</span><br><span class="line"><span class="keyword">double</span> myDouble = <span class="keyword">double</span> (myClass);</span><br></pre></td></tr></table></figure><h1 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h1><p>复制构造函数接受其所属类的对象作为参数。例如，MyClass类的复制构造函数的原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass(<span class="keyword">const</span> MyClass &amp;);</span><br></pre></td></tr></table></figure><p>在下述情况下，将使用复制构造函数：</p><ul><li>将新对象初始化为一个同类对象</li><li>按值将对象传递给函数</li><li>函数按值返回对象</li><li>编译器生成临时对象</li></ul><p>如果程序没有使用（显式或隐式）复制构造函数，编译器将提供原型，但不提供函数定义；否则，程序将定义一个执行成员初始化的复制构造函数。也就是说，新对象的每个成员都被初始化为原始对象相应成员的值。如果成员为类对象,则初始化该成员时，将使用相应类的复制构造函数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;类与接口&quot;&gt;&lt;a href=&quot;#类与接口&quot; class=&quot;headerlink&quot; title=&quot;类与接口&quot;&gt;&lt;/a&gt;类与接口&lt;/h1&gt;&lt;p&gt;类是一种将抽象转换为用户定义类型的C++工具，它将数据表示和操作数据的方法组合成一个整洁的包。接口提供给我们从外部访问类与类
      
    
    </summary>
    
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/categories/C/"/>
    
    
      <category term="学习笔记" scheme="https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【算法】（一）排序算法</title>
    <link href="https://blogs.littlegenius.xin/2019/08/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%B8%80%E6%8E%92%E5%BA%8F/"/>
    <id>https://blogs.littlegenius.xin/2019/08/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%B8%80%E6%8E%92%E5%BA%8F/</id>
    <published>2019-08-24T15:45:32.000Z</published>
    <updated>2019-08-24T15:50:37.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序算法的分类"><a href="#排序算法的分类" class="headerlink" title="排序算法的分类"></a>排序算法的分类</h1><ul><li>比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</li><li>非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。      </li></ul><p><img src="http://cdn.littlegenius.xin/Algorithm1-1.png" alt="算法的分类"></p><h1 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/Algorithm1-2.png" alt="算法的复杂度" title="">                </div>                <div class="image-caption">算法的复杂度</div>            </figure> <h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><ul><li>稳定：如果a原本在b前面，而a=b，排序之后 a 仍然在 b 的前面。</li><li>不稳定：如果a原本在b的前面，而a=b，排序之后 a      可能会出现在 b 的后面。</li><li>时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li><li>空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 </li></ul><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 </p><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ul><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序（Selection-sort）是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录      R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong>。</p><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k      趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li><li>缩小增量间隔的方法      grap=[grap/2]</li></ul><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><ul><li>从数列中挑出一个元素，称为      “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><ul><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ul><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ul><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序（Bucket sort）是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p><ul><li>设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序；</li><li>从不是空的桶里把排好序的数据拼接起来。 </li></ul><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p><ul><li>取得数组中的最大数，并取得位数</li><li>arr为原始数组，从最低位开始取每个位组成radix数组</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点） </li></ul><p><strong>参考</strong>：<a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener">https://www.cnblogs.com/onepixel/articles/7674659.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;排序算法的分类&quot;&gt;&lt;a href=&quot;#排序算法的分类&quot; class=&quot;headerlink&quot; title=&quot;排序算法的分类&quot;&gt;&lt;/a&gt;排序算法的分类&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因
      
    
    </summary>
    
    
      <category term="算法" scheme="https://blogs.littlegenius.xin/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="学习笔记" scheme="https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="算法" scheme="https://blogs.littlegenius.xin/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构】（五）堆</title>
    <link href="https://blogs.littlegenius.xin/2019/08/24/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%BA%94%E5%A0%86/"/>
    <id>https://blogs.littlegenius.xin/2019/08/24/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%BA%94%E5%A0%86/</id>
    <published>2019-08-24T07:03:50.000Z</published>
    <updated>2019-08-24T07:19:43.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h1><p><strong>堆</strong>（Heap）又称为<strong>优先队列</strong>（priority queue），在队列的基础上，堆允许所有队列中的元素不一定按照<strong>先进先出</strong>（FIFO）的规则进行，而是使得每个元素有一定的优先级，优先级高的先出队列。</p><blockquote><p>这类数据结构属于计算机科学中最雅致的一种</p></blockquote><p>优先队列至少存在两个重要的操作：</p><ul><li><code>insert</code>：插入，使得数据入队列，是一种有约束的enqueue操作</li><li><code>deleteMin</code>：删除最小项，找出、返回并删除优先队列中最小的元素，也就是最大优先级的元素，是一种有约束的dequeue操作</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-1.png" alt="优先队列" title="">                </div>                <div class="image-caption">优先队列</div>            </figure><h1 id="堆的简单实现"><a href="#堆的简单实现" class="headerlink" title="堆的简单实现"></a>堆的简单实现</h1><p>有几种简单而明显的方法实现优先队列。</p><ul><li>简单链表：在表头以O(1)执行插入操作，遍历该链表以O(N)删除最小元</li><li>始终有序的链表：插入代价以O(N)进行，删除操作以O(1)进行</li><li>二叉查找树：对插入和删除两种操作的平均运行时间都是O(log)。尽管插入是随机的，而删除则不是，但是并不影响这个结论，反复除去左子树中的结点（最小值）损害了树的平衡，使得右子树加重。在最坏情形下，即将左子树删空的情形下，右子树拥有的元素最多也就是它应具有的两倍，这只是在其期望的深度上加了一个小常数</li><li>ALV树：可能有些过分，因为它支持大量并不需要的操作</li></ul><h1 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h1><p><strong>二叉堆</strong>（binary heap）是一种对于优先队列的实现，可以简称为堆</p><h2 id="结构性质"><a href="#结构性质" class="headerlink" title="结构性质"></a>结构性质</h2><p>堆是一棵<strong>完全二叉树</strong>（complete binary tree），即所有节点都必须有左右两个子节点，除了最后一排元素从左向右填入，直到没有元素为止。</p><p>很显然，一棵高为h的完全二叉树有 2^h 到 2^(h+1)-1 个节点，即其高度为 logN 向下取整。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-2.png" alt="二叉堆" title="">                </div>                <div class="image-caption">二叉堆</div>            </figure><p>完全二叉树的好处在于其规律性，可以使用一个数组而不需要链表来表示</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-3.png" alt="二叉堆的数组表示" title="">                </div>                <div class="image-caption">二叉堆的数组表示</div>            </figure><p>对于数组中任一位置 i 上的元素，其左儿子在位置 2i 上，右儿子在左儿子后的单元 (2i+1) 上，它的父亲则在位置 i/2 向下取整上。</p><p>因此，不仅不需要链，而且遍历该树所需要的操作也极简单，在大部分计算机上都可能运行得非常快。唯一问题是最大的堆的大小需要事先估计。</p><h2 id="堆序性质"><a href="#堆序性质" class="headerlink" title="堆序性质"></a>堆序性质</h2><p>使操作可以快速执行的性质是<strong>堆序性质</strong>（heap-order property）：对于每一个节点X，X的父节点中的键小于等于X中的键，除没有父节点根节点外。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-4.png" alt="二叉堆" title="">                </div>                <div class="image-caption">二叉堆</div>            </figure><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="insert插入"><a href="#insert插入" class="headerlink" title="insert插入"></a>insert插入</h3><p>将待插入的元素首先放置在最后一个位置上，以保证他是一个完全二叉树，然后将该元素与其父节点（i/2向下取整）比较，如果比其父节点小，就将两者互换，互换后再和新的父节点比较，这种方式称为<strong>上滤</strong>（percolate up），得到一个小顶堆（min heap），如果比较的时候是较大的值向上走，就会得到一个大顶堆（max heap） </p><p>比如向一个小顶堆中插入元素14的操作：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-5.png" alt="小顶堆的插入" title="">                </div>                <div class="image-caption">小顶堆的插入</div>            </figure><h3 id="deleteMin删除"><a href="#deleteMin删除" class="headerlink" title="deleteMin删除"></a>deleteMin删除</h3><p>找出、返回并删除最小元非常简单，最小元就是根节点处的元素，将其返回并删除。接下来是处理这个B。首先拿下最后一个元素X，如果元素X比B的两个子节点都小，可以直接将X插入到B的位置，如果X比B的两个子节点中的任意一个大，就不能插入，此时找到两个子节点中较小的那个放到B处，B转而移至这个子结点处。重复如上的步骤直到X可以插入B处为止。这个操作成为<strong>下滤</strong>（percolate down）</p><p>比如从一个小顶堆中删除根节点</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-6.png" alt="从小顶堆中删除" title="">                </div>                <div class="image-caption">从小顶堆中删除</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-7.png" alt="从小顶堆中删除" title="">                </div>                <div class="image-caption">从小顶堆中删除</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-8.png" alt="从小顶堆中删除" title="">                </div>                <div class="image-caption">从小顶堆中删除</div>            </figure><h3 id="decreaseKey"><a href="#decreaseKey" class="headerlink" title="decreaseKey"></a>decreaseKey</h3><p><code>decreaseKey(p, A)</code> 操作减小在位置p处的元素的值，减少量为A，可以理解为调高了某个元素的优先级。操作破坏了堆的性质，从而需要上滤操作进行堆的调整。</p><h3 id="increaseKey"><a href="#increaseKey" class="headerlink" title="increaseKey"></a>increaseKey</h3><p><code>increaseKey(p, A)</code> 操作增加在位置p处的元素的值，增加量为A，可以理解为降低了某个元素的优先级。操作破坏了堆的性质，从而需要下滤操作进行堆的调整。</p><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p><code>remove(p)</code> 操作删除在堆中位置p处的节点，这种操作可以通过连续执行 <code>decreaseKey(p, ∞)</code> 和 <code>deleteMin()</code> 完成，可以理解马上删除某个一般优先级的元素</p><h3 id="buildHeap"><a href="#buildHeap" class="headerlink" title="buildHeap"></a>buildHeap</h3><p>即将一个原始集合构建成二叉堆，这个构造过程即进行N次连续的<code>insert</code>操作完成</p><p><strong>定理</strong>：包含 2^(h+1)-1 个节点且高度为h的理想二叉树（perfect binary tree）的节点的高度和为 2^(h+1)-1-(h+1)</p><h1 id="d堆"><a href="#d堆" class="headerlink" title="d堆"></a>d堆</h1><p><strong>d堆</strong>（d-Heaps）是二叉堆的简单推广，它与二叉堆很像，但是每个节点都有d个子节点，所以二叉堆是d为2的d堆。d堆是完全d叉树。比如下边的一个3堆。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-9.png" alt="一个3堆" title="">                </div>                <div class="image-caption">一个3堆</div>            </figure><p>d堆比二叉堆浅很多，其insert的运行时间改进到 O(logdN) 。但是deleteMin操作比较费时，因为要在d个子节点中找到最小的一个，需要进行d-1次比较。d堆无法进行find操作，而且将两个堆合二为一是很困难的事情，这个附加操作为merge合并。</p><p><strong>注意！</strong>在寻找节点的父节点、子节点的时候，乘法和除法都有因子d。如果d是一个2的幂，则可以通过使用二进制的<strong>移位</strong>操作计算，这在计算机中是非常省时间的。但是如果d不是一个2的幂，则使用一般的乘除法计算，时间开销会急剧增加。有证据显示，实践中，堆可以胜过二叉堆</p><h1 id="左式堆"><a href="#左式堆" class="headerlink" title="左式堆"></a>左式堆</h1><p>这些高级的数据结构很难使用一个数据结构来实现，所以一般都要用到链式数据结构，这种结构可能会使得其操作变慢。</p><h2 id="左式堆的定义"><a href="#左式堆的定义" class="headerlink" title="左式堆的定义"></a>左式堆的定义</h2><p><strong>零路径长</strong>（null path length）npl(X)：定义为从一个X节点到其不具有两个子节点的子节点的最短路径长，即具有0个或者1个子节点的节点npl=0，npl(null)=-1，任意节点的零路径长都比其各个子节点中零路径长最小值多1。</p><p><strong>左式堆</strong>（leftist heap）是指对于任意一个节点X，其左子节点的零路径长都大于等于其右子节点的零路径长。很显然，左式堆趋向于加深左路径。比如下边的两个堆，只有左边的是左式堆，堆的节点标示的是该节点的零路径长。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-10.png" alt="左式堆" title="">                </div>                <div class="image-caption">左式堆</div>            </figure><p>左式堆的实现中，需要有四个值：数据、左指针、右指针和零路径长。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LeftistHeap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Object data;</span><br><span class="line">    LeftistHeap* leftChild;</span><br><span class="line">    LeftishHeap* rightChild;</span><br><span class="line">    <span class="keyword">int</span> npl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定理</strong>：在右路径上有r个节点的左式堆必然至少有 2^r-1 个节点</p><h2 id="左式堆的合并"><a href="#左式堆的合并" class="headerlink" title="左式堆的合并"></a>左式堆的合并</h2><p><code>merge</code>是左式堆的基本操作，<code>insert</code>插入可以看成是一个单节点的堆与一个大堆的<code>merge</code>，<code>deleteMin</code>删除最小值操作可以看成是首先返回、删除根节点，然后将根节点的左右子树进行<code>merge</code>。所以<code>merge</code>是左式堆的基本操作。</p><p>假设现在有两个非空的左式堆H1和H2，merge操作递归地进行如下的步骤：</p><ul><li>将H1和H2中根节点较的堆（比如是H2）与根节点较小的堆（比如是H1）的右子堆进行merge</li><li>让新的merge的堆成为根节点较小的堆（H1）的右字堆</li><li>如果在根结点处出现左右子堆不符合左式堆的条件的情况，互换左右子堆的位置并更新npl的值</li></ul><p>例如如下的两个堆：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-11.png" alt="合并两个左式堆" title="">                </div>                <div class="image-caption">合并两个左式堆</div>            </figure><p>将H2与H1的右子树（8–17–26）进行merge操作，此时（8–17–26）和H2的merge操作中又需要（8–17–26）和H2的右子堆（7–37–18）进行merge操作……如此递归得到如下的堆：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-12.png" alt="合并两个左式堆" title="">                </div>                <div class="image-caption">合并两个左式堆</div>            </figure><p>然后根据递归的最外层（回到H1和H2的merge的第二步），将上边合并的堆成为H1的右子堆</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-13.png" alt="合并两个左式堆" title="">                </div>                <div class="image-caption">合并两个左式堆</div>            </figure><p>此时根节点（3）处出现了左右子堆不符合左式堆的情况，互换左右子堆并更新零路径长的值</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-14.png" alt="合并两个左式堆" title="">                </div>                <div class="image-caption">合并两个左式堆</div>            </figure><h1 id="斜堆"><a href="#斜堆" class="headerlink" title="斜堆"></a>斜堆</h1><p><strong>斜堆</strong>（skew heap）是左式堆的自调节形式，实现起来极其简单。斜堆和左式堆的关系类似于伸展树和AVL树之间的关系。斜堆是具有堆序的二叉树，但是不存在对树的结构的现限制。不同于左式堆，关于任意结点的零路径长的任何信息都不保留。斜堆的右路径在任何时刻都可以任意长，因此，所有操作的最坏情形运行时间均为O(N)。然而，正如伸展树一样，可以证明对任意M次连续操作，总的最坏情形运行时间是 O(MlogN)。因此，斜堆每次操作的<strong>摊还开销</strong>（amortized cost）为O(logN)</p><h2 id="斜堆的合并"><a href="#斜堆的合并" class="headerlink" title="斜堆的合并"></a>斜堆的合并</h2><p>斜堆的基本操作也是merge合并，和左式堆的合并相同，但是不需要对不满足左右子堆的左式堆条件的节点进行左右子堆的交换。斜堆的交换是无条件的，除右路径上所有节点的最大者不交换它的左右儿子外，都要进行这种交换。</p><p>比如将上述的H1和H2进行merge合并操作</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-15.png" alt="合并两个斜堆" title="">                </div>                <div class="image-caption">合并两个斜堆</div>            </figure><p>首先进行第一步，除了交换左右子树的操作与左式堆不同，其他的操作都相同</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-16.png" alt="合并两个斜堆" title="">                </div>                <div class="image-caption">合并两个斜堆</div>            </figure><p>将合并的堆作为H1的右子堆并交换左右子堆，得到合并后的斜堆</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-17.png" alt="合并两个斜堆" title="">                </div>                <div class="image-caption">合并两个斜堆</div>            </figure><h1 id="二项队列"><a href="#二项队列" class="headerlink" title="二项队列"></a>二项队列</h1><p><strong>二项队列</strong>（binomial queue）支持merge、insert和deleteMin三种操作，并且每次操作的最坏情形运行时间为O(logN)，插入操作平均花费常数时间。</p><h2 id="二项队列的结构"><a href="#二项队列的结构" class="headerlink" title="二项队列的结构"></a>二项队列的结构</h2><p>二项队列不是一棵堆序的树，而是堆序的树的集合，成为<strong>森林</strong>（forest）。堆序树中的每一棵都是有约束的<strong>二项树</strong>（binomial tree）。二项树是每一个高度上至多存在一棵二项树。高度为0的二项树是一棵单节点树，高度为k的二项树Bk通过将一棵二项树Bk-1附接到另一棵二项树Bk-1的根上而构成的。如下图的二项树B0、B1、B2、B3和B4。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-18.png" alt="二项树" title="">                </div>                <div class="image-caption">二项树</div>            </figure><p>可以看到二项树Bk由一个带有儿子B0，B1，……，Bk-1的根组成。高度为k的二项树恰好有2^k个节点，而在深度d处的节点数为二项系数Cdk。</p><p>我们可以使用二项树的集合唯一地表示任意大小的优先队列。以大小为13的队列为例，13的二进制表示为1101，从而我们可以使用二项树森林B3、B2、B0表示，即二进制表示的数中，第k位为1表示Bk树出现，第k位为0表示Bk树不出现。比如上述的堆H1和堆H2可以表示为如下的两个二项队列：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-19.png" alt="H1和H2的二项队列表示" title="">                </div>                <div class="image-caption">H1和H2的二项队列表示</div>            </figure><h2 id="二项队列的合并"><a href="#二项队列的合并" class="headerlink" title="二项队列的合并"></a>二项队列的合并</h2><p>二项队列额merge合并操作非常简单，以上边的二项队列H1、H2为例。需要将其合并成一个大小为13的队列，即B3、B2、B0。</p><p>首先H2中有一个B0，H1中没有，所以H2中的B0可以直接作为新的队列的B0的树</p><p>其次H1和H2中两个B1的树可以合并成一个新的B2的树，只需要将其中根节点较小的堆挂到根节点较大的堆的根节点上。这样就得到了三棵B2堆，将其中根节点最大的堆直接放到新队列中成为它的B2堆。</p><p>最后将两个B2堆合并成一个新队列中的B3堆。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-20.png" alt="二项队列的合并" title="">                </div>                <div class="image-caption">二项队列的合并</div>            </figure><p>二项队列的deleteMin很简单，只需要比较队列中所有二项堆的根节点，返回和删除最小的值即可，时间复杂度为O(logN)，然后进行一次merge操作，也可以使用一个单独的空间每次记录最小值，这样就可以以O(1)的时间返回。 </p><h2 id="二项队列的实现"><a href="#二项队列的实现" class="headerlink" title="二项队列的实现"></a>二项队列的实现</h2><p>森林中树的实现采用“左子右兄弟”的表示方法，然后二项队列可以使用一个数组来记录森林中每个树的根节点。</p><p>例如上边的合成的二项队列可以表示成如下的样子：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-21.png" alt="二项堆列的实现" title="">                </div>                <div class="image-caption">二项堆列的实现</div>            </figure><h1 id="标准库中的优先队列"><a href="#标准库中的优先队列" class="headerlink" title="标准库中的优先队列"></a>标准库中的优先队列</h1><p>STL中，二叉堆是通过<code>priority_queue</code>模板类实现的，在头文件<code>queue</code>中，STL实现一个大顶堆而不是小顶堆，其关键的成员函数如下：</p><ul><li><code>void push( const object &amp; x );</code></li><li><code>const Object &amp; top( ) const;</code></li><li><code>void pop( );</code></li><li><code>bool empty( );</code></li><li><code>void clear( );</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;堆（Heap）&quot;&gt;&lt;a href=&quot;#堆（Heap）&quot; class=&quot;headerlink&quot; title=&quot;堆（Heap）&quot;&gt;&lt;/a&gt;堆（Heap）&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;堆&lt;/strong&gt;（Heap）又称为&lt;strong&gt;优先队列&lt;/strong&gt;（p
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://blogs.littlegenius.xin/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习笔记" scheme="https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/tags/C/"/>
    
      <category term="数据结构" scheme="https://blogs.littlegenius.xin/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构】（四）散列</title>
    <link href="https://blogs.littlegenius.xin/2019/08/19/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%9B%9B%E6%95%A3%E5%88%97/"/>
    <id>https://blogs.littlegenius.xin/2019/08/19/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%9B%9B%E6%95%A3%E5%88%97/</id>
    <published>2019-08-19T15:22:06.000Z</published>
    <updated>2019-08-19T15:30:28.470Z</updated>
    
    <content type="html"><![CDATA[<p><strong>哈希</strong>（hashing）又称散列，是实现散列表的技术。散列是一种用于以常数平均时间执行插入、删除和查找的技术，因此涉及到元素间排序信息的操作不会得到支持，如树的<code>findMin</code>、<code>findMax</code>以及按照顺序打印列表这些操作散列是不支持的。</p><h1 id="散列的基本思想"><a href="#散列的基本思想" class="headerlink" title="散列的基本思想"></a>散列的基本思想</h1><p>散列是一个固定大小的数组，存储的是键值对（Key–Value），键一般是好操作的数据，值一般存储比较大的实际意义强的数据，键的存在是便于使用键进行数据的查找。</p><p>散列的基本思想是使用一个对应关系（映射关系），这里称之为<strong>散列函数</strong>（hashing function），将哈希表的存储位置（0到TableSize-1）与键做一个对应，理想情况下是得到一个一一映射。但是这是不可能的，从而还需要确定一个方案来解决当两个键都被对应到同一个存储位置上时的情况，这个过程叫做解决冲突（collision）</p><h1 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h1><ul><li>如果键时整数，一般使用 <code>Key mod TableSize</code> 作为对应的索引。通常，为了使哈希的分布均匀，通常采取素数大小的哈希表，当输入的键是随机整数的时候，散列函数不仅运算简单而且键的分配也很均匀</li><li>如果键时字符串<ul><li>一种策略是将字符串中字符的ASCLL码值求和，然后使用整数策略，这种方式不够均匀</li><li>一种策略是取字符串的前几位的ASCLL码值求和，然后使用整数策略，这种方式不够均匀</li><li>一种较好的策略是递归地求 <code>h = k0+37 k1+37^2 k2</code> 作为键，或者对一些选取的字符（而不是整个字符串）采用如上的策略</li></ul></li></ul><h1 id="解决冲突的方法"><a href="#解决冲突的方法" class="headerlink" title="解决冲突的方法"></a>解决冲突的方法</h1><p>无论如何设计散列函数，都能保证对于任何一个键都可以找到唯一的存储索引而不发生冲突，所以解决冲突是哈希实现的关键</p><h2 id="分离链接法"><a href="#分离链接法" class="headerlink" title="分离链接法"></a>分离链接法</h2><p>分离链接法（separate chaining）将散列到同一个值的所有元素保存到一个链表中</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure5-1.png" alt="分离链接法" title="">                </div>                <div class="image-caption">分离链接法</div>            </figure><p>这种方式的缺点是使用了一些链表，所以给新单元分配地址需要较多的时间开销。</p><h2 id="探测散列表"><a href="#探测散列表" class="headerlink" title="探测散列表"></a>探测散列表</h2><p>一般为了减少使用链表带来的较大的时间开销，通常避免使用链表，而将所有的数据都放入表内，所以这种方式需要散列表要比较大才行。一般要求装填的数据和总数据含量之比小于0.5，这样的表成为探测散列表（probing hash tables）。</p><p>探测散列表的散列函数为 h(x)=(hash(x)+f(i)) mod TableSize 且 f(0)=0，说白了就是如果应该在的位置冲突了，就按照一定的规律去找下一个空位置，以此类推。根据寻找下一个空位置的方式不同可以分为如下的几种探测方式。</p><h3 id="线性探测（Linear-Probing）"><a href="#线性探测（Linear-Probing）" class="headerlink" title="线性探测（Linear Probing）"></a>线性探测（Linear Probing）</h3><p>f(i)=i，当一个位置出现冲突时，顺序查找下一个位置，直到找到一个空位置为止</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure5-2.png" alt="线性探测" title="">                </div>                <div class="image-caption">线性探测</div>            </figure><h3 id="平方探测（Quadratic-Probing）"><a href="#平方探测（Quadratic-Probing）" class="headerlink" title="平方探测（Quadratic Probing）"></a>平方探测（Quadratic Probing）</h3><p>f(i)=i^2，即冲突函数为二次函数的探测方法</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure5-3.png" alt="二次探测" title="">                </div>                <div class="image-caption">二次探测</div>            </figure><p>关于二次探测，这里有一个<strong>定理</strong>：如果表的大小是素数，那么当表至少有一半是空的时候，总能够插入一个新的元素</p><h2 id="双散列（Double-Hashing）"><a href="#双散列（Double-Hashing）" class="headerlink" title="双散列（Double Hashing）"></a>双散列（Double Hashing）</h2><p>双散列（Double Hashing）也是一种解决冲突的方式，对于双散列，一种流行的方式是选择 f(i)=i*hash’(x), hash’(x)=R-(x  mod R), 其中R通常选取一个素数。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure5-4.png" alt="双散列" title="">                </div>                <div class="image-caption">双散列</div>            </figure><h2 id="再散列（Rehashing）"><a href="#再散列（Rehashing）" class="headerlink" title="再散列（Rehashing）"></a>再散列（Rehashing）</h2><p>再散列（Rehashing）的思想是当一个散列表将要被耗尽时，建立一个新的比原来的表大约两倍的表并且使用新的散列函数，将原表中的数据通过新的散列函数安排到新表中。例如下边的例子：</p><p>首先有一个大小为7的散列表：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure5-5.png" alt="再散列例子" title="">                </div>                <div class="image-caption">再散列例子</div>            </figure><p>向这个表中插入数据23，得到了如下的表，由于此时数据已占用超过70%，从而创建一个新的大小为17的散列表。新的表的选取，是按照原来的散列表的二倍的后边第一个素数来规定。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure5-6.png" alt="再散列例子" title="">                </div>                <div class="image-caption">再散列例子</div>            </figure><p>将原来哈希表中的五个数据根据 key mod 17 再重新计算位置，添加到新的散列中去</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure5-7.png" alt="再散列例子" title="">                </div>                <div class="image-caption">再散列例子</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;哈希&lt;/strong&gt;（hashing）又称散列，是实现散列表的技术。散列是一种用于以常数平均时间执行插入、删除和查找的技术，因此涉及到元素间排序信息的操作不会得到支持，如树的&lt;code&gt;findMin&lt;/code&gt;、&lt;code&gt;findMax&lt;/code&gt;
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://blogs.littlegenius.xin/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习笔记" scheme="https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/tags/C/"/>
    
      <category term="数据结构" scheme="https://blogs.littlegenius.xin/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构】（三）树</title>
    <link href="https://blogs.littlegenius.xin/2019/08/19/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%B8%89%E6%A0%91/"/>
    <id>https://blogs.littlegenius.xin/2019/08/19/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%B8%89%E6%A0%91/</id>
    <published>2019-08-18T16:16:53.000Z</published>
    <updated>2019-08-19T15:30:22.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="树的实现"><a href="#树的实现" class="headerlink" title="树的实现"></a>树的实现</h2><p>实现树时，对于每一个节点，除了存储该节点的数据以外，还需要存储一些外链。</p><p>一个典型的存储方式是：左孩子右兄弟法，即对于每一个节点，存储节点的数据、指向其孩子中最左边的孩子的指针、指向其紧邻的右侧的兄弟节点的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Object element;</span><br><span class="line">    TreeNode * firstChild;</span><br><span class="line">    TreeNode * nextSiling;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如下边的这棵树通过这种方式表现的结果是这样的：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure4-1.png" alt="采用“左子右兄弟”表示树" title="">                </div>                <div class="image-caption">采用“左子右兄弟”表示树</div>            </figure><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>二叉树（binary tree）是一棵每个节点都不能有多于两个儿子的树</p><h2 id="二叉树的特点"><a href="#二叉树的特点" class="headerlink" title="二叉树的特点"></a>二叉树的特点</h2><ul><li>二叉树第i层上至多有 2i-1 个节点</li><li>深度为k的二叉树至多有 2k-1 个节点</li><li>对于一棵非空二叉树，如果其叶子节点数为n0，度为2的节点数为n2，则n0=n2+1</li><li>具有n个节点的完全二叉树的深度为 [log2n]+1      (向下取整数)</li><li>如果对于n个节点的完全二叉树，第 i&gt;0      的节点，其父节点为 [(i-1)/2] (向下取整)</li></ul><p>二叉树的一个性质是平均二叉树的深度要比结点个数N小得多，这个性质有时很重要。分析表明，这个平均深度为O(√N)，而对于特殊类型的二叉树，即二叉查找树( binary search tree)，其深度的平均值是O(logN)。当然极端的树的深度也可以大到N-1。</p><h2 id="二叉树的实现"><a href="#二叉树的实现" class="headerlink" title="二叉树的实现"></a>二叉树的实现</h2><p>由于二叉树的每个节点最多有两个儿子，所以可以直接连接到它们。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Object element;</span><br><span class="line">    BinaryNode * left;</span><br><span class="line">    BinaryNode * red;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><p>二叉查找树（Binary Search Trees）是二叉树，它的特点是：对于任何一个节点X，其左子树中的所有节点的值都小于该节点X，其右子树中的所有节点的值都大于该节点X。如下图中的左边就是一棵二叉查找是，而右侧不是：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure4-2.png" alt="二叉查找树" title="">                </div>                <div class="image-caption">二叉查找树</div>            </figure><h2 id="重要的方法与其实现"><a href="#重要的方法与其实现" class="headerlink" title="重要的方法与其实现"></a>重要的方法与其实现</h2><ul><li><code>isEmpty</code>：是否为空树，这一点很重要，一般在进行树的相关操作时都会先确定是否是一个空树，只要指向根节点的指针为<code>NULL</code>，就表示是一个空树</li><li><code>contains</code>：是否包含某项，在确定树非空后，查找是否包含某个项，将目标项与根节点进行比较开始，如果比该节点大，就从右子树查找，如果比该节点小，就从左子树查找，如果出现相等的则表示包含该项，如果一直不相等且无子树可以继续查找，则不包含此项</li><li><code>findMin</code>：找到最小值，一直找左子树，直到找到没有左子树的左子树最左边的节点就是最小值</li><li><code>findMax</code>：找到最大值，一直找右子树，直到找到没有右子树的右子树最右边的节点就是最大值</li><li><code>insert</code>：插入某个值，从根节点开始比较，如果目标值比该节点大就插入其右子树，否则插入左子树，如果出现相等的情况说明有该元素不需要再插入，直到插入某个空节点为止</li><li><code>remove</code>：删除节点<ul><li>删除叶子节点：直接删除</li><li>删除有一个子节点的节点：将该子节点挂到被删除的节点的父节点上，取代删除节点的位置<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure4-3.png" alt="删除只有一个子节点的子节点" title="">                </div>                <div class="image-caption">删除只有一个子节点的子节点</div>            </figure></li><li>删除有两个子节点的节点：找到该节点右子树中的最小值或者左子树中的最大值，将其替换要删除的元素，然后递归地删除用来替换的最大/小值，为什么是递归地删除呢？因为被拿出来替换被删除值的那个最大/小值也会有子树，所以删除它的时候还要执行删除remove操作。但是最多只进行一次单子节点的删除工作，因为无论是右子树中的最小值还是左子树中的最大值，最多只有一个子树<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure4-4.png" alt="删除有两个子节点的子节" title="">                </div>                <div class="image-caption">删除有两个子节点的子节</div>            </figure></li></ul></li></ul><h2 id="平均情况分析"><a href="#平均情况分析" class="headerlink" title="平均情况分析"></a>平均情况分析</h2><table><thead><tr><th align="center">操作</th><th align="center">平均时间复杂度</th></tr></thead><tbody><tr><td align="center">isEmpty</td><td align="center">O(1)</td></tr><tr><td align="center">contains</td><td align="center">O(logN)</td></tr><tr><td align="center">findMin/findMax</td><td align="center">O(logN)</td></tr><tr><td align="center">insert</td><td align="center">O(logN)</td></tr><tr><td align="center">remove</td><td align="center">O(1)</td></tr></tbody></table><h1 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h1><p>AVL（Adelson-Velskii and Landis）树是带有平衡条件（balance condition）的二叉查找树，这个平衡条件很容易保持并且保证了树的深度为O(logN)。</p><p>AVL树要求每个节点的左子树和右子树的高度差最多为1。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure4-5.png" alt="AVL树" title="">                </div>                <div class="image-caption">AVL树</div>            </figure><p>AVL树除了插入操作外，其他所有的操作都可以最多以O(logN)的时间执行</p><h2 id="AVL树的插入"><a href="#AVL树的插入" class="headerlink" title="AVL树的插入"></a>AVL树的插入</h2><p>AVL树的插入比较复杂的点在于插入的值可能会破坏树原本的平衡，所以在插入值后需要进行<strong>旋转</strong>（rotation）</p><p>旋转的情况可以根据插入后的树的情况分为如下四种：</p><blockquote><p>示意图来源：<a href="https://blog.csdn.net/gabriel1026/article/details/6311339" target="_blank" rel="noopener">https://blog.csdn.net/gabriel1026/article/details/6311339</a></p></blockquote><table><thead><tr><th align="center">插入后的情况</th><th align="center">描述</th><th align="center">旋转方式</th></tr></thead><tbody><tr><td align="center">LL-左子树左高</td><td align="center">在左子树根节点的左子树上插入节点而破坏平衡</td><td align="center">右旋转</td></tr><tr><td align="center">RR-右子树右高</td><td align="center">在右子树根节点的右子树上插入节点而破坏平衡</td><td align="center">左旋转</td></tr><tr><td align="center">LR-左子树右高</td><td align="center">在左子树根节点的右子树上插入节点而破坏平衡</td><td align="center">先左旋后右旋</td></tr><tr><td align="center">RL-右子树左高</td><td align="center">在右子树根节点的左子树上插入节点而破坏平衡</td><td align="center">先右旋后左旋</td></tr></tbody></table><ul><li>LL-左子树左高的情况  <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure4-6.png" alt="LL-左子树左高" title="">                </div>                <div class="image-caption">LL-左子树左高</div>            </figure></li><li>RR-右子树右高的情况  <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure4-7.png" alt="RR-右子树右高" title="">                </div>                <div class="image-caption">RR-右子树右高</div>            </figure></li><li>LR-左子树右高的情况  <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure4-8.png" alt="LR-左子树右高" title="">                </div>                <div class="image-caption">LR-左子树右高</div>            </figure></li><li>RL-右子树左高的情况  <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure4-9.png" alt="RL-右子树左高" title="">                </div>                <div class="image-caption">RL-右子树左高</div>            </figure></li></ul><h1 id="伸展树"><a href="#伸展树" class="headerlink" title="伸展树"></a>伸展树</h1><h2 id="伸展树与摊还时间"><a href="#伸展树与摊还时间" class="headerlink" title="伸展树与摊还时间"></a>伸展树与摊还时间</h2><p>伸展树（splay tree）保证从空树开始任意连续M此对树的操作最多花费O(MlogN)的时间，即这M次连续的操作中即使有些操作耗时长，但是也有一些耗时短的操作，使得这M个连续的操作花费的总时间最坏为O(MlogN)。</p><p><strong>摊还</strong>（amortized）：一般说来，当M次操作的序列总的最坏情形运行时间为O(M f(N))时,我们就说它的摊还(amortized)运行时间为O(f(N))。因此，一棵伸展树每次操作的摊还代价是O(logN)。经过一系列的操作，有的操作可能花费时间多一些，有的可能要少一些，不存在不好的输入队列。 </p><p>如果任意特定操作可以有最坏时间界O(N)，而我们仍然要求一个O(logN)的摊还时间界，那么很清楚，只要有一个结点被访问，它就必须被移动。否则，一旦我们发现一个深层的结点，就有可能不断地对它进行访问。如果这个结点不改变位置，而每次访问又花费O(N)，那么M次访问将花费O(MN)的时间。这个思想和数据库中将经常访问到的数据前移以及操作系统中将经常访问的数据放入cache高速缓存等思想相同。（在许多应用中，当一个结点被访问时，它就很可能不久再被访问。研究表明，这种情况的发生比人们预料的要频繁得多。）</p><h2 id="伸展（splaying）"><a href="#伸展（splaying）" class="headerlink" title="伸展（splaying）"></a>伸展（splaying）</h2><p>伸展树的基本思想是将访问到的一个较深的节点通过旋转的方式将其旋转到根节点的位置，但是为了保证旋转过程中不让一些较浅的节点也被沦落到较深的位置，这里的伸展采用一定的策略：</p><ul><li>首先，一个要被旋转到树根处的深节点X，如果X的父节点就是根节点，那么只要旋转X和树根即可</li><li>如果X的父节点不是根节点，将其父节点命名为P，同时X一定有祖父节点G，X、P、G三个节点存在两种排列关系：<ul><li>“之字形”（zig-zag）：这种情况下执行一次AVL树同理的双旋转<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure4-10.png" alt="“之字形”（zig-zag）" title="">                </div>                <div class="image-caption">“之字形”（zig-zag）</div>            </figure></li><li>“一字形”（zig-zig）：这种情况下直接将树左右对调（类似于跷跷板）<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure4-11.png" alt="“一字形”（zig-zig）" title="">                </div>                <div class="image-caption">“一字形”（zig-zig）</div>            </figure></li></ul></li></ul><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>如下图，想把 K1 节点调至树根处</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure4-12.png" alt="一个伸展树的例子" title="">                </div>                <div class="image-caption">一个伸展树的例子</div>            </figure><p>首先由K1、K2、K3构成了一个“之字形”结构，使用双旋转方式得到如下的第一次调整</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure4-13.png" alt="一个伸展树的例子" title="">                </div>                <div class="image-caption">一个伸展树的例子</div>            </figure><p>然后由K1、K4、K5构成了一个“一字形”结构，采用跷跷板的方式做第二次调整</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure4-14.png" alt="一个伸展树的例子" title="">                </div>                <div class="image-caption">一个伸展树的例子</div>            </figure><h1 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h1><p>树的遍历分为三种</p><ul><li>先根遍历：每棵树按照 根-左子树-右子树 顺序遍历</li><li>中根遍历：每棵树按照 左子树-根-右子树 顺序遍历</li><li>后根遍历：每棵树按照 左子树-右子树-根 顺序遍历</li></ul><h1 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h1><p>B树的思想很简单，如果我们使用二叉树，树的平均深度为logN，如果我们是一个M叉树（每个节点最多有M个子树），则树的平均深度为logMN，显然这样会使得树的深度降低。</p><h2 id="M阶B树的规范"><a href="#M阶B树的规范" class="headerlink" title="M阶B树的规范"></a>M阶B树的规范</h2><ul><li>数据项存储在树叶上</li><li>非叶结点存储直到 M-1 个键，以指示搜索的方向；键 i 代表子树 i+1 中的最小的键</li><li>树的根或者是一片树叶，或者其儿子数在2和M之间</li><li>除根外，所有非树叶结点的儿子数在 [M/2]（向上取整）和M之间</li><li>所有的树叶都在相同的深度上并有 [L/2]（向上取整）和L之间个数据项</li></ul><h2 id="一个5阶B树的例子"><a href="#一个5阶B树的例子" class="headerlink" title="一个5阶B树的例子"></a>一个5阶B树的例子</h2><p>一个5阶的B树，所有的非叶子节点的儿子都在3和5之间，从而有2到4个键，根可能只有两个的儿子，L=5，因此每个树叶有3到5个数据项，要求节点一半满，保证B树不致退化成简单的二叉树</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure4-15.png" alt="一个5阶B树的例子" title="">                </div>                <div class="image-caption">一个5阶B树的例子</div>            </figure><p>向B树中插入 57 数据项：按照键索引到插入数据的位置，插入数据项</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure4-16.png" alt="一个5阶B树的例子" title="">                </div>                <div class="image-caption">一个5阶B树的例子</div>            </figure><p>再插入 55  数据项，导致该叶子节点数据超出5，所以需要分裂其父节点成为两个叶子</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure4-17.png" alt="一个5阶B树的例子" title="">                </div>                <div class="image-caption">一个5阶B树的例子</div>            </figure><p>再插入 40 数据项，引起树叶被分裂成两片然后又造成父结点的分裂</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure4-18.png" alt="一个5阶B树的例子" title="">                </div>                <div class="image-caption">一个5阶B树的例子</div>            </figure><p>从B树中删除 99 数据项导致叶子节点的数据少于3从而合并叶子，而父节点也少于3从而再一次合并</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure4-19.png" alt="一个5阶B树的例子" title="">                </div>                <div class="image-caption">一个5阶B树的例子</div>            </figure><h1 id="标准库（SLT）中的set和map"><a href="#标准库（SLT）中的set和map" class="headerlink" title="标准库（SLT）中的set和map"></a>标准库（SLT）中的set和map</h1><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set是一个排序后的容器，不允许重复。set特有的操作是高效的插入、删除和执行基本查找。set也允许使用iterator来遍历。</p><h3 id="set的方法"><a href="#set的方法" class="headerlink" title="set的方法"></a>set的方法</h3><ul><li>与<code>vector</code>和<code>list</code>相同的方法<ul><li><code>iterator begin()</code>：返回容器开始的迭代器</li><li><code>iterator end()</code>：返回容器结尾处的迭代器</li><li><code>int size() const</code>：返回容器内的元素个数</li><li><code>bool empty()</code>：如果容器没有元素，返回 <code>true</code>，否则返回 <code>false</code></li></ul></li><li>特有的插入操作，<code>set</code>使用<code>insert</code>进行插入操作，由于非重复性，导致插入有可能会失败，<code>insert</code>操作返回一个<code>iterator</code>指明插入新项的位置或者失败时已有的项的位置.。pair是一个类模板，并且提供两个成员 first 和 second 用来访问返回值的两项成员<ul><li><code>pair&lt;iterator, bool&gt; insert( const Object &amp; x);</code> ：插入Object x</li><li><code>pair&lt;iterator, bool&gt; insert( iterator hint, const Object &amp; x);</code>：在指定索引hint处插入Object x，比单参数的插入快得多，通常为O(1)</li></ul></li><li><code>erase</code>删除操作<ul><li><code>int erase( const Object &amp; x);</code> ：删除x，如果找到的话，返回删除元素的个数，显然只能返回0或者1</li><li><code>iterator erase( iterator itr);</code>：删除有iterator指定的位置的对象</li><li><code>iterator erase( iterator start, iterator end);</code>：删除由两个iterator指定的位置对象中间包含的所有元素，包含前不包含后</li></ul></li><li><code>find</code>查找操作<ul><li><code>iterator find( const Object &amp; x) const;</code>：查找x返回其位置</li></ul></li></ul><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map用来存储排序后的由键和值组成的项的集合，键必须唯一，但是多个键可以同时对应一个值，即值不需要唯一，键保持逻辑排序后的顺序</p><h3 id="map的方法"><a href="#map的方法" class="headerlink" title="map的方法"></a>map的方法</h3><p>map的方法和set很像，但是其返回值是一个键-值对： <code>pair&lt;KeyType, ValueType&gt;</code>，map支持 <code>begin</code>、<code>end</code>、<code>size</code>、<code>enmty</code>、<code>insert</code>、<code>find</code>、<code>erase</code>、<code>find</code></p><ul><li><code>insert</code>操作必须提供 <code>pair&lt;KeyType, ValueType&gt;</code> 对象</li><li><code>find</code>仅需要一个键，但是返回值的<code>iterator</code>还是指向一个 <code>pair&lt;KeyType, ValueType&gt;</code> 对象，并可以用 <code>first</code> 访问返回的键，使用 <code>second</code> 访问返回的值</li></ul><p>map还重载了数组索引的操作符 <code>[]</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ValueType &amp; <span class="keyword">operator</span>[] ( <span class="keyword">const</span> KeyType &amp; key );</span><br></pre></td></tr></table></figure><p>如果map中存在key就返回只想相应值的引用，如果不存在key就在map中插入一个默认的值，然后返回指向这个插入的默认值的引用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;树&quot;&gt;&lt;a href=&quot;#树&quot; class=&quot;headerlink&quot; title=&quot;树&quot;&gt;&lt;/a&gt;树&lt;/h1&gt;&lt;h2 id=&quot;树的实现&quot;&gt;&lt;a href=&quot;#树的实现&quot; class=&quot;headerlink&quot; title=&quot;树的实现&quot;&gt;&lt;/a&gt;树的实现&lt;/h2&gt;&lt;p
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://blogs.littlegenius.xin/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习笔记" scheme="https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/tags/C/"/>
    
      <category term="数据结构" scheme="https://blogs.littlegenius.xin/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【C++温故知新】（五）多文件架构与名称空间</title>
    <link href="https://blogs.littlegenius.xin/2019/08/18/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E4%BA%94%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4/"/>
    <id>https://blogs.littlegenius.xin/2019/08/18/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E4%BA%94%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4/</id>
    <published>2019-08-18T03:21:51.000Z</published>
    <updated>2019-08-18T03:27:18.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="头文件与源文件"><a href="#头文件与源文件" class="headerlink" title="头文件与源文件"></a>头文件与源文件</h1><p>一般我们将大量公用的代码段存放在头文件中，然后使用其他源文件引用这个头文件，从而使得很多代码段不需要在每个源文件中都书写一遍。一种推荐的策略是这样的，将整个项目/程序包分为三个部分：</p><ul><li>头文件（.h）：包含结构体等数据类型的声明，类的框架、函数原型等等抽象而公用的部分</li><li>源代码文件（.cpp）：负责头文件中的抽象部分的具体化，如函数的主体、类的实现等</li><li>源代码文件（.cpp）：负责调用头文件中的函数以及实例化类模型等从而完成项目逻辑</li></ul><p>头文件中不要包含函数的定义或者变量的声明，头文件中一般只包含如下的部分：</p><ul><li>函数原型</li><li>使用 #define 或 const 定义的符号常量</li><li>结构声明</li><li>类声明</li><li>模板声明</li><li>内联函数</li></ul><p>头文件通常的书写架构如下，例如我们创建了一个命名为 headFile.h 的头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HEADFILE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEADFILE_H_</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// the head file</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>对头文件与源代码文件编译时是单独编译的，编译器会创建每个源代码文件的目标代码文件，生成 <strong>.o</strong> 后缀的文件，然后使用连接器将两个部分连接起来，将库代码和启动代码合并，生成一个 <strong>.out</strong> 后缀的文件，进而生成 <strong>.exe</strong> 后缀的可执行文件。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/CPP5-1.png" alt="多文件编译的过程" title="">                </div>                <div class="image-caption">多文件编译的过程</div>            </figure><h1 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h1><p>名称空间可以理解为为了区分不同的库类不同的厂商的代码中所包含的同命名的变量、函数等来问题的。例如我的程序包含了两个厂家开发的库，但这两个库中都有一个名为 List 的类，为了区分使用哪个厂家的类，就需要这两个厂家将自己的 List 类封装在自己的名称空间中，从而方便区分。 </p><h2 id="名称空间的创建"><a href="#名称空间的创建" class="headerlink" title="名称空间的创建"></a>名称空间的创建</h2><p>我们自己也可以创建名称空间，例如我们声明一个int类型的变量myInt，将其放在我们定义的一个名称空间MHZ中，可以这样写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> MHZ</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> myInt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="名称空间的使用"><a href="#名称空间的使用" class="headerlink" title="名称空间的使用"></a>名称空间的使用</h2><p>如果我想在我的程序中调用名称空间<code>MHZ</code>中的<code>myInt</code>变量，需要使用该名称空间，有以下的一些方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译使用整个名称空间</span></span><br><span class="line"><span class="comment">// 这种方式最不安全</span></span><br><span class="line"><span class="comment">// 因为会将整个名称空间的内容全部编译使用</span></span><br><span class="line"><span class="comment">// 很容易出现不同名称空间重名的问题</span></span><br><span class="line"><span class="keyword">using</span> MHZ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; myInt;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 指定编译使用名称空间中的某个变量/函数等</span></span><br><span class="line"><span class="comment">// 这种方式相对安全</span></span><br><span class="line"><span class="comment">// 使用哪个因素就声明那个因素</span></span><br><span class="line"><span class="keyword">using</span> MHZ::myInt;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; myInt;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在调用的时候指明名称空间</span></span><br><span class="line"><span class="comment">// 这种方式虽然繁琐，但是最不容易出错</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; MHZ::myInt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;头文件与源文件&quot;&gt;&lt;a href=&quot;#头文件与源文件&quot; class=&quot;headerlink&quot; title=&quot;头文件与源文件&quot;&gt;&lt;/a&gt;头文件与源文件&lt;/h1&gt;&lt;p&gt;一般我们将大量公用的代码段存放在头文件中，然后使用其他源文件引用这个头文件，从而使得很多代码段不需要
      
    
    </summary>
    
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/categories/C/"/>
    
    
      <category term="学习笔记" scheme="https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【C++温故知新】（四）函数</title>
    <link href="https://blogs.littlegenius.xin/2019/08/12/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E5%9B%9B%E5%87%BD%E6%95%B0/"/>
    <id>https://blogs.littlegenius.xin/2019/08/12/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E5%9B%9B%E5%87%BD%E6%95%B0/</id>
    <published>2019-08-12T04:44:00.000Z</published>
    <updated>2019-08-18T03:22:11.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h1><h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">typeName <span class="title">functionName</span><span class="params">(parameterList)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">statement;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数有多个参数，使用逗号间隔。</p><p>函数在执行完第一个 <code>return</code> 语句后结束，如果返回值是<code>void</code>，可以直接使用 <code>return</code>; 或者不写返回语句。</p><h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h2><p>函数原型描述了函数到编译器的接口，需要写在main函数前边，通常放在头文件引用后。函数原型需要说明函数的<strong>返回类型、函数名、函数的参数类型</strong>，不需要写变量名，以分号结尾。</p><h1 id="函数与一些数据类型"><a href="#函数与一些数据类型" class="headerlink" title="函数与一些数据类型"></a>函数与一些数据类型</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>函数是使用指针来处理数组的。已知C++中将数组名解释为该数组中第一个元素的地址，即 <code>arrayName = &amp;arrayName[0]</code>，在函数中，当将数组作为函数的参数传递时，实际上传递的是数组的第一个元素的地址，即在调用函数时，传入的参数是数组名。</p><p>以数组为参数的函数声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">arrayFunction</span><span class="params">(<span class="keyword">int</span> arr [], <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>调用该函数时，只将数组的名字作为参数传入（即传入的是指向数组首元素的指针）即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> myArray[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> result = arrayFunction(myArray,<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>所以实际上传入的类型应该是一个<code>int</code>的指针，也就是说函数其实是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">arrayFunction</span><span class="params">(<span class="keyword">int</span> * arr, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/CPP4-1.png" alt="将数组作为参数出入函数" title="">                </div>                <div class="image-caption">将数组作为参数出入函数</div>            </figure><p>可以看到，我们使用 <code>int arr []</code> 替换了 <code>int *arr</code> 。既然这两个函数头都是正确的，那么就证明了一个问题：在C++中，当(且仅当）用于函数头或函数原型中，<code>int* arr</code> 和 <code>int arr[]</code> 的含义才是相同的，它们都表示<code>arr</code>是一个<code>int</code>指针。然而，数组表示法（<code>int ar[]</code>）提醒用户，<code>arr</code>不仅指向<code>int</code>，还指向<code>int</code>数组的第一个<code>int</code>值。<br><strong>但是！</strong>在其他的上下文中，<code>int*ar</code> 和 <code>int arr[]</code> 的含义并不相同。</p><p>数组名与指针对应是一件好事。将数组地址作为参数可以节省复制整个数组所需的时间和内存。如果数组很大，则使用拷贝的系统开销将非常大，程序不仅需要更多的计算机内存，还需要花费时间来复制大块的数据。但是另一方面，使用原始数据增加了破坏数据的风险，所以要尽可能的使用const限定词来保护数组。</p><h3 id="使用const来保护数组"><a href="#使用const来保护数组" class="headerlink" title="使用const来保护数组"></a>使用const来保护数组</h3><p>由于数组名与指针对应，所以数组是按照引用传递的，不是按值传递，因此保护传入的数组不被函数修改破坏非常重要，因此如果函数内部没有修改传入的数组的理由（例如便利打印数组），则最好用<code>const</code>来限定参数，从而起到保护数组的作用。</p><p>通常分为如下两种声明方法：</p><ul><li><code>void functionModify(int arr[], int size);</code></li><li><code>void functionNoChange(const int arr[], int size);</code></li></ul><h3 id="使用数组区间的函数"><a href="#使用数组区间的函数" class="headerlink" title="使用数组区间的函数"></a>使用数组区间的函数</h3><p>传统的传递数组到函数中的方式为：传递一个数组名称作为指向第一个元素的指针，再传递一个整数告知函数数组的大小。</p><p>还有一种方式是通过传递两个指针来告知函数要处理的元素区间（range），一个指针标识数组的开头，另一个指针标识数组的结尾。例如下边这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumArray</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> * <span class="built_in">begin</span>, <span class="keyword">const</span> <span class="keyword">int</span> * <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * pt;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(pt=<span class="built_in">begin</span>;pt!=<span class="built_in">end</span>;pt++)</span><br><span class="line">sum+=*pt;</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> arrayName[arraySize]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> sum = sumArray(arrayName,arrayName+arraySize);</span><br></pre></td></tr></table></figure><h3 id="指针、数组与函数的参数传递"><a href="#指针、数组与函数的参数传递" class="headerlink" title="指针、数组与函数的参数传递"></a>指针、数组与函数的参数传递</h3><p>我们知道，函数对于传递数组作为参数，根据函数是否有权限改变数组的值，通常有两种声明方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionModify</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;<span class="comment">// 1号函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionNoChange</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> arr[], <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;<span class="comment">// 2号函数</span></span><br></pre></td></tr></table></figure><p>此时，如果我们有两个数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cosnt <span class="keyword">int</span> array1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">// 1号数组</span></span><br><span class="line"><span class="keyword">int</span> array2 = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;<span class="comment">// 2号数组</span></span><br></pre></td></tr></table></figure><p>很明显，一个是常量数组，一个是变量数组。两种数组对于两个函数的关系是这样的：</p><ul><li>禁止将常量数组的地址赋给非常量指针，即：1号数组不能传递给2号函数，只能传递给1号函数</li><li>可以将非常量数组赋给常量或非常量指针，即：2号数组可以被传递给1和2号函数</li></ul><p>因此，在设计函数时，要尽可能地使用const，因为将指针参数声明为指向常量数据的指针可以：</p><ul><li>避免由于无意间修改数据而导致的编程错误</li><li>使用const使得函数能够处理const和非const实参，否则将只能接受非const数据</li></ul><p>所以，如果条件允许，则应将指针形参声明为指向<code>const</code>的指针</p><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>编写以二维数组作为参数的方法如下：首先，数组名称被视为其地址，而且数组名可以认为是指向第一层元素的指针（第一层的元素是数组（第二层））。</p><p>例如下边的这个数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> data[<span class="number">3</span>][<span class="number">4</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;, &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;, &#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>可以这样声明一个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span> <span class="params">(<span class="keyword">int</span> (*arr)[<span class="number">4</span>], <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>或者这样声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span> <span class="params">(<span class="keyword">int</span> arr[][<span class="number">4</span>], <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>然后这样使用它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = sum(data,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>可以看到，传入的参数是数组名，即表示大数组data中第一个元素的引用，而这个元素又是一个4维的数组，所以其实传入的第一个参数是一个<strong>指向由4个int组成的数组的指针</strong>。而且，第一种声明方式中，必须将 <code>*arr</code> 用括号括起来，否则 <code>int *arr[4]</code> 将表示的是一个由4个指向int的指针组成的数组，然而函数的参数不可能是数组。以上两种声明方式都表明 arr 是指针而不是数组，只是在声明时需要表明它是一个由4个int组成的数组罢了，这也就意味着已经将数组的列数传入函数，所以只需要单独传入一个行数作为参数即可。</p><p>在函数中，可以直接将 arr 看成数组名，然后像这样使用它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result+=arr[i][j];</span><br></pre></td></tr></table></figure><p>显然，这里存在如下的一个关系：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[i][j] == *(*(arr+i)+j)</span><br></pre></td></tr></table></figure><p>实际上，是这样推演过来的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr  <span class="comment">// 指向第一行的由4个int组成的数组的指针</span></span><br><span class="line">arr+i  <span class="comment">// 指向低i行的元素的指针（这个元素是一个4元int数组）</span></span><br><span class="line">*(arr+i)  <span class="comment">// 第i行的元素，也就是第i行数组，即第i行的指向这个数组第一个元素的指针，等同于 arr[i]</span></span><br><span class="line">*(arr+i)+j  <span class="comment">// 指向第i行第j个元素的指针，等同于 arr[i]+j</span></span><br><span class="line">*(*arr+i)+j)  <span class="comment">// 第i行第j列的元素值，等同于 arr[i][j]</span></span><br></pre></td></tr></table></figure><h2 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a>C风格字符串</h2><p>C风格字符串只一系列字符，以空值结尾的字符串。</p><h3 id="作为参数"><a href="#作为参数" class="headerlink" title="作为参数"></a>作为参数</h3><p>将C风格的字符串作为参数传递给函数，有三种表示字符串的方式：</p><ul><li>char数组</li><li>用引号括起来的字符串常量（字符串字面值）</li><li>被设置为字符串的地址的char指针</li></ul><p>但其实这三种方式都是传递了一个char指针（<code>char*</code>），由于C风格的字符串与一般的char数组的最主要区别是，C风格字符串自带了结束字符（\0），所以不需再传入一个数组的长度作为参数。</p><p>变量的声明与传入函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> myChar[<span class="number">6</span>] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> * ch = <span class="string">"hello"</span>;</span><br><span class="line">charFunction(myChar);  <span class="comment">// myChar 是hello的第一个元素（h）的地址</span></span><br><span class="line">charFunction(ch);  <span class="comment">// ch是指向char（h）的一个指针</span></span><br><span class="line">charFunction(<span class="string">"hello"</span>);  <span class="comment">// 直接传入字符串的地址</span></span><br></pre></td></tr></table></figure><p>函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">charFunction(<span class="keyword">char</span> * str);</span><br><span class="line">charFunction(<span class="keyword">char</span> str[]);</span><br></pre></td></tr></table></figure><p>函数中对参数的使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">charFunction(<span class="keyword">const</span> <span class="keyword">char</span> * str)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(*str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*str;</span><br><span class="line">        str++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作为返回值"><a href="#作为返回值" class="headerlink" title="作为返回值"></a>作为返回值</h3><p>函数无法直接返回一个字符串，但是可以返回字符串的地址，比如可以这样声明一个返回值为字符串的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">buildChar</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * pstr = <span class="keyword">new</span> <span class="keyword">char</span>[n+<span class="number">1</span>];</span><br><span class="line">    pstr[n]=<span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--&gt;<span class="number">0</span>)</span><br><span class="line">pstr[n]=c;</span><br><span class="line">    <span class="keyword">return</span> pstr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="传递结构的值"><a href="#传递结构的值" class="headerlink" title="传递结构的值"></a>传递结构的值</h3><p>当结构体较小时，按值传递结构比较合理，且安置传递可以将结构体看成和int、double等一样的普通单值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> myInt;</span><br><span class="line">    <span class="keyword">double</span> myDouble;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">myStruct <span class="title">sum</span><span class="params">(myStruct str1, myStruct str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    myStruct result;</span><br><span class="line">    result.myInt = str1.myInt + str2.myInt;</span><br><span class="line">    result.myDouble = str1.myDouble + str2.myDouble;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="传递结构的地址"><a href="#传递结构的地址" class="headerlink" title="传递结构的地址"></a>传递结构的地址</h3><p>当结构体较大时，传递结构体的地址更为合理，可以节省时间与空间，此时需要将参数由结构体变成指向它的指针，并且访问结构体内的元素时需要使用 <code>-&gt;</code> 代替点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStruct</span><span class="params">(<span class="keyword">const</span> myStruct * str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"myInt = "</span>&lt;&lt;str-&gt;myInt;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"myDouble = "</span>&lt;&lt;str-&gt;myDouble;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="string对象"><a href="#string对象" class="headerlink" title="string对象"></a>string对象</h2><p>由于string是对象，对象是可以赋值的，所以和结构体类似，可以直接将string的实体按值传递给函数，也可以直接从函数返回，如果需要多个string，可以使用string的数组而不需要一个char的二维数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pringStrings</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> str[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">" : "</span>&lt;&lt; str[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="array对象"><a href="#array对象" class="headerlink" title="array对象"></a>array对象</h2><p>array对象也是对象，所以依然有两种传递给函数的方式：按值传递和按引用传递（传递地址）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="built_in">array</span>&lt;<span class="keyword">int</span>,<span class="number">3</span>&gt; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="built_in">array</span>&lt;<span class="keyword">int</span>,<span class="number">3</span>&gt; * arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">3</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(*arr)[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>递归就是函数自己调用自己。在递归的过程中，需要设置终止条件，否则将无限循环下去，例如下边的test为false时将会断开递归。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recurs</span><span class="params">(argumentlist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    statements1;</span><br><span class="line">    <span class="keyword">if</span>(test)</span><br><span class="line">        recurs(arguments)</span><br><span class="line">    statements2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归对于函数的调用是基于栈这种数据结构的，即后进先出，例如三次递归上边的函数，会首先有三次statements1，然后发现终止条件满足后再倒叙执行三次statements2，形成一个栈的后进先出的结果。</p><p>函数递归一般会在时间上对于程序有所缩短，但是占用内存的开销却一般较大，因为所以未完成递归的函数都需要存储在内存中，直到整个递归结束才会释放。</p><h1 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h1><p>函数也有地址，指向函数的存储地址的数据类型为函数指针，在存储机器语言代码的内存块中，函数指针指向这个函数的内存块的开始地址。利用函数指针，我们可以使用一个函数找到另一个函数，亦或者让函数成为另一个函数的变量。那为什么不直接使用函数调用呢？因为函数调用的代码是写好的，只能调用那一个固定的函数，但是函数指针如果作为一个变量来使用的话，可以传入不同的值，即可以选择使用不同的函数。</p><h2 id="获取函数指针"><a href="#获取函数指针" class="headerlink" title="获取函数指针"></a>获取函数指针</h2><p>函数名（不带参数）即为指向该函数的指针，若将函数作为参数传递，必须传递函数名（函数指针）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">invoke(myFunction); <span class="comment">// 传入的是函数指针，即函数</span></span><br><span class="line">invoke(myFunction()); <span class="comment">// 传入的是函数的返回值</span></span><br></pre></td></tr></table></figure><h2 id="声明函数指针"><a href="#声明函数指针" class="headerlink" title="声明函数指针"></a>声明函数指针</h2><p>声明函数指针时必须指定指针指向的函数类型，即说明函数的返回类型与参数列表，和函数原型的声明方式非常类似。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myFunction</span><span class="params">(<span class="keyword">double</span>)</span></span>; <span class="comment">// 函数原型</span></span><br><span class="line"><span class="keyword">int</span> (*myFunctionPoint)(<span class="keyword">double</span>); <span class="comment">// myFunction是函数指针</span></span><br></pre></td></tr></table></figure><p>这里将 <code>(*myFunctionPoint)</code> 替换了 <code>myFunction</code> ，从而 <code>myFunction</code>是函数名， <code>myFunctionPoint</code>是函数指针</p><p>注意区分如下的两种情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*myFunctionPoint)(<span class="keyword">double</span>); <span class="comment">// myFunction是函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">myFunction</span><span class="params">(<span class="keyword">double</span>)</span></span>; <span class="comment">// 返回一个指向int的指针的函数</span></span><br></pre></td></tr></table></figure><p>在正确的声明函数指针后，要通过赋值使得函数指针指向函数，由于上文提到函数名（不带参数）即是函数的地址，从而赋值的方式就很简单（赋值必须保证返回类型和参数列表均相同）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myFunctionPoint = myFunction; <span class="comment">// 左侧为函数指针，右侧为函数的地址</span></span><br></pre></td></tr></table></figure><h2 id="使用指针调用函数"><a href="#使用指针调用函数" class="headerlink" title="使用指针调用函数"></a>使用指针调用函数</h2><p>已知，<code>(*myFunctionPoint)</code>和<code>myFunction</code>扮演的角色相同，所以可以使用任何一种形式来调用这个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = myFunction(<span class="number">1.2</span>); <span class="comment">// 使用函数名调用函数</span></span><br><span class="line"><span class="keyword">int</span> result = (*myFunctionPoint)(<span class="number">5.6</span>); <span class="comment">// 使用函数指针调用函数</span></span><br><span class="line"><span class="keyword">int</span> result = myFunctionPoint(<span class="number">3.7</span>); <span class="comment">// 实际上这也是一种可行的方式</span></span><br></pre></td></tr></table></figure><h2 id="函数指针数组"><a href="#函数指针数组" class="headerlink" title="函数指针数组"></a>函数指针数组</h2><p>函数指针的神奇之处在于它可以保存成数组类型。假设我们有三个返回类型和参数列表均相同但是作用却不同的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f3</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>我们可以使用一个指向这种函数类型的函数指针的数组来存储这三个函数的指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> (*fp[<span class="number">3</span>]) (<span class="keyword">int</span>) = &#123;f1,f2,f3&#125;;</span><br></pre></td></tr></table></figure><p>现在说明一下数组索引3的位置：fp是一个包含三个元素的数组，而要声明这样的数组，首先需要使用<code>fp[3]</code>，该声明的其他部分指出了数组包含的元素是什么样的。运算符<code>[]</code>的优先级高于<code>*</code>，因此<code>fp[3]</code>表明<code>fp</code>是一个包含三个指针的数组。上述声明的其他部分指出了每个指针指向的是什么：参数为int，且返回类型为double的函数。因此，<code>fp</code>是一个包含三个指针的数组，其中每个指针都指向这样的函数，即将int作为参数，并返回一个double。</p><p><strong>注意</strong>，此处无法使用auto赋值，因为auto只能用于单值初始化，无法用于初始化列表。</p><p>接下来使用该数组调用函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> = fp[<span class="number">0</span>](<span class="number">1</span>);</span><br><span class="line"><span class="keyword">double</span> = (*fp[<span class="number">1</span>])(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><p>内联函数与其他函数的区分之处在于编译器对函数的处理方式，常规函数在编译时，函数调用就是函数调用，在调用到该函数时，运行程序会跳转到存储该函数的代码块去执行这个函数，执行结束后再跳转回来继续执行；而内联函数再编译时直接将整个函数编译到调用的地方，即用函数的内容替换函数调用。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/CPP4-2.png" alt="内联函数与常规函数" title="">                </div>                <div class="image-caption">内联函数与常规函数</div>            </figure><p>这个性质就决定了，内联函数最好是简单的函数，如果函数过于复杂，不适合被声明为内联函数，因为如果复杂的函数作为了内联函数，那么编译时每一个函数调用都会复制一次整个函数放在调用的位置，是非常耗费空间的。但是对于简单的却调用次数很多的函数，适合声明为内联函数，这样其实相当于将一些多次多处重复的代码单独拎出来写了，但是编译时编译器帮你放了回去。</p><p>内联函数的声明方法：在函数生命和定义前都加上关键词 inline，而且通常由于内联函数很简单，会直接写在原型处：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="keyword">return</span> x*x; &#125;</span><br></pre></td></tr></table></figure><h1 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h1><p>引用变量被定义为一个变量的别名，即引用变量和其指向的变量代表同一个值，指向同一个存储单元，并且引用变量自从赋值起就已知跟着这个变量，不会再发生改变，也就是一个变量两个名字，所以更改其中的任何一个这个变量都会发生改变。</p><p><code>&amp;</code>符号可以指示变量的地址，同时它的另一个含义就是用来声明引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> genius;</span><br><span class="line"><span class="keyword">int</span> &amp; me = genius;</span><br></pre></td></tr></table></figure><p>这里的<code>&amp;</code>不是地址运算符，而是类型标识符的一部分，就像<code>int *</code>是<code>int</code>类型的指针一样，<code>int &amp;</code>是指向<code>int</code>的引用。上述声明将me和genius等价，它们指向相同的值和内存单元，就是说me就是genius，而genius就是me。</p><h2 id="引用和指针"><a href="#引用和指针" class="headerlink" title="引用和指针"></a>引用和指针</h2><p>引用和指针貌似很相像，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> genius = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> &amp; me = genius;</span><br><span class="line"><span class="keyword">int</span> * myself = &amp;genius;</span><br></pre></td></tr></table></figure><p>这样，神奇的事情来了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">me == *myself == genius</span><br><span class="line">&amp;me == myself == &amp;genius</span><br></pre></td></tr></table></figure><p>引用与指针也有区别，例如必须再声明时将引用的值初始化，不能像指针一样，先声明在赋值；而且引用变量一旦赋值将不会再更改，这一点更接近于const指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp; me = genius;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> myself = &amp;genius;</span><br></pre></td></tr></table></figure><p>从而，<code>me == *myself</code></p><h2 id="将引用用作函数参数"><a href="#将引用用作函数参数" class="headerlink" title="将引用用作函数参数"></a>将引用用作函数参数</h2><p>按值传递与按引用传递</p><ul><li>按值传递：函数复制一份传入的值，然后对复制的数据进行操作，与被传入的数据无关</li><li>按引用传递：函数直接使用传入的数据，不对其进行拷贝，修改的内容会直接体现在原数据上，这一点可以轻松地使用引用变量完成，抑或通过使用指针传递变量的地址来完成</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/CPP4-3.png" alt="按值传递与按引用传递" title="">                </div>                <div class="image-caption">按值传递与按引用传递</div>            </figure><p>例如，完成一个交换两个变量的值的函数：</p><p>按值传递</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapByValue</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按引用传递：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapByReference</span><span class="params">(<span class="keyword">int</span> &amp; a, <span class="keyword">int</span> &amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按地址（指针）传递:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapByPoint</span><span class="params">(<span class="keyword">int</span> * a, <span class="keyword">int</span> * b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种函数的调用方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">swapByValue(intA, intB);</span><br><span class="line">swapByReference(intA, intB);</span><br><span class="line">swapByPoint(&amp;intA, &amp;intB);</span><br></pre></td></tr></table></figure><p>可以看出，按指针传递的声明方法和调用方法与其他两种均不同，需要在函数定义时告知传入的变量时 <code>int*</code> 类型，在调用时传入变量的地址 <code>&amp;intA</code> 才可以；按值传递和按引用传递的调用方式相同，直接将变量名传入，只有在定义函数处才可以直到两者的不同，一个是按值传递，一个指出了是按地址传递 <code>&amp; int</code>。</p><p>按引用传递的一个重要方面是被传入的值会被直接使用或者修改，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">squareByValue</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a *= a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">squareByReference</span><span class="params">(<span class="keyword">int</span> &amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a *= a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用时会出现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a =<span class="number">2</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; squareByValue(a) &lt;&lt; <span class="string">" = square of "</span> &lt;&lt; a; <span class="comment">// 输出：4 = square of 2</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; squareByReference(a) &lt;&lt; <span class="string">" = square of "</span> &lt;&lt; a; <span class="comment">// 输出：4 = square of 4</span></span><br></pre></td></tr></table></figure><p>可见，按照引用传递时，被传入的变量的更改会影响到原始的变量。</p><h2 id="将引用用于结构"><a href="#将引用用于结构" class="headerlink" title="将引用用于结构"></a>将引用用于结构</h2><p>声明一个结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> myInt;</span><br><span class="line">    <span class="keyword">double</span> myDouble;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将引用用于结构-1"><a href="#将引用用于结构-1" class="headerlink" title="将引用用于结构"></a>将引用用于结构</h3><p>将结构的引用作为参数传递非常简单，同时需要注意的是最好使用引用作为返回值。否则的话，函数需要先将待返回的结构体赋予一个临时变量，然后将这个临时变量返回，这是非常耗费时间和空间的。所以应该像这样使用它们：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">myStruct &amp; <span class="title">sum</span><span class="params">(myStruct &amp; target, <span class="keyword">const</span> myStruct &amp; source)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    target.myInt += source.myInt;</span><br><span class="line">    target.myDouble += source.myDouble;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用该函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myStruct target = &#123;<span class="number">1</span>,<span class="number">2.5</span>&#125;;</span><br><span class="line">myStruct source = &#123;<span class="number">2</span>,<span class="number">3.8</span>&#125;;</span><br><span class="line">myStruct result;</span><br><span class="line">result = sum(target, source);</span><br></pre></td></tr></table></figure><h3 id="对返回值使用const"><a href="#对返回值使用const" class="headerlink" title="对返回值使用const"></a>对返回值使用const</h3><p>如果不对返回值使用const，意味着返回值是可以被赋值的，即下边的表达式成立：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(target, source) = anotherStruct;</span><br></pre></td></tr></table></figure><p>未来避免这种情况发生，可以使用const限定返回值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> myStruct &amp; <span class="title">sum</span><span class="params">(myStruct &amp; target, <span class="keyword">const</span> myStruct &amp; source)</span></span>;</span><br></pre></td></tr></table></figure><p>从而如下的语句都不能成立：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum(target, source) = anotherStruct;</span><br><span class="line">sum(sum(target, source), source);</span><br></pre></td></tr></table></figure><p>因为无法将一个有const限定的变量传递给一个没有const限定的变量，但是可以将返回值赋给其他结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = sum(target, source);</span><br></pre></td></tr></table></figure><h2 id="何时使用引用参数"><a href="#何时使用引用参数" class="headerlink" title="何时使用引用参数"></a>何时使用引用参数</h2><p>使用引用参数的主要原因有两个：</p><ul><li>程序员能够修改调用函数中的数据对象</li><li>通过传递引用而不是整个数据对象，可以提高程序的运行速度</li></ul><p>当数据对象较大时（如结构和类对象），第二个原因最重要。这些也是使用指针参数的原因。这是有道理的，因为引用参数实际上是基于指针的代码的另一个接口。那么，什么时候应使用引用、什么时候应使用指针呢？什么时候应按值传递呢？下面是一些<strong>参考原则</strong>：</p><ul><li>对于使用传递的值而不作修改的函数<ul><li>如果数据对象很小，如内置数据类型或小型结构，则按值传递</li><li>如果数据对象是数组，则使用指针，因为这是唯一的选择，并将指针声明为指向const的指针</li><li>如果数据对象是较大的结构，则使用const指针或const引用，以提高程序的效率。这样可以节省复制结构所需的时间和空间。</li><li>如果数据对象是类对象，则使用const引用。传递类对象参数的标准方式是按引用传递</li></ul></li><li>对于修改调用函数中数据的函数<ul><li>如果数据对象是内置数据类型，则使用指针</li><li>如果数据对象是数组，则只能使用指针</li><li>如果数据对象是结构，则使用引用或指针</li><li>如果数据对象是类对象，则使用引用</li></ul></li></ul><h1 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h1><p>默认参数显然就是在调用函数时，如果没有主动传入参数，可以直接使用默认的参数。</p><p>默认参数的写法只需在函数原型中的参数后跟上默认值即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myFunction</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>, <span class="keyword">double</span> = <span class="number">1.0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>默认参数的原则如下：</p><ul><li><p>在参数列表中，带有默认参数的参数必须放到所有参数的右边，即从某个参数开始，后边的如果是带有默认参数的就都是带有默认参数的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myFunction</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">double</span> n = <span class="number">1.0</span>, <span class="keyword">char</span> c = <span class="string">'c'</span>)</span></span>; <span class="comment">// 这是可行的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myFunction</span><span class="params">(<span class="keyword">int</span> m, doubel n = <span class="number">1.0</span>, <span class="keyword">char</span> c)</span></span>; <span class="comment">// 这是不行的</span></span><br></pre></td></tr></table></figure></li><li><p>调用函数时，可以不传入有默认值的参数，但是所有参数赋值必须从左到右，不能跳过某个参数值，比如上边的第一个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = myFunction(<span class="number">1</span>); <span class="comment">// 传一个参数，1，1.0，'c'</span></span><br><span class="line"><span class="keyword">int</span> result = myFunction(<span class="number">1</span>, <span class="number">2.0</span>); <span class="comment">// 传两个参数，1，2.0，'c'</span></span><br><span class="line"><span class="keyword">int</span> result = myFunction(<span class="number">1</span>, <span class="number">2.0</span>, <span class="string">'h'</span>); <span class="comment">// 传三个参数，1，2.0，'h'</span></span><br><span class="line"><span class="keyword">int</span> result = myFunction(<span class="number">1</span>, <span class="string">'h'</span>); <span class="comment">// 不允许</span></span><br><span class="line"><span class="keyword">int</span> result = myFunction(<span class="number">1</span>,  , <span class="string">'h'</span>); <span class="comment">// 不允许</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><p>函数重载提供的功能是，定义同名、同返回值，但是参数列表不同的函数，这样在调用时，编译器根据传入参数的类型自行选择使用哪一种函数。</p><p>加入我们定义了如下的三个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">int</span> i)</span></span>; <span class="comment">// #1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">double</span> d)</span></span>; <span class="comment">// #2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="built_in">string</span> s)</span></span>; <span class="comment">// #3</span></span><br></pre></td></tr></table></figure><p>在调用时会根据参数选择使用哪一种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myPrint(<span class="number">1</span>); <span class="comment">// #1</span></span><br><span class="line">myPrint(<span class="number">2.5</span>); <span class="comment">// #2</span></span><br><span class="line">myPrint(<span class="string">"hello world!"</span>); <span class="comment">// #3</span></span><br></pre></td></tr></table></figure><h2 id="重载的一些原则"><a href="#重载的一些原则" class="headerlink" title="重载的一些原则"></a>重载的一些原则</h2><p>引用变量是无法作为两种重载函数的，比如有两个函数原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> &amp; x)</span></span>;</span><br></pre></td></tr></table></figure><p>这样，在调用函数时出入参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> result = square(x);</span><br></pre></td></tr></table></figure><p>根本无法确定是使用哪种函数模型，所以在函数重载中，编译器将类型本身和类型的引用看成是一种参数。</p><p>在匹配函数时，并不区分const和非const的变量，如以下的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">char</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> c)</span></span>;</span><br></pre></td></tr></table></figure><p>广义上来讲这也是一种重载，但是由于const函数可以处理const变量和非const变量，而非const的函数只能处理非const变量，所以其实并不是严格意义上的重载函数</p><h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><p>函数模板的作用是允许我们使用泛型定义函数，然后根据具体的数据类型替换泛型。通过将类型作为参数传递给模板，可以是编译器生成该类的函数。</p><p>比如要交换两个变量的值，这时候我们写好了一个交换两个int值的函数，又需要一个交换两个double值的函数，我们需要将第一个函数重复一遍，然后再将其中的int替换成double，是非常复杂的。尤其是当一些算法可以应用于很多数据类型时，我们无法对每一种数据类型都写一套算法函数，这就时函数模板解决的问题。 </p><h2 id="模板函数的定义与使用"><a href="#模板函数的定义与使用" class="headerlink" title="模板函数的定义与使用"></a>模板函数的定义与使用</h2><p>我们可以先定义一个模板，然后用具体的数据类型替换，像下边这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T &amp;a, T &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T temp;</span><br><span class="line">temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要建立一个模板，必须先使用<code>template</code>语法来定义一个模板变量T，这里也可以用旧的声明方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;;</span></span><br></pre></td></tr></table></figure><p>很多代码库都使用<code>class</code>开发的，这样的上下文中，两个关键词完全相同，如果不考虑向后兼容并且不介意输入长单词的话，使用<code>typename</code>而不使用<code>class</code> </p><p>调用模板函数时，和其他函数类似，编译器会根据我们传入的函数类型自行生成一个对应的函数，这个函数我们是看不到的，但是编译器会直接在背后生成并为我们使用好，例如调用下边的语句时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line">swap(i, j);</span><br></pre></td></tr></table></figure><p>这是，编译器会自动生成一个函数：使用int代替所有的T，从而完成相关的逻辑，这个函数我们看不到，但是没问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line">temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板函数的重载"><a href="#模板函数的重载" class="headerlink" title="模板函数的重载"></a>模板函数的重载</h2><p>模板函数也是可以重载的，虽然泛型使我们合并解决了很多问题，但是有些数据类型是无法合并的。比如交换变量值的函数，我们可以将上述逻辑同时用于int、double、char、string等，但是却无法用于数组，因为数组需要将每个元素交换，于是可以使用函数模板的重载：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T &amp;a, T &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T []a, T[]b, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i] = b[i];</span><br><span class="line">        b[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以用同名函数swap交换任意数据类型和数组类型了。</p><h2 id="函数模板的局限性"><a href="#函数模板的局限性" class="headerlink" title="函数模板的局限性"></a>函数模板的局限性</h2><p>定义模板函数要考虑好这个函数应用的数据类型的范围，有些操作对于数据类型是很有局限性的，比如 a&gt;b 这种操作，只能用于 int、double 等，string和char显然无法使用 </p><h2 id="显式具体化"><a href="#显式具体化" class="headerlink" title="显式具体化"></a>显式具体化</h2><p>假如定义了一个结构:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> myInt;</span><br><span class="line">    <span class="keyword">double</span> myDouble;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时我们同样可以通过上面的swap函数交换两个struct的值，因为结构体是可以直接被赋给另一个结构体的。但是如果我们只想交换两个结构体的myInt变量，而不想交换myDouble变量呢，就无法使用上述模板函数了，但是由于这种情况下我们传入的参数还是和上述模板函数相同的（两个待交换的T），所以重载无法达到这个愿望。这就用到了显式具体化（explicit specialization）。</p><p>显示具体化是我们可以提供一个具体化的函数定义，其中包含这个特殊的处理情况下的代码，当编译器找到了与函数调用匹配的具体化定义时，就不再使用模板，而是用该具体化的定义：</p><ul><li>对于给定的函数名，可以有非模板函数、模板函数和显式具体化模板函数以及它们的重载函数四个版本</li><li>显式具体化的原型和定义以<code>&lt;template&gt;</code>打头，并通过名称来指出类型</li><li>非模板函数优先于具体化和常规模板，具体化模板优先于常规模板</li></ul><p>例如对于刚才的结构体，下面是用于交换逻辑的非模板函数、模板函数和具体化函数的原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非模板函数 #1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(myStruct &amp;, myStruct &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板函数 #2</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T &amp;, T &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板具体化函数 #3</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">void</span> swap&lt;myStruct&gt;(myStruct &amp;, myStruct &amp;);</span><br></pre></td></tr></table></figure><p>在上述三个函数原型同时存在时，#1优先于#3优先于#2。在具体化函数模板中，可以省略函数名后的<code>&lt;myStruct&gt;</code>，因为参数类型已经表明了这是一个myStruct的具体化函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(myStruct &amp;, myStruct &amp;)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="实例化与具体化"><a href="#实例化与具体化" class="headerlink" title="实例化与具体化"></a>实例化与具体化</h2><p>当我们定义了一个模板函数swap后，通过调用时传入了两个int值可以使得编译器在后台自动为我们实例化了一个int类型的函数，这个函数是编译中产生的，所以我们看不到，但是它确实是产生了，这个过程成为<strong>隐式实例化</strong>。</p><p>同时我们也可以进行<strong>显式实例化</strong>（explicit instantiation），即可以直接命令编译器创建特定的实例，比如一个处理int的swap函数，只需要这样声明它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="keyword">void</span> swap&lt;<span class="keyword">int</span>&gt;(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><p>这是要和<strong>显示具体化</strong>（explicit specialization）区分开的，具体化是在<code>template</code>后还需要加一个<code>&lt;&gt;</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; &gt; <span class="keyword">void</span> swap&lt;<span class="keyword">int</span>&gt;(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">template</span> &lt; &gt; <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>在<code>template</code>后有无<code>&lt;&gt;</code>是区分显示具体化和显示实例化的重要标志。</p><p>通常的，隐式实例化、显式实例化和显示具体化都被称为<strong>具体化</strong>（specialization）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;函数基础&quot;&gt;&lt;a href=&quot;#函数基础&quot; class=&quot;headerlink&quot; title=&quot;函数基础&quot;&gt;&lt;/a&gt;函数基础&lt;/h1&gt;&lt;h2 id=&quot;函数的定义&quot;&gt;&lt;a href=&quot;#函数的定义&quot; class=&quot;headerlink&quot; title=&quot;函数的定义&quot;&gt;
      
    
    </summary>
    
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/categories/C/"/>
    
    
      <category term="学习笔记" scheme="https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构】（二）栈与队列</title>
    <link href="https://blogs.littlegenius.xin/2019/08/08/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%BA%8C%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <id>https://blogs.littlegenius.xin/2019/08/08/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%BA%8C%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</id>
    <published>2019-08-08T13:13:38.000Z</published>
    <updated>2019-08-08T13:20:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈（stack）"><a href="#栈（stack）" class="headerlink" title="栈（stack）"></a>栈（stack）</h1><p>栈（stack）是限制插入和删除操作只能在末尾位置上进行的表，该末尾成为栈的顶（top）。是一种<strong>后进先出</strong>的表（<strong>LIFO</strong>，Last In First Out）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure2-1.png" alt="栈" title="">                </div>                <div class="image-caption">栈</div>            </figure><h2 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h2><ul><li>链表实现：使用单向链表实现</li><li>数组实现：使用数组实现，是更加常用的方式。由C++中的vector中的back、push_back和pop_back可以很简单地实现一个栈。每个栈需要一个用于存储栈数据的数组（stackArray）和一个记录栈顶索引的值（topOfStack）（当空栈时索引为-1）</li></ul><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><ul><li><code>push</code>：入栈操作，将<code>topOfStack+1</code>，然后令<code>stackArray[topOfStack]=newElement;</code></li><li><code>pop</code>：出栈操作，<code>outElement=stackArray[topOfStack]</code>，然后将<code>topOfStack-1</code></li><li><code>top</code>：返回栈顶元素，返回<code>stackArray[topOfStack]</code></li></ul><p>所有操作均为<strong>常数时间O(1)</strong>运行</p><h1 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h1><p>队列也是表，是一种<strong>先进先出</strong>（First In First Out，<strong>FIFO</strong>）的数据结构，入队列的一端成为队尾，出队列的一端成为队头。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure2-2.png" alt="队列" title="">                </div>                <div class="image-caption">队列</div>            </figure><h2 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h2><p>队列也可以使用链表来实现，但通常使用循环数组来实现。</p><p>一个队列需要一个用于存储队列中数据的数组queueArray和两个位置front、back，用于记录队列的两端。为了判定队列是否空还是满，通常还增设一个元素currentSize来记录队列中现有的元素个数。 </p><h2 id="常用操作-1"><a href="#常用操作-1" class="headerlink" title="常用操作"></a>常用操作</h2><ul><li><p><code>enqueue</code>：入队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">back = (back+<span class="number">1</span>)%queueArray.<span class="built_in">size</span>();</span><br><span class="line">queueArray[back]=newElement;</span><br><span class="line">currentSize++;</span><br></pre></td></tr></table></figure></li><li><p><code>dequeue</code>：出队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">outElement = queueArray[front];</span><br><span class="line">fornt = (front+<span class="number">1</span>)%queueArray.<span class="built_in">size</span>();</span><br><span class="line">currentSize--;</span><br></pre></td></tr></table></figure></li><li><p><code>back</code>：返回队尾元素，直接返回<code>queueArray[back]</code></p></li><li><p><code>front</code>：返回队头元素，直接返回<code>queueArray[front]</code></p></li></ul><p>以上操作均以<strong>常数时间O(1)</strong>运行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;栈（stack）&quot;&gt;&lt;a href=&quot;#栈（stack）&quot; class=&quot;headerlink&quot; title=&quot;栈（stack）&quot;&gt;&lt;/a&gt;栈（stack）&lt;/h1&gt;&lt;p&gt;栈（stack）是限制插入和删除操作只能在末尾位置上进行的表，该末尾成为栈的顶（top）。是
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://blogs.littlegenius.xin/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习笔记" scheme="https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/tags/C/"/>
    
      <category term="数据结构" scheme="https://blogs.littlegenius.xin/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构】（一）表与迭代器</title>
    <link href="https://blogs.littlegenius.xin/2019/08/08/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%B8%80%E8%A1%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>https://blogs.littlegenius.xin/2019/08/08/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%B8%80%E8%A1%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/</id>
    <published>2019-08-08T10:18:26.000Z</published>
    <updated>2019-08-27T11:44:33.768Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>抽象数据类型</strong>（abstract data type，<strong>ADT</strong>）是带有一组操作的一些对象的集合。An abstract data type (ADT) is a set of objects together with a set of operations. </p></blockquote><blockquote><p><strong>标准模板库</strong>（Standard Template Library，<strong>SLT</strong>）。实现了ADT等数据结构，这些数据结构被称为集合（collection）或者容器（container）</p></blockquote><h1 id="表（List）"><a href="#表（List）" class="headerlink" title="表（List）"></a>表（List）</h1><h2 id="表的实现方式"><a href="#表的实现方式" class="headerlink" title="表的实现方式"></a>表的实现方式</h2><ul><li>静态表：利用数组实现</li><li>动态表：利用链表实现</li></ul><h2 id="表的常用操作"><a href="#表的常用操作" class="headerlink" title="表的常用操作"></a>表的常用操作</h2><ul><li>printList：遍历、打印整个表</li><li>makeEmpty：将整个表清空</li><li>find：在表中查找某个元素</li><li>insert：向表中插入某个元素</li><li>remove：从表中移除某个元素</li><li>findKth：查找表中的第k个元素</li><li>next：返回某个元素的下一个元素</li><li>previous：返回某个元素的上一个元素</li></ul><h2 id="表的两种简单形式"><a href="#表的两种简单形式" class="headerlink" title="表的两种简单形式"></a>表的两种简单形式</h2><p>简单链表实现</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure1-1.png" alt="简单链表" title="">                </div>                <div class="image-caption">简单链表</div>            </figure><p>双向链表</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure1-2.png" alt="双向链表" title="">                </div>                <div class="image-caption">双向链表</div>            </figure><h2 id="表的两种重要操作"><a href="#表的两种重要操作" class="headerlink" title="表的两种重要操作"></a>表的两种重要操作</h2><p>链表的插入</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure1-3.png" alt="链表的插入" title="">                </div>                <div class="image-caption">链表的插入</div>            </figure><p>链表的删除</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure1-4.png" alt="链表的删除" title="">                </div>                <div class="image-caption">链表的删除</div>            </figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><table><thead><tr><th align="center">基本操作</th><th align="center">静态 数组实现</th><th align="center">动态 链表实现</th></tr></thead><tbody><tr><td align="center">printList</td><td align="center">O(n)</td><td align="center">O(n)</td></tr><tr><td align="center">makeEmpty</td><td align="center">O(n)</td><td align="center">O(1)</td></tr><tr><td align="center">find</td><td align="center">O(1)</td><td align="center">O(i)</td></tr><tr><td align="center">insert</td><td align="center">O(n)</td><td align="center">O(1)</td></tr><tr><td align="center">remove</td><td align="center">O(n)</td><td align="center">O(1)</td></tr><tr><td align="center">findKth</td><td align="center">O(1)</td><td align="center">O(i)</td></tr><tr><td align="center">next</td><td align="center">O(1)</td><td align="center">O(1)</td></tr><tr><td align="center">previous</td><td align="center">O(1)</td><td align="center">O(i)</td></tr></tbody></table><h1 id="STL中的向量和表"><a href="#STL中的向量和表" class="headerlink" title="STL中的向量和表"></a>STL中的向量和表</h1><h2 id="表AST的实现方式"><a href="#表AST的实现方式" class="headerlink" title="表AST的实现方式"></a>表AST的实现方式</h2><p>表ADT有两种流行的实现：</p><ul><li><p><code>vector</code>：给出了表ADT的可增长的数组实现</p><ul><li>优点：利于索引（常量时间）</li><li>缺点：插入新项或删除已有项代价昂贵（除非操作发生在vector的末尾）；查找效率低</li></ul></li><li><p><code>list</code>：提供了表ADT的双向链表实现</p><ul><li>优点：如果发生变化的位置已知，插入新项和删除已有项代价很小</li><li>缺点：不容易索引；查找效率低</li></ul></li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li>所有STL容器都适用的方法<ul><li><code>int size() const</code>：返回容器内的元素个数</li><li><code>void clear()</code>：删除容器中所有的元素</li><li><code>bool empty()</code>：如果容器没有元素，返回 <code>true</code>，否则返回 <code>false</code></li></ul></li><li><code>vector</code> 和 <code>list</code> 同时支持的方法<ul><li><code>void push_back(const Object &amp; x)</code>：在表的末尾添加 <code>x</code></li><li><code>void pop_back( )</code>：删除表的末尾的对象</li><li><code>const Object &amp; back( ) const</code>：返回表的末尾的对象（也提供返回引用的修改函数）</li><li><code>const Object &amp; front( ) const</code>：返回表的前端的对象（也提供返回引用的修改函数）</li></ul></li><li>vector 单独支持的方法<ul><li><code>Object &amp; operator [ ] (int idx)</code>：返回 <code>vector</code> 中 <code>idx</code> 索引位置的对象，不包含边界检测（也提供返回常量引用的访问函数）</li><li><code>Object &amp; at (int iax)</code>：返回 <code>vector</code> 中 <code>i</code> 索引位置的对象，包含边界检测（也提供返回常量引用的访问函数）</li><li><code>int capacity( ) const</code>：返回 <code>vector</code> 的内部容量</li><li><code>void reserve(int new Capacity)</code>：设定 <code>vector</code> 的新容量。如果已有良好的估计的话，这可以避免对 <code>vector</code> 进行扩展</li></ul></li><li><code>list</code> 单独支持的方法<ul><li><code>void push_front(const Object &amp; x)</code>：在<code>list</code>的前端添加<code>x</code></li><li><code>void pop_front()</code>：在<code>list</code>的前端删除对象</li></ul></li></ul><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>在STL中，使用迭代器（内置类型 iterator）给出数据在表中的位置。通常可以使用对应的模板来声明 iterator：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STLType&lt;dataType&gt;::iterator</span><br></pre></td></tr></table></figure><h2 id="获得迭代器"><a href="#获得迭代器" class="headerlink" title="获得迭代器"></a>获得迭代器</h2><p>SLT的所有容器都拥有如下的方法可以获得容器中指向的第一个和终止标志的迭代器：</p><ul><li><code>iterator begin()</code>：返回指向容器的第一项的一个适当的迭代器</li><li><code>iterator end()</code>：返回指向容器的终止标志（容器中最后一项的后面的位置）的一个适当的迭代器。（这里比较特殊，是指向的容器的“边界之外”）</li></ul><p>两种方法均可以根据所指向的容器类型返回一个恰当的迭代器，所以可以使用 <code>auto</code> 来声明它们，当你不知道应该如何声明的时候：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> myIterator = STLCollection.<span class="built_in">begin</span>();</span><br></pre></td></tr></table></figure><h2 id="迭代器方法"><a href="#迭代器方法" class="headerlink" title="迭代器方法"></a>迭代器方法</h2><p>迭代器很多方法都来自于运算符的重载</p><ul><li><code>=</code>：赋值</li><li><code>itr++</code>和<code>++itr</code>：推进迭代器itr至下一个位置，前缀和后缀两种形式都允许</li><li><code>*itr</code>：返回存储在迭代器itr指定位置的对象的引用。</li><li><code>itr1==itr2</code>：如果itr1和itr2都指向同一个位置就返回true，否则，返回fa1se</li><li><code>itr1!=itr2</code>：如果ix1和itr2都指向不同位置就返回true，否则，返回fase</li></ul><p>从而，利用迭代器打印STL容器的方式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itr=v.<span class="built_in">begin</span>(); itr != v.<span class="built_in">end</span>(); ++itr)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*itr&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itr=v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(itr!=v.<span class="built_in">end</span>())</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*itr&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h2 id="需要迭代器的表方法"><a href="#需要迭代器的表方法" class="headerlink" title="需要迭代器的表方法"></a>需要迭代器的表方法</h2><p>一些表中常用的需要使用迭代器的容器方法：</p><ul><li><code>iterator insert(iterator pos, const Object &amp; x)</code>：添加x到表中迭代器pos所指向的位置之前的位置。对1ist是常量时间操作，对vector则不是。返回值是一个指向插入项位置的迭代器</li><li><code>iterator  erase(iterator pos)</code>：删除迭代器所给出位置的对象。对1ist是常量时间操作，对vector不是。返回值是调用之前pos所指向元素的下一个元素的位置。这个操作使pos失效。pos不再有用，因为它所指向的容器变量已经被删除了</li><li><code>iterator erase(iterator start, iterator end)</code>：删除所有的从位置start开始直到位置end(但是不包括end)的所有元素</li></ul><h2 id="迭代器的分类"><a href="#迭代器的分类" class="headerlink" title="迭代器的分类"></a>迭代器的分类</h2><ul><li>正向迭代器：<code>containerType::iterator itr</code>;</li><li>常量正向迭代器（不可更改）：<code>containerType::const_iterator itr</code>;</li><li>反向迭代器：<code>containerType::reverse_iterator itr</code>;</li><li>常量反向迭代器：<code>containerType::const_reverse_iterator itr</code>;</li></ul><p>迭代器的参考：<a href="http://www.cplusplus.com/reference/iterator/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/iterator/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;抽象数据类型&lt;/strong&gt;（abstract data type，&lt;strong&gt;ADT&lt;/strong&gt;）是带有一组操作的一些对象的集合。An abstract data type (ADT) is a set of obje
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://blogs.littlegenius.xin/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习笔记" scheme="https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/tags/C/"/>
    
      <category term="数据结构" scheme="https://blogs.littlegenius.xin/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【C++温故知新】（三）循环与分支</title>
    <link href="https://blogs.littlegenius.xin/2019/08/05/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E4%B8%89%E5%BE%AA%E7%8E%AF%E4%B8%8E%E5%88%86%E6%94%AF/"/>
    <id>https://blogs.littlegenius.xin/2019/08/05/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E4%B8%89%E5%BE%AA%E7%8E%AF%E4%B8%8E%E5%88%86%E6%94%AF/</id>
    <published>2019-08-05T03:28:16.000Z</published>
    <updated>2019-08-05T03:47:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(init; condition; increment)</span><br><span class="line">&#123;</span><br><span class="line">conditional code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="foreach循环"><a href="#foreach循环" class="headerlink" title="foreach循环"></a>foreach循环</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> myArray[<span class="number">5</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> i : myArray) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition) </span><br><span class="line">&#123;</span><br><span class="line">statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">statement(s);</span><br><span class="line">&#125;<span class="keyword">while</span>( condition );</span><br></pre></td></tr></table></figure><h2 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h2><ul><li>break</li><li>continue</li><li>goto<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> label; </span><br><span class="line">label: statement;</span><br></pre></td></tr></table></figure></li></ul><h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><h2 id="if和else语句"><a href="#if和else语句" class="headerlink" title="if和else语句"></a>if和else语句</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(boolean_expression) </span><br><span class="line">&#123;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)</span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">case</span> constant-expression : </span><br><span class="line">statement(s); </span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line"><span class="keyword">case</span> constant-expression : </span><br><span class="line">statement(s);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span> : </span><br><span class="line">statement(s); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;循环&quot;&gt;&lt;a href=&quot;#循环&quot; class=&quot;headerlink&quot; title=&quot;循环&quot;&gt;&lt;/a&gt;循环&lt;/h1&gt;&lt;h2 id=&quot;for循环&quot;&gt;&lt;a href=&quot;#for循环&quot; class=&quot;headerlink&quot; title=&quot;for循环&quot;&gt;&lt;/a&gt;for循
      
    
    </summary>
    
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/categories/C/"/>
    
    
      <category term="学习笔记" scheme="https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【C++温故知新】（二）指针</title>
    <link href="https://blogs.littlegenius.xin/2019/08/05/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E4%BA%8C%E6%8C%87%E9%92%88/"/>
    <id>https://blogs.littlegenius.xin/2019/08/05/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E4%BA%8C%E6%8C%87%E9%92%88/</id>
    <published>2019-08-05T03:28:06.000Z</published>
    <updated>2019-08-06T07:54:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>指针是一个变量，存储的是值的地址</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp;Value =&gt; Address/Pointer</span><br><span class="line">*Pointer/Address =&gt; Value</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> myInt = <span class="number">10</span>;     <span class="comment">//Value</span></span><br><span class="line"><span class="keyword">int</span> *myPoint = &amp;myInt;     <span class="comment">//Pointer</span></span><br></pre></td></tr></table></figure><p>上边的写法是将 <code>myInt</code> 的地址赋给了指针 <code>myPoint</code> ，前边的 * 可以和 int 一同理解为一个整体，表示一个整型的指针。</p><h2 id="指针的声明"><a href="#指针的声明" class="headerlink" title="指针的声明"></a>指针的声明</h2><p>• <code>int *myPoint;</code><br>• <code>int * myPoint;</code><br>• <code>int* myPoint;</code></p><h2 id="动态分配内存"><a href="#动态分配内存" class="headerlink" title="动态分配内存"></a>动态分配内存</h2><ul><li>使用new来分配内存<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeName * pointer_name = <span class="keyword">new</span> typeName;</span><br></pre></td></tr></table></figure></li><li>使用delete释放内存<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> pointer_name;</span><br></pre></td></tr></table></figure></li></ul><p><strong>总结</strong>：使用 * 声明指针，指向某值的地址，使用 <code>&amp;Value</code> 获得值的地址，使用 <code>new</code> 会动态分配空间，使用 <code>delete</code> 释放动态分配的空间</p><h1 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h1><h2 id="使用new创建动态数组"><a href="#使用new创建动态数组" class="headerlink" title="使用new创建动态数组"></a>使用new创建动态数组</h2><p>动态数组表示在运行过程中创建。如果不使用 new 来声明数组，那么数组会在编译的时候就被分配相应的内存，不论是否有值都会占据相应的存储空间，成为静态联编（static binding），类似于使用值存储；使用 new 来声明数组，数组会在程序运行时创建，成为动态联编（dynamic binding），类似于使用链表存储。</p><h2 id="动态数组的创建与释放"><a href="#动态数组的创建与释放" class="headerlink" title="动态数组的创建与释放"></a>动态数组的创建与释放</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typeName * pointer_name = <span class="keyword">new</span> typeName [num_elements];</span><br><span class="line"><span class="keyword">delete</span> [] pointer_name;</span><br></pre></td></tr></table></figure><h2 id="动态数组的使用"><a href="#动态数组的使用" class="headerlink" title="动态数组的使用"></a>动态数组的使用</h2><p>pointer_name 为指向数组第一个值的指针，调用数组第n个元素可以：</p><ul><li><code>pointer_name[n];</code></li><li><code>pointer_name+n; pointer_name[0];</code></li></ul><h2 id="数组名与指针"><a href="#数组名与指针" class="headerlink" title="数组名与指针"></a>数组名与指针</h2><p>数组名即为指向该数组第一个元素的指针，即存在：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayName = &amp;arrayName[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>所以以下两个情况等价：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> myInt[<span class="number">3</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>* myPoint=myInt;  &lt;==&gt;  <span class="keyword">int</span>* myPoint = &amp;myInt[<span class="number">0</span>]</span><br><span class="line">myPoint[<span class="number">0</span>]  &lt;==&gt;  *myPoint</span><br><span class="line">myPoint[<span class="number">2</span>]  &lt;==&gt;  *(myPoint+<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>但是只有指针才可以有运算，数组名不可以有运算，例如在上边的代码中，<code>myPoint+1</code> 是合法的，但是 <code>myInt+1</code> 是不合法的</p><h1 id="指针算术"><a href="#指针算术" class="headerlink" title="指针算术"></a>指针算术</h1><p>将指针加一，等于将指针增加的量指向其类型的字节数。比如一个指向double类型的指针加一，其数值其实增加8，以指到下一个地址去。</p><p>还可以将一个指针减去另一个指针，获得两个指针的差。这种运算将得到一个整数，仅当两个指针指向同一个数组(也可以指向超出结尾的一个位置)时，这种运算才有意义；这将得到两个元素的间隔。</p><h1 id="指针和字符串"><a href="#指针和字符串" class="headerlink" title="指针和字符串"></a>指针和字符串</h1><p>在C++的 <code>cout</code> 以及其他多数表达式中，<code>char</code>数组名、<code>char</code>指针以及用引号引起来的字符串常量都被解释为字符串中第一个字符的地址。</p><p>由于数组名是数组中第一个元素的指针，所以在字符串数组中，如果直接打印数组名，将会一直打印所有的内容，直到出现\0才结束，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> myChar[<span class="number">10</span>] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; myChar;</span><br></pre></td></tr></table></figure><p>上述代码将打印 <code>hello</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> myChar[<span class="number">10</span>] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span>* myPointer = myChar;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; myPointer;</span><br></pre></td></tr></table></figure><p>上述代码将打印 <code>hello</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> myChar[<span class="number">10</span>] = <span class="string">"hell\0o"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; myChar;</span><br></pre></td></tr></table></figure><p>上述代码将只打印 <code>hell</code></p><h1 id="指针与结构"><a href="#指针与结构" class="headerlink" title="指针与结构"></a>指针与结构</h1><p>使用 <code>new</code> 可以创建动态结构，使用指针调用动态结构中的某一项需要使用 <code>-&gt;</code>，（使用结构名来调用某一项使用的是 <code>.</code> ）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> myInt;</span><br><span class="line">    <span class="keyword">double</span> myDouble;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myStruct * myPointer = <span class="keyword">new</span> myStruct;</span><br><span class="line">myPointer-&gt;myInt = <span class="number">10</span>;</span><br><span class="line">myPointer-&gt;myDouble = <span class="number">10.2</span>;</span><br></pre></td></tr></table></figure><h1 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h1><p>根据用于分配内存的方法,C++管理数据内存的方式可以分为 自动存储、静态存储和动态存储(有时也叫作自由存储空间或堆)。(C++11新增了线程存储)</p><ul><li>自动存储：<br>在函数内部定义的常规变量使用自动存储空间，被称为自动变量(automatic variable)，它们在所属的函数被调用时自动产生，在该函数结束时消亡。自动变量是一个局部变量，其作用域为包含它的代码块。代码块是被包含在花括号中的一段代码。自动变量通常存储在栈中，即执行代码块时，其中的变量将依次加入到栈中，而在离开代码块时，将按相反的顺序释放这些变量。</li><li>静态存储：<br>静态存储是整个程序执行期间都存在的存储方式。使变量成为静态的方式有两种：一种是在函数外面定义它；另一种是在声明变量时使用关键字 static 定义。</li><li>动态存储：<br>使用 new 和 delete 运算符可以提供一种比自动变量和静态变量更灵活的方法。它们管理了一个内存池，这在C++中被称为自由存储空间(free store)或堆(heap)。该内存池同用于静态变量和自动变量的内存是分开的。因此，数据的生命周期不完全受程序或函数的生存时间控制。</li></ul><h1 id="指针与const"><a href="#指针与const" class="headerlink" title="指针与const"></a>指针与const</h1><p>对于将const应用于指针，这个问题是很微妙又复杂的，因为存在两种情况：</p><ul><li>将const作用于指针指向的值，使指针指向一个常量对象，这样可以防止使用指针来修改其指向的值，但是指针所指的位置可以随意更改，即可以更换指针指向的变量，但是那个const的变量本身是无法修改的</li><li>将const作用于指针本身，这样可以防止改变指针指向的位置，但是该位置所存储的值是可以改变的，即可以通过指针指向的变量修改该地址存储的值</li></ul><h2 id="指针指向常规变量"><a href="#指针指向常规变量" class="headerlink" title="指针指向常规变量"></a>指针指向常规变量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> myInt=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * pt = &amp;myInt;</span><br></pre></td></tr></table></figure><p>这里的<code>pt</code>是一个指向 const int（10）的指针，因此无法使用<code>pt</code>来修改这个值，即 <code>*pt</code> 的值为const，不能被修改，如  <code>*pt+=1</code> 是不行的。</p><p>但是在这里，<code>myInt</code>本身并不是const的常量，而是对于<code>pt</code>而言，这个值是常量，也就是说无法利用<code>pt</code>来修改<code>myInt</code>的值，但是可以直接修改<code>myInt</code>本身：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*pt = <span class="number">20</span>;     <span class="comment">// 不合法的</span></span><br><span class="line">myInt = <span class="number">20</span>;     <span class="comment">// 合法的</span></span><br></pre></td></tr></table></figure><p>但是这种情况下，可以将一个新的地址赋给<code>pt</code>，这就也很微妙，虽然<code>pt</code>无法改变其所指向的地址存储的值，但是可以改变其所指向的地址，比如可以将一个新的地址赋给<code>pt</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> anotherInt = <span class="number">30</span>;</span><br><span class="line">pt = &amp;anotherInt;</span><br></pre></td></tr></table></figure><p>尽管改了新的地址，但是由于<code>pt</code>本身是一个指向常量的指针，所以依然无法改变新的地址存储的值（这里的30）</p><h2 id="常规指针指向变量"><a href="#常规指针指向变量" class="headerlink" title="常规指针指向变量"></a>常规指针指向变量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> myInt=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> pt = &amp;myInt;</span><br></pre></td></tr></table></figure><p>当const的位置改变，这种情况下，表示<code>pt</code>指针是一个const的常规指针，它只能指向<code>myInt</code>而不能改变指向的地址，也就是不能再对其赋一个新的值，但是由于<code>myInt</code>本身是一个变量，所以可以通过<code>myInt</code>改变10这个值，也可以通过<code>pt</code>来改变这个值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*pt=<span class="number">20</span>；     <span class="comment">// 合法的</span></span><br><span class="line">pt=&amp;anotherInt;     <span class="comment">// 不合法的</span></span><br></pre></td></tr></table></figure><h2 id="指向常规对象的常规指针"><a href="#指向常规对象的常规指针" class="headerlink" title="指向常规对象的常规指针"></a>指向常规对象的常规指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> myInt = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> pt = &amp;myInt;</span><br></pre></td></tr></table></figure><p>这是前两种情况的组合，此时<code>pt</code>只能指向<code>myInt</code>，并且<code>pt</code>不能用来修改<code>myInt</code>的值，即 <code>pt</code> 和 <code>*pt</code> 都是const。</p><h2 id="常规指针指向常规变量"><a href="#常规指针指向常规变量" class="headerlink" title="常规指针指向常规变量"></a>常规指针指向常规变量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> myInt=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* pt = $myInt;</span><br></pre></td></tr></table></figure><p>此时既不能使用<code>myInt</code>更改10这个值，也不能使用<code>pt</code>来修改10这个值。</p><h2 id="一种不允许的情况"><a href="#一种不允许的情况" class="headerlink" title="一种不允许的情况"></a>一种不允许的情况</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> myInt = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>* pt = &amp;myInt;</span><br></pre></td></tr></table></figure><p>这种情况是不允许的，因为如果这个赋值成立，那么const的状态就很奇怪了，<code>myInt</code>本身是常量，却可以使用<code>pt</code>指针来修改，所以这种情况是不合法的</p><h2 id="指针、数组与函数的参数传递"><a href="#指针、数组与函数的参数传递" class="headerlink" title="指针、数组与函数的参数传递"></a>指针、数组与函数的参数传递</h2><p>我们知道，函数对于传递数组作为参数，根据函数是否有权限改变数组的值，通常有两种声明方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionModify</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;<span class="comment">// 1号函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionNoChange</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> arr[], <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;<span class="comment">// 2号函数</span></span><br></pre></td></tr></table></figure><p>此时，如果我们有两个数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cosnt <span class="keyword">int</span> array1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">// 1号数组</span></span><br><span class="line"><span class="keyword">int</span> array2 = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;<span class="comment">// 2号数组</span></span><br></pre></td></tr></table></figure><p>很明显，一个是常量数组，一个是变量数组。两种数组对于两个函数的关系是这样的：</p><ul><li>禁止将常量数组的地址赋给非常量指针，即：1号数组不能传递给2号函数，只能传递给1号函数</li><li>可以将非常量数组赋给常量或非常量指针，即：2号数组可以被传递给1和2号函数</li></ul><p>因此，在设计函数时，要尽可能地使用const，因为将指针参数声明为指向常量数据的指针可以：</p><ul><li>避免由于无意间修改数据而导致的编程错误</li><li>使用const使得函数能够处理const和非const实参，否则将只能接受非const数据</li></ul><p>所以，如果条件允许，则应<strong>将指针形参声明为指向const的指针</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;指针&quot;&gt;&lt;a href=&quot;#指针&quot; class=&quot;headerlink&quot; title=&quot;指针&quot;&gt;&lt;/a&gt;指针&lt;/h1&gt;&lt;p&gt;指针是一个变量，存储的是值的地址&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/categories/C/"/>
    
    
      <category term="学习笔记" scheme="https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【C++温故知新】（一）数据类型</title>
    <link href="https://blogs.littlegenius.xin/2019/08/04/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E4%B8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://blogs.littlegenius.xin/2019/08/04/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E4%B8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2019-08-04T09:59:56.000Z</published>
    <updated>2019-08-05T03:38:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本的内置数据类型"><a href="#基本的内置数据类型" class="headerlink" title="基本的内置数据类型"></a>基本的内置数据类型</h1><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><table><thead><tr><th align="center">类型</th><th align="center">关键字</th></tr></thead><tbody><tr><td align="center">布尔型</td><td align="center">bool</td></tr><tr><td align="center">字符型</td><td align="center">char</td></tr><tr><td align="center">整型</td><td align="center">int</td></tr><tr><td align="center">浮点型</td><td align="center">float</td></tr><tr><td align="center">双浮点型</td><td align="center">double</td></tr><tr><td align="center">无类型</td><td align="center">void</td></tr><tr><td align="center">宽字符型</td><td align="center">wchar_t</td></tr></tbody></table><p>基本的数据类型可以使用如下的四种修饰符修饰：</p><ul><li><code>signed</code></li><li><code>unsigned</code></li><li><code>short</code></li><li><code>long</code></li></ul><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>使用<code>typedef</code>为某种数据类型起一个别名：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> typerName newTypeName</span><br></pre></td></tr></table></figure><h2 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h2><table><thead><tr><th align="center">字符名称</th><th align="center">C++代码</th></tr></thead><tbody><tr><td align="center">换行符</td><td align="center">\n</td></tr><tr><td align="center">水平制表符</td><td align="center">\t</td></tr><tr><td align="center">垂直制表符</td><td align="center">\v</td></tr><tr><td align="center">退格</td><td align="center">\b</td></tr><tr><td align="center">回车/返回行首</td><td align="center">\r</td></tr><tr><td align="center">振铃</td><td align="center">\a</td></tr><tr><td align="center">反斜杠</td><td align="center">\</td></tr><tr><td align="center">问号</td><td align="center">?</td></tr><tr><td align="center">单引号</td><td align="center">&#39;</td></tr><tr><td align="center">双引号</td><td align="center">&#39;‘</td></tr></tbody></table><h1 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组的声明与初始化方式"><a href="#数组的声明与初始化方式" class="headerlink" title="数组的声明与初始化方式"></a>数组的声明与初始化方式</h3><ul><li><code>int array[3];array[0] = 1;array[1] = 2;array[2] = 3;</code></li><li><code>int array[3] = {1,2,3}</code></li><li><code>int array[5] = {1,2}    // 1,2,0,0,0</code></li><li><code>int array[5] = {0}    // 0,0,0,0,0</code></li><li><code>int array[] = {1,2,3}    // size of the array is 3</code></li></ul><h3 id="获取数组长度："><a href="#获取数组长度：" class="headerlink" title="获取数组长度："></a>获取数组长度：</h3><p><code>sizeof array / sizeof (int)</code></p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="C风格的字符串"><a href="#C风格的字符串" class="headerlink" title="C风格的字符串"></a>C风格的字符串</h3><p>使用char数组存储字符串：一种C风格的字符串表达形式，需要使用 <code>&#39;\0&#39;</code> 做结尾才可以成为一个字符串</p><ul><li><code>char string1[5] = {&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;};    // not a string</code></li><li><code>char string1[6] = {&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;,&#39;\0&#39;};    // a string</code></li><li><code>char string2[6]=&quot;hello&quot;;    // &#39;\0&#39;可以被编辑器理解到并自行添加到末尾</code></li><li><code>char string3[] = &quot;hello&quot;;    // 编辑器可以自己确定数组的大小（6）</code></li></ul><p>获取一个C风格字符串的长度（不包括末尾的\0）：<code>strlen(string1)</code></p><h3 id="字符串的输入"><a href="#字符串的输入" class="headerlink" title="字符串的输入"></a>字符串的输入</h3><p>已知：<code>char hello[20];</code></p><ul><li><code>cin &gt;&gt; hello</code>：cin使用空白（空格、制表符和换行符）来确定字符串的结束位置，也就是说在cin读取到任何空白的时候都会结束输入，将剩余的部分保留在输入队列（输入流）中等待下一个输入命令来读取，（注意cin会读取掉该空白符，即空白符不再留在输入队列中），所以使用cin只能读取相应大小（比如此处的20）以内并且不含有空白符的字符串</li><li><code>cin.getline(hello,20)</code>：面向行的输入，它使用回车键输入的换行符来确定输入结尾，第二个参数表示其最多读取的字符个数+1后的值，即此处最多读取19个字符，所以这种方法读取指定长度的字符后或者遇到换行符后结束读取。</li><li><code>cin.get()</code>：<ul><li><code>cin.get(hello,20)</code>：和 <code>cin.getline(hello,20)</code> 效果相同，唯一不同的地方是，<code>cin.get()</code> 会将读取到的换行符保留在输入流中，不是将其读入或者丢弃。此时如果进行下一次 <code>cin.get()</code> 或者是 <code>cin.getline()</code> 都会使得被保留的换行符结束它们，使得他们什么都读不到（除了那个被保留在输入队列队首的换行符）。</li><li><code>cin.get(hello,20); cin.get(); cin.get(hello,20);</code> ：在使用完一次 <code>cin.get(arrayName,arraySize)</code> 后再次使用 <code>cin.get()</code> 将那个换行符读进来可以解决这个问题。</li><li><code>cin.get(hello,20).get()</code>：上一种方法的简写</li><li><code>(cin &gt;&gt; something).get()</code>：在<code>cin</code>后追加<code>get()</code>的简写</li><li>同理，<code>cin,getline(hello,20).getline(hello,20)</code>：连续使用 <code>cin.getline()</code> 读取两次的简写模式</li></ul></li></ul><h2 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h2><p>使用 string 类前必须包含 string 头文件：<code>#include&lt;string&gt;</code></p><h3 id="string的声明与初始化"><a href="#string的声明与初始化" class="headerlink" title="string的声明与初始化"></a>string的声明与初始化</h3><ul><li><code>string myString;</code></li><li><code>string myString = &quot;hello world!&quot;;</code></li><li><code>string mystring = {&quot;hello world!&quot;};</code></li><li><code>string myString1 = &quot;hello world!&quot;;string myString2 = myString1;</code></li></ul><h3 id="string的赋值、拼接与附加"><a href="#string的赋值、拼接与附加" class="headerlink" title="string的赋值、拼接与附加"></a>string的赋值、拼接与附加</h3><ul><li><code>string myString1 = &quot;hello world!&quot;;string myString2 = myString1;</code></li><li><code>string myString3;</code></li><li><code>myString3 = myString1 + myString2;</code></li><li><code>myString1 += myString2;</code></li></ul><h3 id="string类输入"><a href="#string类输入" class="headerlink" title="string类输入"></a>string类输入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getline(<span class="built_in">cin</span>,stringName)</span><br></pre></td></tr></table></figure><h2 id="结构体（struct）"><a href="#结构体（struct）" class="headerlink" title="结构体（struct）"></a>结构体（struct）</h2><h3 id="结构体的定义"><a href="#结构体的定义" class="headerlink" title="结构体的定义"></a>结构体的定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">structType</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">dataType dateName1;</span><br><span class="line">dataType dataName2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结构体的声明与初始化"><a href="#结构体的声明与初始化" class="headerlink" title="结构体的声明与初始化"></a>结构体的声明与初始化</h3><ul><li><code>structType structName1;</code></li><li><code>structType structName1 = {data1,data2};</code></li><li><code>structType structName2 = structName1;</code></li><li><code>structName1.dataName1 = data1;</code></li><li>在定义完结构体后直接声明一个结构体：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">structType</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">dataType dateName1;</span><br><span class="line">dataType dataName2;</span><br><span class="line">&#125;structName=&#123;</span><br><span class="line">data1,</span><br><span class="line">data2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>只声明一个结构，可以不提前定义结构体：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    dataType dateName1;</span><br><span class="line">    dataType dataName2;</span><br><span class="line">&#125;structName;</span><br></pre></td></tr></table></figure></li></ul><h3 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h3><p>假设已经定义了结构体结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">structType</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">dataType dateName1;</span><br><span class="line">dataType dataName2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>初始化一个结构体数组：</p><ul><li>先声明再逐个初始化<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">structType structArrayName[<span class="number">2</span>];</span><br><span class="line">structArrayName[<span class="number">0</span>]=&#123;data1,data2&#125;;</span><br></pre></td></tr></table></figure></li><li>声明的同时初始化<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">structArrayName[<span class="number">2</span>]=</span><br><span class="line">&#123;</span><br><span class="line">&#123;data1,data2&#125;,</span><br><span class="line">&#123;data1,data2&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="共用体（union）"><a href="#共用体（union）" class="headerlink" title="共用体（union）"></a>共用体（union）</h2><p>共用体和结构体类似，但是不同点在于结构体可以同时存储多种数据结构，但是共用体<strong>只能在同一时间存储一种数据结构</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> myUnion</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> myInt;</span><br><span class="line"><span class="keyword">double</span> myDouble;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myUnion union1;</span><br><span class="line">union1.myInt = <span class="number">1</span>;     <span class="comment">// 此时union1存储的是整数1</span></span><br><span class="line">union1.myDouble = <span class="number">1.1</span>;     <span class="comment">// 此时union1存储的是双精度的浮点数1.1</span></span><br></pre></td></tr></table></figure><h2 id="枚举（enum）"><a href="#枚举（enum）" class="headerlink" title="枚举（enum）"></a>枚举（enum）</h2><h3 id="枚举的声明"><a href="#枚举的声明" class="headerlink" title="枚举的声明"></a>枚举的声明</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> colors &#123;red,blue,green,yellow&#125;;     <span class="comment">// red=0, blue=1, green=2, yellow=3</span></span><br><span class="line">colors myColor = red;     <span class="comment">// myColor = 0</span></span><br><span class="line">colors myColor = colors(<span class="number">2</span>)     <span class="comment">// myColor = green = 2</span></span><br></pre></td></tr></table></figure><p>即枚举变量只能付给已经定义的几个值中的一个，不能赋予其他值</p><h3 id="枚举的值"><a href="#枚举的值" class="headerlink" title="枚举的值"></a>枚举的值</h3><ul><li>可以在每一个枚举变量后为其赋值，如果没有赋值的话该枚举值是前一个值+1<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> numbers &#123;one=<span class="number">1</span>, two=<span class="number">2</span>, four=<span class="number">4</span>, eight=<span class="number">8</span>&#125;</span><br><span class="line"><span class="keyword">enum</span> numbers &#123;one=<span class="number">1</span>, two=<span class="number">2</span>, four=<span class="number">4</span>, five, eight=<span class="number">8</span>&#125;     <span class="comment">// five = 5</span></span><br></pre></td></tr></table></figure></li><li>枚举的值实际上定义了一个范围，比如 <code>enum numbers {one=1, two=2, four=4, eight=8}</code> 中，如下的语句是合法的：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numbers myNumber = numbers(<span class="number">6</span>);</span><br></pre></td></tr></table></figure>虽然6没有被定义，但是却在定义的枚举值的范围内，是合法的。</li></ul><h3 id="枚举值的范围的计算方式："><a href="#枚举值的范围的计算方式：" class="headerlink" title="枚举值的范围的计算方式："></a>枚举值的范围的计算方式：</h3><ul><li>计算上限：找到定义的枚举值的最大值（比如100）；找到比这个最大值大的最小的一个2的幂（比如比100大的最小的是2的7次幂128）；将这个2的幂数减一（127）即为上限</li><li>计算下限：</li><li>如果已经定义的枚举值的最小值比0大或等于0，则下限是0</li><li>如果已经定义的枚举值的最小值比0小，则和计算上限的方式类似：先找到比这个定义的最小值（比如-6）小的，最大的2的次幂（-8）；将这个次幂数加一（-7）即为下限</li></ul><h2 id="vector模板类"><a href="#vector模板类" class="headerlink" title="vector模板类"></a>vector模板类</h2><p>使用vector模板类需要引入头文件：<code>#include&lt;vector&gt;</code><br><code>vector</code>可以存储n个（n可以为变量）该类型的数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;dataType&gt; vt(dataSize);     <span class="comment">// dataSize大小的dataType数据类型的对象</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;     <span class="comment">// 0大小的整型数组</span></span><br></pre></td></tr></table></figure><ul><li>优点：可以动态改变长度</li><li>缺点：效率比数组稍低</li></ul><h2 id="array模板类"><a href="#array模板类" class="headerlink" title="array模板类"></a>array模板类</h2><p>使用array模板类需要引入头文件：<code>#include&lt;array&gt;</code><br><code>array</code>模板类可以存储固定长度的某种数据类型的一个数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>&lt;dataType, arraySize&gt; arrayName;</span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>,5&gt; arrayInt;     <span class="comment">// 创建一个5个int值的数组对象</span></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">double</span>,3&gt; arrayDouble = &#123;<span class="number">1.1</span>,<span class="number">1.2</span>,<span class="number">1.3</span>&#125;;     <span class="comment">// 创建并初始化了一个3个double值的数组对象</span></span><br></pre></td></tr></table></figure><ul><li>有点：效率较快</li><li>缺点：只能声明固定长度的数组</li></ul><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dataType arrayName [row] [column]=</span><br><span class="line">&#123;</span><br><span class="line">    &#123;datas&#125;,</span><br><span class="line">    &#123;datas&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">dataType arrayName [row] [column];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; column; j++)</span><br><span class="line">    &#123;</span><br><span class="line">    arrayName[i][j]=data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本的内置数据类型&quot;&gt;&lt;a href=&quot;#基本的内置数据类型&quot; class=&quot;headerlink&quot; title=&quot;基本的内置数据类型&quot;&gt;&lt;/a&gt;基本的内置数据类型&lt;/h1&gt;&lt;h2 id=&quot;基本数据类型&quot;&gt;&lt;a href=&quot;#基本数据类型&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/categories/C/"/>
    
    
      <category term="学习笔记" scheme="https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Unity3D基础脚本编程</title>
    <link href="https://blogs.littlegenius.xin/2019/08/03/Unity3D%E5%9F%BA%E7%A1%80%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/"/>
    <id>https://blogs.littlegenius.xin/2019/08/03/Unity3D%E5%9F%BA%E7%A1%80%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/</id>
    <published>2019-08-03T11:35:44.000Z</published>
    <updated>2019-08-03T12:15:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unity3D脚本编程笔记–基础的脚本知识"><a href="#Unity3D脚本编程笔记–基础的脚本知识" class="headerlink" title="Unity3D脚本编程笔记–基础的脚本知识"></a>Unity3D脚本编程笔记–基础的脚本知识</h1><h2 id="从脚本开始"><a href="#从脚本开始" class="headerlink" title="从脚本开始"></a>从脚本开始</h2><h3 id="将脚本添加给GameObject"><a href="#将脚本添加给GameObject" class="headerlink" title="将脚本添加给GameObject"></a>将脚本添加给GameObject</h3><p>有三种方法可以将脚本添加给一个GameObject让其成为它的Component。</p><ul><li>将创建的脚本文件直接拖动给目标GameObject</li><li>将脚本文件拖动到该GameObject的Inspector面板中</li><li>在该GameObject的Inspector面板中最下方选择Add Component然后创建一个新的脚本，直接添加给该GameObject</li></ul><h3 id="访问限定词"><a href="#访问限定词" class="headerlink" title="访问限定词"></a>访问限定词</h3><ul><li><code>public</code> 修饰的变量在Inspector面板中可见并且可以直接进行调整</li><li><code>private</code> 修饰的变量只能在脚本程序中使用，在Inspector面板中不可见</li><li><code>public</code> 修饰的变量或者方法，在其他类中使用该类的实例，可以访问该类下的这些变量与方法</li><li><code>private</code> 修饰的变量只能在本类中使用和调用，不能被其实例访问</li></ul><h3 id="几个周期函数"><a href="#几个周期函数" class="headerlink" title="几个周期函数"></a>几个周期函数</h3><ul><li><code>Awake()</code><ul><li>在脚本被初始化的时候调用，尽管该脚本可能已经被禁用</li><li>在整个脚本的生命周期中只调用一次</li></ul></li><li><code>Start()</code><ul><li>在脚本第一次要Update之前，必须是在该脚本是enable的情况下</li><li>在整个脚本的生命周期中只调用一次</li></ul></li><li><code>Update()</code><ul><li>在每一帧出现时调用</li><li>每次更新的时间间隔不同</li><li>一般用于：<ul><li>移动非物理化物体的时候</li><li>简单的定时器</li><li>接收到输入的时候</li></ul></li></ul></li><li><code>FixedUpdate()</code><ul><li>每次物理操作之后调用</li><li>两次更新时间间隔一致</li><li>一般用于：<ul><li>调整物理物体（Rigidbody，刚体）</li></ul></li></ul></li></ul><h2 id="Unity3D中的向量"><a href="#Unity3D中的向量" class="headerlink" title="Unity3D中的向量"></a>Unity3D中的向量</h2><h3 id="向量运算"><a href="#向量运算" class="headerlink" title="向量运算"></a>向量运算</h3><ul><li><p>二维向量 <code>Vector2</code></p><ul><li>向量的模：<code>magnitude</code></li><li>向量的分量：<code>x  y</code></li><li>判定向量相等：<code>Equals</code></li><li>向量单位化：<code>Normalize</code></li><li>向量转化成字符串：<code>ToString</code><blockquote><p>完整Vector2参考：<a href="https://docs.unity3d.com/ScriptReference/Vector2.html?_ga=2.148748272.693619093.1552224779-1809290818.1551791741" target="_blank" rel="noopener">https://docs.unity3d.com/ScriptReference/Vector2.html?_ga=2.148748272.693619093.1552224779-1809290818.1551791741</a></p></blockquote></li></ul></li><li><p>三维向量 <code>Vector3</code></p><ul><li>向量的模：<code>magnitude</code></li><li>计算向量的模的平方，单纯为了比较大小，比计算模速度快：<code>sqrMagnitude</code></li><li>判定向量相等：<code>Equals</code></li><li>向量转化成字符串：<code>ToString</code></li><li>向量的内积（点乘）运算：<code>Dot</code><br>  <code>Vector3.Dot(VectorA, VectorB)</code><br>  <img src="http://cdn.littlegenius.xin/Unity3DScripts1-1.png" alt="向量的内积（点乘）"></li><li>向量的外积（叉乘）运算：<code>Cross</code><br>  <code>Vector3.Cross(VectorA, VectorB)</code><br>  <img src="http://cdn.littlegenius.xin/Unity3DScripts1-2.png" alt="右手坐标系">  <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/Unity3DScripts1-3.png" alt="向量的外积（叉乘）" title="">                </div>                <div class="image-caption">向量的外积（叉乘）</div>            </figure></li></ul></li></ul><h2 id="GameObject与Component"><a href="#GameObject与Component" class="headerlink" title="GameObject与Component"></a>GameObject与Component</h2><h3 id="获取Component"><a href="#获取Component" class="headerlink" title="获取Component"></a>获取Component</h3><ul><li>获取同GameObject下的Component<br>  <code>ComponentType componentName = GetComponent&lt;ComponentType&gt;();</code></li><li>获取其他GameObject下的Compnent<ul><li>先声明一个public变量，然后将其他GameObject的相应的Component拖动到该变量处赋值</li><li>先找到该GameObject再获取Component<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GameObject gameObjectName = GameObject.Find(<span class="string">"  "</span>);</span><br><span class="line">ComponentType componentName = gameObjectName.GetComponent&lt;ComponentType&gt;();</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="控制Component是否可用"><a href="#控制Component是否可用" class="headerlink" title="控制Component是否可用"></a>控制Component是否可用</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if  componentName  is a component got already</span></span><br><span class="line">componentName.enabled=<span class="literal">false</span>;     <span class="comment">//disable the component</span></span><br><span class="line">componentName.enabled=<span class="literal">true</span>;     <span class="comment">//enable the component</span></span><br></pre></td></tr></table></figure><h3 id="获取GameObject"><a href="#获取GameObject" class="headerlink" title="获取GameObject"></a>获取GameObject</h3><ul><li>获取脚本所属GameObject：直接使用 <code>gameObject</code></li><li>获取其他/一般的GameObject</li><li>声明一个public变量，将目标GameObject拖到该参数处为其赋值</li><li>使用Find方法<br>  <code>GameObject gameObjectName = GameObject.Find(&quot;  &quot;);</code></li><li>使用FindGameObjectsWithTag或者FindWithTag获取：为GameObject添加Tag可以在Instector面板中完成  <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/Unity3DScripts1-4.png" alt="为GameObject添加Tag" title="">                </div>                <div class="image-caption">为GameObject添加Tag</div>            </figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ComponentType componentName = GameObject.FindGameObjectsWithTag(<span class="string">"tag"</span>);</span><br><span class="line">ComponentType componentName = GameObject.FindWithTag(<span class="string">"tag"</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="控制GameObject是否可用"><a href="#控制GameObject是否可用" class="headerlink" title="控制GameObject是否可用"></a>控制GameObject是否可用</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if  gameObjectName  is a GameObject got already</span></span><br><span class="line">gameObjectName.SetActive(<span class="literal">false</span>);     <span class="comment">//disable the GameObject</span></span><br><span class="line">gameObjectName.SetActive(<span class="literal">true</span>);     <span class="comment">//enable the GameObject</span></span><br></pre></td></tr></table></figure><h3 id="判断GameObject是否可用"><a href="#判断GameObject是否可用" class="headerlink" title="判断GameObject是否可用"></a>判断GameObject是否可用</h3><p><code>// if  gameObjectName  is a GameObject got already</code></p><table><thead><tr><th align="center">语法</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">gameObjectName.activeSelf</td><td align="center">判断其本身是否active，其父物体为disable，但是其本身可能还是active</td></tr><tr><td align="center">gameObjectName.activeInHierarchy</td><td align="center">判断其所在分级是否active，即其父物体是否active</td></tr></tbody></table><h3 id="获取Transform"><a href="#获取Transform" class="headerlink" title="获取Transform"></a>获取Transform</h3><ul><li>获取脚本所在GameObject的Transform：直接使用 <code>transform</code></li><li>获取其他GameObject的Transform：先使用上述方法得到GameObject，然后使用 <code>gameObjectName.transform</code></li></ul><h3 id="移动（Translate）和旋转（Rotate）"><a href="#移动（Translate）和旋转（Rotate）" class="headerlink" title="移动（Translate）和旋转（Rotate）"></a>移动（Translate）和旋转（Rotate）</h3><ul><li><code>Translate</code>：Transform的方法，以一个Vector3为参数，按照Vector3所描述的方向与大小移动</li><li><code>Rotate</code>：Transform的方法，以一个Vector3为参数，按照Vector3所描述的方向与大小旋转</li><li><code>LookAt</code>：摄像机跟踪目标：<code>Transform.LookAt()</code>：以一个transform为参数，使得摄像机的transform跟随参数的transform变动，即实现跟踪</li></ul><h3 id="销毁（Destroy）"><a href="#销毁（Destroy）" class="headerlink" title="销毁（Destroy）"></a>销毁（Destroy）</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Destory(GameObject/Component);</span><br><span class="line">Destory(GameObject/Component,DelaySecond);</span><br></pre></td></tr></table></figure><h2 id="获取输入"><a href="#获取输入" class="headerlink" title="获取输入"></a>获取输入</h2><h3 id="获取按键输入"><a href="#获取按键输入" class="headerlink" title="获取按键输入"></a>获取按键输入</h3><ul><li><code>ButtonInput</code>：获取键钮，在 <strong>Edit -&gt; Project Settings -&gt; Input</strong> 中可以看到各种预设好的按键，读取这些键钮的名称作为GetButton的参数</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input.GetButtonDown(<span class="string">"name"</span>);     <span class="comment">// 键钮按下时的一帧为true</span></span><br><span class="line">Input.GetButton(<span class="string">"name"</span>);     <span class="comment">// 键钮按下时保持为true</span></span><br><span class="line">Input.GetButtonUp(<span class="string">"name"</span>);     <span class="comment">// 键钮按下然后释放后的状态下保持为true</span></span><br></pre></td></tr></table></figure><ul><li><code>KeyInput</code>：获取键钮<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input.GetKeyDown(KeyCode.name);     <span class="comment">// 键钮按下时的一帧为true</span></span><br><span class="line">Input.GetKey(KeyCode.name<span class="string">");     // 键钮按下时保持为true</span></span><br><span class="line"><span class="string">Input.GetKeyUp(KeyCode.name"</span>);     <span class="comment">// 键钮按下然后释放后的状态下保持为true</span></span><br></pre></td></tr></table></figure><blockquote><p>KeyCode完整参考：<a href="https://docs.unity3d.com/ScriptReference/KeyCode.html" target="_blank" rel="noopener">https://docs.unity3d.com/ScriptReference/KeyCode.html</a></p></blockquote></li></ul><h3 id="获取水平-竖直轴向输入"><a href="#获取水平-竖直轴向输入" class="headerlink" title="获取水平/竖直轴向输入"></a>获取水平/竖直轴向输入</h3><p>使用以下函数均可传入一个参数的两个值：“horizontal”、“vertical”来分别表示水平和竖直方向的运动</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input.GetAxisRaw() <span class="comment">//在参数设置的方向上返回 -1 或 1 两个值中的一个，即即止即停</span></span><br><span class="line">Input.GetAxis() <span class="comment">//在参数设置的方向上返回一个 -1 到 1 之间的float值，即有一定的缓冲变动的效果</span></span><br></pre></td></tr></table></figure><h3 id="获取鼠标输入"><a href="#获取鼠标输入" class="headerlink" title="获取鼠标输入"></a>获取鼠标输入</h3><ul><li><code>OnMouseDown()</code>：当鼠标点击GUIElement或者Collider时触发</li><li><code>OnMouseDrag()</code>：当鼠标点击GUIElement或者Collider并仍然按住时触发</li><li><code>OnMouseEnter()</code>：当鼠标进入GUIElement或者Collider时触发</li><li><code>OnMouseExit()</code>：当鼠标离开GUIElement或者Collider时触发</li><li><code>OnMouseOver()</code>：只要鼠标在GUIElement或者Collider上时的每一帧都会触发</li><li><code>OnMouseUp()</code>：当鼠标被释放时触发</li><li><code>OnMouseUpAsButton()</code>：当鼠标在点击了GUIElement或者Collider后并且释放时触发</li></ul><h3 id="DeltaTime"><a href="#DeltaTime" class="headerlink" title="DeltaTime"></a>DeltaTime</h3><p><code>DeltaTime</code>是指的每两个 <code>Update()</code> 函数或者 <code>FixedUpdate()</code> 函数调用之间的时间间隔，使用 <code>Time.deltaTime</code> 获得</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/Unity3DScripts1-5.png" alt="数据类型" title="">                </div>                <div class="image-caption">数据类型</div>            </figure><h3 id="类（Classes）"><a href="#类（Classes）" class="headerlink" title="类（Classes）"></a>类（Classes）</h3><ul><li>脚本名称和类名需要相同</li><li>详细情况与C#类一致</li></ul><h3 id="实例化预设体（Instantiate-Prefab）"><a href="#实例化预设体（Instantiate-Prefab）" class="headerlink" title="实例化预设体（Instantiate Prefab）"></a>实例化预设体（Instantiate Prefab）</h3><p>使用 <code>Instantiate</code> 来创建某个预设体（Prefab）的复制品（Clones）：<br>首先使用public变量来获取目标Prefab：<code>public PrefabType prefabName</code></p><ul><li><code>Instantiate(prefabName)</code>：从prefabName的预设体创建一个克隆体生成在坐标原点处</li><li><code>Instantiate(prefabName,Position,Rotation)</code>：规定预设体的位置与角度</li><li><code>Type reference</code>：<code>reference = Instantiate(prefabName,Position,Rotation) as Type;</code>：将预设体生成在指定位置与角度并且进行类型转换成Type类型</li></ul><blockquote><p>Instantiate完整参考：<a href="https://docs.unity3d.com/ScriptReference/Object.Instantiate.html?_ga=2.116872129.693619093.1552224779-1809290818.1551791741" target="_blank" rel="noopener">https://docs.unity3d.com/ScriptReference/Object.Instantiate.html?_ga=2.116872129.693619093.1552224779-1809290818.1551791741</a></p></blockquote><h3 id="数组（Arrays）"><a href="#数组（Arrays）" class="headerlink" title="数组（Arrays）"></a>数组（Arrays）</h3><p>在Unity的脚本中声明一个 <code>public</code> 类型的数组变量，不需要传入具体的大小，这样的数组可以在Inspector处直接更改数组大小，并且随着数组大小的改变还会自动为你添加每一个数组的参数值。<br>然后使用 <code>foreach</code> 循环或者 <code>for</code> 循环可以很方便的遍历整个数组。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> GameObject[] gameObjects;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Debug.Log(<span class="string">"Using For"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gameObjects.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">Debug.Log(gameObjects[i].name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Debug.Log(<span class="string">"Using Foreach"</span>);</span><br><span class="line"><span class="keyword">foreach</span>(GameObject items <span class="keyword">in</span> gameObjects)</span><br><span class="line">&#123;</span><br><span class="line">Debug.Log(items.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/Unity3DScripts1-7.png" alt="使用public的数组赋值" title="">                </div>                <div class="image-caption">使用public的数组赋值</div>            </figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="调用（Invoke）"><a href="#调用（Invoke）" class="headerlink" title="调用（Invoke）"></a>调用（Invoke）</h3><p><code>Invoke()</code>函数可以在一定时间后以及每一定时间间隔内调用某个方法，要求该方法必须是 0个参数，<code>void</code>返回值的函数。</p><p>比如我们有一个函数 <code>LogHello</code>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LogHello</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Debug.Log(<span class="string">"Hello World!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>Invoke</code> 来调用该方法：</p><ul><li><code>Invoke(&quot;LogHello&quot;, delayTime)</code>：第一个参数为要调用的方法的名称（字符串），第二个参数为要推迟多少时间调用该方法（单位：s）</li><li><code>InvokeRepeating(&quot;LogHello&quot;, delayTime, gapTime)</code>：前两个参数同上，第三个参数规定在第一次调用后每隔多长时间调用一次（单位：s）</li><li><code>CancelInvoke(&quot;LogHello&quot;)</code>：传入要停止<code>Invoke</code>的方法名称（字符串）</li></ul><h3 id="线性插值（Linear-Interplotation）"><a href="#线性插值（Linear-Interplotation）" class="headerlink" title="线性插值（Linear Interplotation）"></a>线性插值（Linear Interplotation）</h3><p>线性插值是在两个给定值之间找到一个百分比的值。比如在3和5之间找到一个50%处的值，即f4</p><ul><li><code>Mathf.Lerp</code>：三个float类型参数，前两个规定起止值，最后一个规定百分比，返回一个float类型的值<br>  <code>float result = Mathf.Lerp (3f, 5f, 0.5f);     // result = 4</code></li><li><code>Color.Lerp</code>：返回两个颜色值的百分比处的插值结果</li><li><code>Vector3.Lerp</code>：返回两个三维向量的百分比处的插值结果</li><li><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vector3 <span class="keyword">from</span> = <span class="keyword">new</span> Vector3 (<span class="number">1f</span>, <span class="number">2f</span>, <span class="number">3f</span>);`</span><br><span class="line">Vector3 to = <span class="keyword">new</span> Vector3 (<span class="number">5f</span>, <span class="number">6f</span>, <span class="number">7f</span>);</span><br><span class="line">Vector3 result = Vector3.Lerp (<span class="keyword">from</span>, to, <span class="number">0.75f</span>);     <span class="comment">// result = (4, 5, 6)</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Unity3D脚本编程笔记–基础的脚本知识&quot;&gt;&lt;a href=&quot;#Unity3D脚本编程笔记–基础的脚本知识&quot; class=&quot;headerlink&quot; title=&quot;Unity3D脚本编程笔记–基础的脚本知识&quot;&gt;&lt;/a&gt;Unity3D脚本编程笔记–基础的脚本知识&lt;/
      
    
    </summary>
    
    
      <category term="Unity3D" scheme="https://blogs.littlegenius.xin/categories/Unity3D/"/>
    
    
      <category term="学习笔记" scheme="https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Unity3D" scheme="https://blogs.littlegenius.xin/tags/Unity3D/"/>
    
  </entry>
  
  <entry>
    <title>【WEB JS PHP】屏幕截图粘贴上传+文字识别+一键复制识别结果</title>
    <link href="https://blogs.littlegenius.xin/2019/04/23/%E3%80%90%E6%8E%A8%E9%80%81%E3%80%91%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%E4%B8%80%E9%94%AE%E7%B2%98%E8%B4%B4-%E8%AF%86%E5%88%AB%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%96%87%E5%AD%97-%E4%B8%80%E9%94%AE%E5%A4%8D%E5%88%B6%E8%AF%86%E5%88%AB%E7%BB%93%E6%9E%9C/"/>
    <id>https://blogs.littlegenius.xin/2019/04/23/%E3%80%90%E6%8E%A8%E9%80%81%E3%80%91%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%E4%B8%80%E9%94%AE%E7%B2%98%E8%B4%B4-%E8%AF%86%E5%88%AB%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%96%87%E5%AD%97-%E4%B8%80%E9%94%AE%E5%A4%8D%E5%88%B6%E8%AF%86%E5%88%AB%E7%BB%93%E6%9E%9C/</id>
    <published>2019-04-23T07:22:17.000Z</published>
    <updated>2019-08-05T03:47:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天为大家带来一款我自己写的小应用，由于最近在学习网课，而个人又是OneNote笔记爱好者，不做笔记就觉得课程学习不完整，但是懒就懒在实在不想打字啊，所以想到了直接截图用文字识别嘛，于是经过几个小时的鼓捣，这个小应用就诞生了！本着好东西要分享的原则，特意把代码贴出来并且非常欢迎大家使用我写的这个小工具~</p><h1 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h1><p>当我们使用QQ、Tim、微信或者电脑自身的截图功能获取了截图后，不需要将图片保存成文件，只需在页面中的输入框中直接使用Ctrl+V或者右键粘贴就能得到剪贴板中的图片了。同时，我们会将你粘贴的图片上传到后台，调用百度AI的OCR（文字识别）接口，将图片中的文字识别并提取出来，将识别结果显示到页面上。最后，你可是一手动修改你认为识别不正确的地方，然后点击下边的按钮一键复制所有的识别结果，粘贴到你想要粘贴的任何部分！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/PasteOCR1.gif" alt="截取并识别视频中的文字" title="">                </div>                <div class="image-caption">截取并识别视频中的文字</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/PasteOCR2.gif" alt="截取并识别不可复制的文字内容" title="">                </div>                <div class="image-caption">截取并识别不可复制的文字内容</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/PasteOCR3.gif" alt="截取并识别图片中的文字" title="">                </div>                <div class="image-caption">截取并识别图片中的文字</div>            </figure><h1 id="基本原理与流程"><a href="#基本原理与流程" class="headerlink" title="基本原理与流程"></a>基本原理与流程</h1><ul><li>使用OCR接口前，需要先请求access_token，为了避免重复请求，将其保存在session中</li><li>使用JavaScript检测粘贴事件，并使用Clipboard技术获取剪贴板中的图片的Base64编码</li><li>显然，获取到的Base64编码是可以用来在页面中显示图片的</li><li>使用AJAX技术将Base64编码传送到后台</li><li>后台获取得到图片的Base64，进行预处理，包括去掉头部信息、将AJAX传送过程中自动转换的‘+’符号从空格转换回来等</li><li>将格式化好的图片的Base64编码请求百度的OCR接口返回文字识别结果</li><li>将多个零散的是被内容拼合成一个完整的字符串并返回给前端，显示在页面上</li><li>完成一键复制功能</li></ul><h1 id="实例与使用"><a href="#实例与使用" class="headerlink" title="实例与使用"></a>实例与使用</h1><p>本仓库中的代码省略了所有的样式，只保留了最简单的代码内容，一个比较好的可以运行的实例请参考笔者的个人项目。</p><p>也欢迎你收藏笔者的网站，随意使用，希望在一些情况下可以帮到你！</p><p><a href="https://www.littlegenius.xin/PasteOCR/" target="_blank" rel="noopener">笔者个人的项目实例</a></p><p>本项目申请使用了百度OCR接口中的“通用文字识别”接口，对于准确率来讲，个人使用基本满意，可以识别中英文和文字不是正向的图片（即文字方向旋转也生效），不能识别手写文字，每日识别次数上线为50000次。</p><p>如果你有任何提议或问题，欢迎使用邮件和我联系：<a href="mailto:&#109;&#x68;&#122;&#50;&#x31;&#x38;&#48;&#x35;&#x37;&#50;&#x35;&#48;&#57;&#x40;&#x31;&#x36;&#51;&#x2e;&#99;&#x6f;&#x6d;">&#109;&#x68;&#122;&#50;&#x31;&#x38;&#48;&#x35;&#x37;&#50;&#x35;&#48;&#57;&#x40;&#x31;&#x36;&#51;&#x2e;&#99;&#x6f;&#x6d;</a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>具体的完整的代码实现就在这里啦：<a href="https://github.com/mhz2180572509/PasteImagetoOCR" target="_blank" rel="noopener">https://github.com/mhz2180572509/PasteImagetoOCR</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天为大家带来一款我自己写的小应用，由于最近在学习网课，而个人又是OneNote笔记爱好者，不做笔记就觉得课程学习不完整，但是懒就懒在实在不想打字啊，所以想到了直接截图用文字识别嘛，于是经过几个小时的鼓捣，这个小应用就诞生了！本着好东西要分享的原则，特意把代码贴出来并且非常
      
    
    </summary>
    
    
      <category term="推送" scheme="https://blogs.littlegenius.xin/categories/%E6%8E%A8%E9%80%81/"/>
    
    
      <category term="WEB" scheme="https://blogs.littlegenius.xin/tags/WEB/"/>
    
      <category term="文字识别" scheme="https://blogs.littlegenius.xin/tags/%E6%96%87%E5%AD%97%E8%AF%86%E5%88%AB/"/>
    
      <category term="项目应用" scheme="https://blogs.littlegenius.xin/tags/%E9%A1%B9%E7%9B%AE%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu18.04 服务器部署与安装 Apache，PHP 7.2和MySQL</title>
    <link href="https://blogs.littlegenius.xin/2019/03/07/Ubuntu18.04%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%AE%89%E8%A3%85%20Apache%EF%BC%8CPHP%207.2%E5%92%8CMySQL/"/>
    <id>https://blogs.littlegenius.xin/2019/03/07/Ubuntu18.04%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%AE%89%E8%A3%85%20Apache%EF%BC%8CPHP%207.2%E5%92%8CMySQL/</id>
    <published>2019-03-07T07:40:50.000Z</published>
    <updated>2019-03-07T13:10:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单说明"><a href="#简单说明" class="headerlink" title="简单说明"></a>简单说明</h1><p>本教程针对于在Linux系统的服务器上安装部署服务器环境，如果你恰好有一台服务器（无论是实体服务器还是购买的云服务器），并且使用的是Linux系统，那么你就可以参考本文来安装Apache（Web服务器）、PHP7.2、数据库（MySQL/MariaDB），并且进行一些有必要的配置，比如对PHP的加速、安装phpMyAdmin以及获取SSL证书使用https协议等。从而，这几种应用程序的经典组合Linux、Apache、MySQL、PHP即统称为LAMP</p><h1 id="链接服务器"><a href="#链接服务器" class="headerlink" title="链接服务器"></a>链接服务器</h1><p>如果你在服务器本机上操作，直接打开服务器命令行终端即可。</p><p>如果你是购买的云服务器或者使用其他电脑远程连接控制该服务器，那么你首先要做的就是链接到你得服务器。</p><h2 id="Windows系统"><a href="#Windows系统" class="headerlink" title="Windows系统"></a>Windows系统</h2><p>Windows系统不能直接链接Linux系统，需要使用一些辅助工具，这里推荐使用Putty。</p><p>下载地址：<a href="https://www.putty.org/" target="_blank" rel="noopener">https://www.putty.org/</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/LAMP1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/LAMP2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>下载完成后直接安装，然后打开，可以进入登录页面，填写你的服务器IP地址，端口号选择22，连接方式选择SSH，然后链接即可，这里本人使用的云服务器的IP地址为39.106.23.80，全篇都采用次地址。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/LAMP3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>进入之后输入用户名，一般是初始值root，然后输入登录密码，密码在输入过程中不会显示任何东西，这是Linux对密码的保护机制，不必惊讶，保证不输错就行。</p><p>一切顺利的话会进入Linux系统，当显示 <code>~#</code> 时则表示可以输入命令了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/LAMP4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h2><p>Linux系统下可以直接链接Linux服务器，在命令行终端下，输入命令 <code>ssh root@39.106.23.80</code> 然后输入服务器的密码即可连接成功，同样出现 <code>~#</code> 的符号</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/LAMP5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="安装MySQL或MariaDB数据库"><a href="#安装MySQL或MariaDB数据库" class="headerlink" title="安装MySQL或MariaDB数据库"></a>安装MySQL或MariaDB数据库</h1><p>目前有两种广泛使用的MySQL数据库系统可供选择，这是由Oracle开发的经典“MySQL”服务器，现在可以在5.7版本中获得，而MySQL分支名为MariaDB，由原始MySQL开发人员Monty Widenius开发。这两种数据库只需要也只能安装一种，也就是说如下的两个小节“安装MySQL 5.7”和“安装MariaDB 10”只需要参考其一完成即可。</p><h2 id="安装MySQL-5-7"><a href="#安装MySQL-5-7" class="headerlink" title="安装MySQL 5.7"></a>安装MySQL 5.7</h2><p>使用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get -y install mysql-server mysql-client</span><br></pre></td></tr></table></figure><p>整个过程中你可能会被要求填写密码、设置一些东西，按照步骤要求填写即可，第一步是设置数据库密码，然后剩下的可以一路选择 y 表示 yes就行，直到最后会出现 Success. All done! 表示安装成功。</p><h2 id="安装MariaDB-10"><a href="#安装MariaDB-10" class="headerlink" title="安装MariaDB 10"></a>安装MariaDB 10</h2><p>使用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get -y install mariadb-server mariadb-client</span><br></pre></td></tr></table></figure><p>然后为MariaDB设置密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql_secure_installation</span><br></pre></td></tr></table></figure><p>整个过程大概这样：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/LAMP6.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>最后出现 <code>Thanks for using MairaDB</code> 即表示成功。</p><h2 id="测试MySQL-MariaDB-root登录"><a href="#测试MySQL-MariaDB-root登录" class="headerlink" title="测试MySQL/MariaDB root登录"></a>测试MySQL/MariaDB root登录</h2><p>使用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>输入刚刚设置的密码，看是否登录到数据库中。</p><p>如果是MySQL数据库，会变成使用 <code>mysql&gt;</code> 开头的符号等待命名输入，如果是MairaDB数据库则会使用 <code>MariaDB&gt;</code> 开头的符号等待命令输入，使用命令 <code>quit</code> 即可退出数据库，下图是MariaDB的图示。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/LAMP7.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="安装Apache"><a href="#安装Apache" class="headerlink" title="安装Apache"></a>安装Apache</h1><p>使用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get -y install apache2</span><br></pre></td></tr></table></figure><p>安装完毕后在浏览器中输入你的IP地址访问服务器，如果看到如下页面则表示Apache安装成功。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/LAMP8.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Ubuntu默认服务器的文档根目录是 <code>/var/www/html</code> ，主配置文件是 <code>/etc/apache2/apache2.conf</code> 配置系统的说明完整记录在 <code>/usr/share/doc/apache2/README.Debian.gz</code> 中</p><h1 id="安装PHP-7-2"><a href="#安装PHP-7-2" class="headerlink" title="安装PHP 7.2"></a>安装PHP 7.2</h1><h2 id="部署PHP语言环境"><a href="#部署PHP语言环境" class="headerlink" title="部署PHP语言环境"></a>部署PHP语言环境</h2><p>使用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get -y install php7.2 libapache2-mod-php7.2</span><br></pre></td></tr></table></figure><p>然后重新启动Apache</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart apache2</span><br></pre></td></tr></table></figure><p>测试PHP并获取PHP安装信息<br>在默认网站文档的根目录也就是 <code>/var/www/html</code> 下创建一个小小的php文件，并使用浏览器访问该文件来检测服务器和PHP语言环境是否正常运行。</p><p>使用vim编辑器新建并编辑一个php文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;var&#x2F;www&#x2F;html&#x2F;info.php</span><br></pre></td></tr></table></figure><p>就会进入vim编辑器，如果你不会使用vim编辑器，请按照如下步骤进行：<br>在输入上一条命令后在编辑器中按 <code>I</code> 键进入编辑模式，输入如下代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">phpinfo();</span><br></pre></td></tr></table></figure><p>然后按 <code>Esc</code> 键退出编辑模式，然后英文状态下输入 <code>:</code> ，会发现左下角出现了一个冒号，输入的光标指向了此处，此时输入 <code>wq</code> 然后按回车，即可返回命令行，同时文件创建编辑完毕。</p><p>回到命令行后，使用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown www-data:www-data &#x2F;var&#x2F;www&#x2F;html&#x2F;info.php</span><br></pre></td></tr></table></figure><p>将 <code>info.php</code> 文件的所有者更改为www-data用户和组</p><p>然后在我们的浏览器中使用IP访问我们的服务器并在后面加入 /info.php 来访问刚刚写的php文件，如果出现如下内容即表示PHP和Apache正确运行。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/LAMP9.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="链接PHP与MySQL-MariaDB数据库"><a href="#链接PHP与MySQL-MariaDB数据库" class="headerlink" title="链接PHP与MySQL/MariaDB数据库"></a>链接PHP与MySQL/MariaDB数据库</h2><p>使用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache search php7.2</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache search php-</span><br></pre></td></tr></table></figure><p>注意：因为并非所有PHP软件包的名称中都有版本号7.2，可以选择你需要的，并像这样安装它们：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get -y install php7.2-mysql php7.2-curl php7.2-gd php7.2-intl php-pear php-imagick php7.2-imap php-memcache  php7.2-pspell php7.2-recode php7.2-sqlite3 php7.2-tidy php7.2-xmlrpc php7.2-xsl php7.2-mbstring php-gettext</span><br></pre></td></tr></table></figure><p>重启Apache</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart apache2</span><br></pre></td></tr></table></figure><p>刷新刚刚的 <code>info.php</code> 页面然后在下方看到数据库的信息后表示成功！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/LAMP10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="安装Opcache-APCu-PHP缓存来加速PHP"><a href="#安装Opcache-APCu-PHP缓存来加速PHP" class="headerlink" title="安装Opcache + APCu PHP缓存来加速PHP"></a>安装Opcache + APCu PHP缓存来加速PHP</h2><p>PHP 7附带了一个内置的操作码缓存器，用于缓存和优化PHP中间代码，名称为“opcache”，可在包php7.0-opcache中找到。 强烈建议安装Opcache以加快PHP页面的速度。 除了opcache之外，我还将安装APCu，它是opcache的兼容性包装，提供APC缓存的功能，这是PHP 5.x版本中经常使用的缓存系统，许多CMS系统仍然使用它。</p><p>使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install php7.2-opcache php-apcu</span><br></pre></td></tr></table></figure><p>如果提示已经安装是正常的事情，然后重启Apache</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart apache2</span><br></pre></td></tr></table></figure><p>再次刷新 <code>info.php</code> 页面，如果找到下方的相关模块则表示安装成功</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/LAMP11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>完成了刚才的测试后，可以及时删除杠杆创建的 info.php 文件，这个文件中包含了许多关键的信息，不希望被他人看到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -f &#x2F;var&#x2F;www&#x2F;html&#x2F;info.php</span><br></pre></td></tr></table></figure><h1 id="设置https协议"><a href="#设置https协议" class="headerlink" title="设置https协议"></a>设置https协议</h1><h2 id="在Apache中启用SSL网站"><a href="#在Apache中启用SSL网站" class="headerlink" title="在Apache中启用SSL网站"></a>在Apache中启用SSL网站</h2><p>SSL/TLS是一个安全层，用于加密网络浏览器和服务器之间的连接。也就是目前支持的https协议。我们可以在服务器上使用如下命令启用SSL支持：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a2enmod ssl</span><br><span class="line">a2ensite default-ssl</span><br></pre></td></tr></table></figure><p>它启用SSL模块并在 <code>/etc/apache2/sites-enabled</code> 文件夹中添加一个符号链接到文件 <code>/etc/apache2/sites-available/default-ssl.conf</code>，用于将其包含到活动的apache配置中。 然后重启Apache：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart apache2</span><br></pre></td></tr></table></figure><p>此时在浏览器中使用https协议访问你得IP地址，如我的是：<a href="https://39.106.23.80/" target="_blank" rel="noopener">https://39.106.23.80/</a> ，会出现如下的提示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/LAMP12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>此时可以选择忽略警告继续浏览，可以进入我们原本的网站</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/LAMP13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/LAMP14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>为了避免出现类似的不安全警告，我们需要获取SSL证书</p><h2 id="从Let’s-Encrypt获取免费的SSL证书"><a href="#从Let’s-Encrypt获取免费的SSL证书" class="headerlink" title="从Let’s Encrypt获取免费的SSL证书"></a>从Let’s Encrypt获取免费的SSL证书</h2><p>首先安装python3-certbot-apache包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get -y install python3-certbot-apache</span><br></pre></td></tr></table></figure><p>使用编辑器打开vhost文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;apache2&#x2F;sites-available&#x2F;000-default.conf</span><br></pre></td></tr></table></figure><p>并在“DocumentRoot”下面添加一行：记得将如下的域名替换成自己的域名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerName www.littlegeniux.xin</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/LAMP15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>保存后回到命令行，使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot --apache -d www.littlegeniux.xin</span><br></pre></td></tr></table></figure><p>然后需要输入一个邮箱地址</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/LAMP16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>然后会经历一些步骤：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/LAMP17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>表示SSL证书配置成功：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/LAMP18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>此时通过 <a href="https://www.littlegenius.xin" target="_blank" rel="noopener">https://www.littlegenius.xin</a> 或者 <a href="https://39.106.23.80" target="_blank" rel="noopener">https://39.106.23.80</a> 访问网站就不再有安全警告出现了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/LAMP19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="设置加密自动更新"><a href="#设置加密自动更新" class="headerlink" title="设置加密自动更新"></a>设置加密自动更新</h2><p>由于SSL证书只在80天中有效，所以我们运行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot --renew</span><br></pre></td></tr></table></figure><p>来设置其自动更新</p><h1 id="安装phpMyAdmin"><a href="#安装phpMyAdmin" class="headerlink" title="安装phpMyAdmin"></a>安装phpMyAdmin</h1><p>phpMyAdmin是一个图形化管理数据库的工具，简单说是一个Web页面，你可以在其中可视化地管理你得数据库。</p><h2 id="配置phpMyAdmin"><a href="#配置phpMyAdmin" class="headerlink" title="配置phpMyAdmin"></a>配置phpMyAdmin</h2><p>使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get -y install phpmyadmin</span><br></pre></td></tr></table></figure><p>整个过程中会经历很多的设置，注意：这种设置是使用键盘的方向键进行选择，当移动到你想选中的位置后一定要按空格键才能将其选中，只移动方向键使它高亮并不是选中，一定要按空格键将其选中！选中后会有一个*号的标识。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/LAMP20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/LAMP21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>之后会有一系列的内容要选择</p><p><img src="http://cdn.littlegenius.xin/LAMP22.png" alt=""></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/LAMP23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/LAMP24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/LAMP25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/LAMP26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="对phpMyAdmin创建root权限"><a href="#对phpMyAdmin创建root权限" class="headerlink" title="对phpMyAdmin创建root权限"></a>对phpMyAdmin创建root权限</h2><p>在命令行中使用命令登录到数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root</span><br></pre></td></tr></table></figure><p>使用如下代码创建一个名为“admin”密码为“123456”的新用户，根据自己的需求更改下方的账户和密码成为你的，注意命令尾部的分号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &#39;admin&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;</span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#39;admin&#39;@&#39;localhost&#39; WITH GRANT OPTION;</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>配置上述内容后就可以在浏览器中使用 <a href="http://39.106.23.80/phpmyadmin/" target="_blank" rel="noopener">http://39.106.23.80/phpmyadmin/</a> 访问phpMyAdmin啦：</p><p><img src="http://cdn.littlegenius.xin/LAMP27.png" alt=""></p><p>输入账号密码即可在phpMyAdmin中管理你得数据库！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/LAMP28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="本地与服务器之间的文件传输"><a href="#本地与服务器之间的文件传输" class="headerlink" title="本地与服务器之间的文件传输"></a>本地与服务器之间的文件传输</h1><p>服务器的搭建和配置任务全部完成了，最后你可能还需要知道如何实现本机与服务器之间的文件传输。</p><h2 id="Linux系统-1"><a href="#Linux系统-1" class="headerlink" title="Linux系统"></a>Linux系统</h2><p>如果你本机使Linux系统，很简单，使用命令行终端就可以完成：<br>将本地文件 <code>/home/test.txt</code> 传输到服务器的 <code>/var/www/html</code> 目录下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp  &#x2F;home&#x2F;test.txt root@39.106.23.80:&#x2F;var&#x2F;www&#x2F;html</span><br></pre></td></tr></table></figure><p>将服务器的 <code>/var/www/html/test.txt</code> 文件传输到本地的 <code>/home</code> 目录下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp  root@39.106.23.80:&#x2F;var&#x2F;www&#x2F;html&#x2F;test.txt &#x2F;home</span><br></pre></td></tr></table></figure><p>将本地文件 <code>/home</code> 整个目录传输到服务器的 <code>/var/www/html</code> 目录下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp  &#x2F;home root@39.106.23.80:&#x2F;var&#x2F;www&#x2F;html</span><br></pre></td></tr></table></figure><p>将服务器的 <code>/var/www/html</code> 整个目录传输到本地的 <code>/home</code> 目录下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp  root@39.106.23.80:&#x2F;var&#x2F;www&#x2F;html &#x2F;home</span><br></pre></td></tr></table></figure><h2 id="Windows系统-1"><a href="#Windows系统-1" class="headerlink" title="Windows系统"></a>Windows系统</h2><p>如果你是用Windows系统，那么你可以使用WinScp工具来完成这个过程.</p><p>下载地址：<a href="https://winscp.net/eng/index.php" target="_blank" rel="noopener">https://winscp.net/eng/index.php</a></p><p>下载好后安装，然后和putty的界面和操作类似，输入IP地址，端口号设置为22，然后输入用户名与密码</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/LAMP29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果经常使用可以选择保存将这个IP保存，下次就不需要再输入一次了</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/LAMP30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>连接建立后就会出现如下的界面，很简单，左边是你的Windows目录，右边就是你的服务器目录，需要进行文件传递只需要将文件或者文件夹从左侧拖动到右侧或者从右侧拖动回左侧即可。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/LAMP31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简单说明&quot;&gt;&lt;a href=&quot;#简单说明&quot; class=&quot;headerlink&quot; title=&quot;简单说明&quot;&gt;&lt;/a&gt;简单说明&lt;/h1&gt;&lt;p&gt;本教程针对于在Linux系统的服务器上安装部署服务器环境，如果你恰好有一台服务器（无论是实体服务器还是购买的云服务器），并且
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://blogs.littlegenius.xin/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://blogs.littlegenius.xin/tags/Linux/"/>
    
      <category term="技术指南" scheme="https://blogs.littlegenius.xin/tags/%E6%8A%80%E6%9C%AF%E6%8C%87%E5%8D%97/"/>
    
      <category term="服务器" scheme="https://blogs.littlegenius.xin/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>安装好Ubuntu双系统后的一些事情</title>
    <link href="https://blogs.littlegenius.xin/2019/02/20/%E5%AE%89%E8%A3%85%E5%A5%BDUbuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B%E6%83%85/"/>
    <id>https://blogs.littlegenius.xin/2019/02/20/%E5%AE%89%E8%A3%85%E5%A5%BDUbuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B%E6%83%85/</id>
    <published>2019-02-20T04:44:01.000Z</published>
    <updated>2019-02-20T05:15:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建root管理权限"><a href="#创建root管理权限" class="headerlink" title="创建root管理权限"></a>创建root管理权限</h1><p>root管理权限即Linux系统的超级管理权限，他几乎可以做所有操作，新的Linux系统是需要设置root权限的，必须先设置root密码，这个密码可以和你登陆系统的密码不同。</p><p>打开命令行后输入：<code>sudo passwd</code></p><p>然后会提示创建新的密码，输入过程中不会显示（Ubuntu之于密码都是这么处理的），然后会第二次输入确认密码，之后回车就可以创建了。这时候输入命令：<code>su</code>，即可进入超级管理权限哦（你可能会注意到，超级管理权限的命令行前是#打头，普通权限是$打头），输入命令：<code>exit</code>，即可退出超级管理权限.</p><h1 id="之去掉桌面的垃圾桶图标"><a href="#之去掉桌面的垃圾桶图标" class="headerlink" title="之去掉桌面的垃圾桶图标"></a>之去掉桌面的垃圾桶图标</h1><p>很多人是不是看到干干净净的桌面上有一个回收站的图标深感不满，本教程关于如何去掉桌面上的回收站图标。</p><p>首先在应用商店中搜索寻找到“GNOME Tweaks”</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/Ubuntu%E4%BA%8C1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>确认是这个软件后点击“安装”:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/Ubuntu%E4%BA%8C2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>安装完成后打开，在里边找到“桌面”也就是“Desktop”选项设置，右侧的“回收站”也就是“Trash”一项就可以选择是否显示了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/Ubuntu%E4%BA%8C3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="安装拼音输入法"><a href="#安装拼音输入法" class="headerlink" title="安装拼音输入法"></a>安装拼音输入法</h1><p>打开设置</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/Ubuntu%E4%BA%8C4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>找到“地区和语言”设置项，点击右边的“管理已经安装的语言”</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/Ubuntu%E4%BA%8C5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这时候可能会弹出下边的窗口，可以点开细节查看发现是一些小语种，再次建议可以选择不安装，除非你有特殊需求，否则是没什么作用的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/Ubuntu%E4%BA%8C6.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>此处选择“安装/删除语言”选项，点开这个选项时留意一下下边的是否是“IBus”，如果不是更改成为“IBus”（默认应该是这个选项）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/Ubuntu%E4%BA%8C7.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>点开后找到汉语（简体）也就是“Chinese(simplified)”，在后边打勾，然后别忘了点击“应用”，也就是“Apply”</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/Ubuntu%E4%BA%8C8.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>此时可以关闭这个设置卡，回到刚刚的设置，点击下边的“+”号。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/Ubuntu%E4%BA%8C9.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>此时，应该就可以看到“Chinese”了，<strong>双击</strong>这一行。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/Ubuntu%E4%BA%8C10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这时可以看到有我们安装的拼音输入法了，下边也有五笔输入，可以自行选择。选好后，点击右上角的“添加”，也就是“Add”，即可。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/Ubuntu%E4%BA%8C11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>回到桌面，可以找到自己的两个输入法了，并且通过Shift键也可以在两个输入法之间切换。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/Ubuntu%E4%BA%8C12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="开机启动引导页面的优化与美化"><a href="#开机启动引导页面的优化与美化" class="headerlink" title="开机启动引导页面的优化与美化"></a>开机启动引导页面的优化与美化</h1><p>不出意外地，安装好Ubuntu和Windows的双系统后应该是由Ubuntu的grub引导启动的，也就是开机的时候要我们选择进入那个系统的那个黑底白字的难看至极的页面，这篇文章的目的就是对grub引导进行设置和美化。</p><h2 id="优化设置"><a href="#优化设置" class="headerlink" title="优化设置"></a>优化设置</h2><p>grub引导的设置文件是 /etc/default/grub ，对其进行修改可以得到我们想要的结果。</p><p>在命令行中输入：如果你会使用vim： <code>sudo vim /etc/default/grub</code></p><p>或者如果你不会使用vim：<code>sudo gedit /etc/default/grub</code></p><p>然后我们就可以对设置文件进行编辑了</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/Ubuntu%E4%BA%8C13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>一般我们需要更改其中的 GRUB_DEFAULT（默认启动项：这个编号是你开机时看到的若干个启动项从上到下的依次编号，记住！程序员世界的编号从来都是从0开始的，意思是，第一项是0，第二项是1，以此类推）、GRUB_TIMEOUT_STYLE（是否显示倒计时，hidden的属性表示不会显示倒计时）、GRUB_TIMEOUT（等待时间，单位是秒）、GRUB_GFXMODE（屏幕的显示像素，可以不用管这一项）</p><p>按照自己的需求更改，其他的很多配置如果你还需要更改可以去查询每一项的具体含义和属性值。</p><p><strong>注意一点，如果你更改的属性语句前边有#符号，一定要将其去掉这一句才会起作用。</strong></p><p>完成后记得保存离开，然后再命令行输入： <code>sudo update-grub</code> ，对刚才的设置进行更新。整体下来大概是这个样子：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/Ubuntu%E4%BA%8C14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="页面美化"><a href="#页面美化" class="headerlink" title="页面美化"></a>页面美化</h2><p>这个黑底白字的启动引导页面说实话还是极其丑陋的，不过好在我们可以对其进行美化。如果你是可以完成自己修改源码或者加上样式的大神，不用我多说，但是如果你想省事或者不会自己写页面样式，可以去这里下载一款你喜欢的风格的页面样式给自己使用就好： （可能需要翻墙，如果需要请移步我的其他有关科学上网的文章），点击左侧的GRUB Themes</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/Ubuntu%E4%BA%8C15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这里你就可以看到各种各样的主题了，选择自己喜欢的一个，我以这个“Poly lignt”为例，选择它并下载。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/Ubuntu%E4%BA%8C16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/Ubuntu%E4%BA%8C17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果你实在无法打开这个页面，可以来我的百度云分享的这个文件出下载：<a href="https://pan.baidu.com/s/1HEhEGK_qK9-0o826CePqrQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1HEhEGK_qK9-0o826CePqrQ</a> 提取码：x1hl </p><p>下载好后得到了一个压缩包，将其解压</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/Ubuntu%E4%BA%8C18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>创建一个文件夹：<code>sudo mkdir /boot/grub/themes/</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/Ubuntu%E4%BA%8C19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>将整个解压出来的文件夹拷贝到刚刚创建的文件夹下：<code>sudo cp -R poly-light-master /boot/grub/themes/</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/Ubuntu%E4%BA%8C20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>接下来编辑文件：/etc/grub.d/00_header，即输入命令：<code>sudo gedit /etc/grub.d/00_header</code></p><p>如果你发现自己更改内容之后无法保存文件，说明你权限不够，可以进入root权限再次编辑</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/Ubuntu%E4%BA%8C21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在打开的 00_header 文件中，加入如下两行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GRUB_THEME&#x3D;”&#x2F;boot&#x2F;grub&#x2F;themes&#x2F;poly-light-master&#x2F;theme.txt”</span><br><span class="line">GRUB_GFXMODE&#x3D;”1920×1080”</span><br></pre></td></tr></table></figure><p>第一句根据你下载的主题改成自己刚刚拷贝到themes文件夹下的主题包中的theme.txt文件，第二句是你屏幕的分辨率。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/Ubuntu%E4%BA%8C22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>保存后记得要更新一下grub： <code>sudo update-grub</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/Ubuntu%E4%BA%8C23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>好了，此时再次重启你的电脑就可以看到好看的开机页面啦！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;创建root管理权限&quot;&gt;&lt;a href=&quot;#创建root管理权限&quot; class=&quot;headerlink&quot; title=&quot;创建root管理权限&quot;&gt;&lt;/a&gt;创建root管理权限&lt;/h1&gt;&lt;p&gt;root管理权限即Linux系统的超级管理权限，他几乎可以做所有操作，新的L
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://blogs.littlegenius.xin/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://blogs.littlegenius.xin/tags/Linux/"/>
    
      <category term="技术指南" scheme="https://blogs.littlegenius.xin/tags/%E6%8A%80%E6%9C%AF%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
</feed>
