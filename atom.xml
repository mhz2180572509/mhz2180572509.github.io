<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小天才的杂货铺</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blogs.littlegenius.xin/"/>
  <updated>2020-01-13T13:15:38.346Z</updated>
  <id>https://blogs.littlegenius.xin/</id>
  
  <author>
    <name>MA Haozhe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【机器学习】（七）概率图模型</title>
    <link href="https://blogs.littlegenius.xin/2020/01/13/%E3%80%90ML%E3%80%917%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B/"/>
    <id>https://blogs.littlegenius.xin/2020/01/13/%E3%80%90ML%E3%80%917%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-01-13T12:49:09.000Z</published>
    <updated>2020-01-13T13:15:38.346Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概率模型与概率图模型"><a href="#概率模型与概率图模型" class="headerlink" title="概率模型与概率图模型"></a>概率模型与概率图模型</h1><h2 id="概率模型"><a href="#概率模型" class="headerlink" title="概率模型"></a>概率模型</h2><p><strong>概率模型</strong>（probabilistic model）提供了一种描述框架，将学习任务归结于计算变量的概率分布。在概率模型中，利用已知变量推测未知变量的分布称为<strong>推断</strong>（inference），其核心是如何基于可观测变量推测出未知变量的条件分布。假定所关心的变量集合为Y，可观测变量集合为O，其他变量的集合为R。</p><ul><li><strong>生成式</strong>（generative）模型考虑联合分布P(Y,R,O)</li><li><strong>判别式</strong>（discriminative）模型考虑条件分布P(Y,R|O)</li></ul><p>给定一组观测变量值，推断就是要由P(Y,R,O)或P(Y,R|O)得到条件概率分布P(Y|O)</p><h2 id="概率图模型"><a href="#概率图模型" class="headerlink" title="概率图模型"></a>概率图模型</h2><p><strong>概率图模型</strong>（probabilistic graphical model）是一类用图来表达变量相关关系的概率模型。它以图为表示工具，最常见的是用一个结点表示一个或一组随机变量，结点之间的边表示变量间的概率相关关系，即变量关系图。</p><p>根据边的性质不同，概率图模型可大致分为两类</p><ul><li><strong>贝叶斯网</strong>（Bayesian network）：使用<strong>有向无环图</strong>表示变量间的依赖关系</li><li><strong>马尔可夫网</strong>（Markovnetwork）：使用<strong>无向图</strong>表示变量间的相关关系，又称为无向图模型</li></ul><h1 id="隐马尔可夫模型"><a href="#隐马尔可夫模型" class="headerlink" title="隐马尔可夫模型"></a>隐马尔可夫模型</h1><p><strong>隐马尔可夫模型</strong>（Hidden Markov Model，HMM）是结构最简单的<strong>动态贝叶斯网</strong>（dynamic Bayesian network），主要用于时序数据建模。</p><p>隐马尔可夫模型中的变量可以分为两组：</p><ul><li>状态变量：状态变量yi表示第i时刻的系统状态，通常假定状态变量是隐藏的、不可被观测的，因此也称<strong>隐变量</strong>（hidden variable）。隐马尔可夫模型中，系统的状态通常在多个状态之间互相转化，因此一般认为状态变量的取值是有限的离散值。</li><li>观测变量：观测变量xi表示第i时刻的观测值。它可以是离散型也可以是连续型。</li></ul><p>隐马尔可夫模型各变量的依赖关系如下图。在任一时刻，观测变量的取值仅依赖于状态变量，即 xt 仅由 yt 确定；任一时刻的状态变量仅依赖于其上一时刻的状态变量，即 yt 仅依赖于 y(t-1)。这就是<strong>马尔可夫链</strong>（Markov chain），即：系统下一时刻的状态仅由当前状态决定，不依赖于以往的任何状态。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/6966151-f5780ebf445eed7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>基于马尔可夫链，所有变量的联合概率分布为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/6966151-54130215644cf0d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p> 为确定一个隐马尔可夫模型，需要以下三组参数：</p><ul><li>状态转移概率：模型在各个状态间转换的概率，通常记为矩阵A=[aij]N×N，其中<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/6966151-1d07fe8bdc046da2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>表示在任意时刻t，若状态为si，则在下一时刻状态为sj的概率</li><li>输出观测概率：模型根据当前状态获得各个观测值的概率，通常记为矩阵B=[bij]N×M，其中<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/6966151-3759dd0e8c8618fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>表示在任意时刻t，若状态为si，则观测值oj被获取的概率</li><li>初始状态概率：模型在初始时刻各状态出现的概率，通常记为π=(π1, π2, …, πN)，其中<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/6966151-e8695206412acd95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>表示模型的初始状态为si的概率</li></ul><p>从而，隐马尔可夫模型通常使用 λ=[A, B, π] 来表示。</p><h1 id="马尔可夫随机场"><a href="#马尔可夫随机场" class="headerlink" title="马尔可夫随机场"></a>马尔可夫随机场</h1><p><strong>马尔可夫随机场</strong>（Markov Random Field，MRF）是典型的马尔可夫网，这是一种无向图模型。图中每个结点表示一个或一组变量，结点之间的边表示两个变量之间的依赖关系。马尔可夫随机场有一组<strong>势函数</strong>（potential functions），亦称<strong>因子</strong>（factor），这是定义在变量子集上的<strong>非负实函数</strong>，主要用于定义概率分布函数。</p><p>如下图即一个简单的马尔可夫随机场：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/6966151-043e59b97e3907e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="马尔可夫随机场计算联合分布"><a href="#马尔可夫随机场计算联合分布" class="headerlink" title="马尔可夫随机场计算联合分布"></a>马尔可夫随机场计算联合分布</h2><p>在一个马尔可夫随机场中定义如下概念：</p><ul><li><strong>团</strong>（clique）：对于图中结点的一个子集，若其中任意两个结点之间都有边连接，则称该子集为一个团</li><li><strong>极大团</strong>（maximal clique）：若某个团加入另外任何一个结点都不能再够成团，则称该团为极大团，即极大团就是不能被其他团所包含的团</li></ul><p>马尔可夫随机场中，所有变量的联合概率可以通过团来定义，每个因子仅与一个团相关。若所有的团构成集合C，与团Q相关的变量集合记为xQ，则联合概率定义为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/6966151-5292ae90e810bc52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>其中ψQ为与团Q对应的势函数，用于对团Q中的变量关系进行建模</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/6966151-58a1872d1834a940.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>称为规范化因子，一般很难计算，所以往往不需要Z的精确值</p><p>为了减少团的数量同时保证满足每个因子仅与一个团相关这个条件，通常使用极大团Q*来计算，使用极大团定义的联合概率为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/6966151-8cd4cd78f4192e97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="马尔可夫随机场中的条件独立性"><a href="#马尔可夫随机场中的条件独立性" class="headerlink" title="马尔可夫随机场中的条件独立性"></a>马尔可夫随机场中的条件独立性</h2><p>定义如下概念：</p><p>若马尔可夫随机场中，结点集A中的结点到B中的结点都必须经过结点集C中的结点，则称结点集A和B被结点集C分离，结点集C称为分离集（separating set），如图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/6966151-357288c5d7ad8230.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>全局马尔可夫性（global Markov     property）：给定两个变量子集的分离集，则这两个变量子集条件独立，如上图中，xA和xB在给定xC的条件下独立，记为：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/6966151-76a3d08eb2796834.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li>局部马尔可夫性（local Markov property）：给定某变量的邻接变量，则该变量条件独立于其他变量。例如，令V为图的结点集，n(v)为结点v在图上的邻接结点，n*(v)=n(v)U{v}，有：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/6966151-aae8cfbd63248d36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li>成对马尔可夫性（pairwise Markov property）：给定所有其他变量，两个非邻接变量条件独立。例如，令图的结点集和边集分别为V和E，对图中的两个结点u和v，若⟨n,v⟩∉E，则：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/6966151-7689389de19be650.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul><h2 id="势函数"><a href="#势函数" class="headerlink" title="势函数"></a>势函数</h2><p>势函数定量地刻画变量集xQ中变量之间的相关关系，是非负函数，且在所偏好的变量取值上有较大的函数值，势函数常用指数函数定义：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/6966151-5ff6c7e17c50b356.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>HQ(xQ)是一个定义在变量xQ上的实值函数，常见形式为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/6966151-af166955163f398a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="条件随机场"><a href="#条件随机场" class="headerlink" title="条件随机场"></a>条件随机场</h1><p><strong>条件随机场</strong>（Conditional Random Field，CRF）是一种判别式无向图模型，对条件分布进行建模。隐马尔可夫模型和马尔可夫随机场为生成式模型，直接对联合分布进行建模。</p><p>条件随机场试图对多个变量在给定观测值后的条件概率进行建模。具体来说，若令x={x1, x2, …, xn}为观测序列，y={y1, y2, …, yn} 为与之相应的标记序列，则条件随机场的目标是构建条件概率模型P(y|x)。</p><p>令G=&lt;V,E&gt;表示结点与标记变量y中元素一一对应的无向图，yv表示与结点v对应的标记变量，n(v)表示结点v的邻接结点，若图G的每个变量yv都满足马尔可夫性，即：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/6966151-c83a8a1c3bab8ea9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>则G=&lt;V,E&gt;构成一个条件随机场</p><p>理论上来说，图G可具有任意结构，只要能表示标记变量之间的条件独立性关系即可。但在现实应用中，尤其是对标记序列建模时，最常用的仍是如下图所示的链式结构，即<strong>链式条件随机场</strong>（chain-structured CRF）：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/6966151-cb39e2228229d6d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>条件随机场中，通过选用指数势函数并引入<strong>特征函数</strong>（feature function），条件概率被定义为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/6966151-f19f0dabcf63bd11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>其中tj是定义在观测序列的两个相邻标记位置上的<strong>转移特征函数</strong>（transition feature function），用于刻画相邻标记变量之间的相关关系以及观测序列对它们的影响，sk是定义在观测序列的标记位置i上的<strong>状态特征函数</strong>（status feature function），用于刻画观测序列对标记变量的影响，λj和μk为参数，Z为规范化因子。</p><ul><li>条件随机场和马尔可夫随机场均使用团上的势函数定义概率，两者在形式上没有显著区别</li><li>条件随机场处理的是条件概率，而马尔可夫随机场处理的是联合概率</li></ul><blockquote><p>全文参考：周志华 著 《机器学习》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概率模型与概率图模型&quot;&gt;&lt;a href=&quot;#概率模型与概率图模型&quot; class=&quot;headerlink&quot; title=&quot;概率模型与概率图模型&quot;&gt;&lt;/a&gt;概率模型与概率图模型&lt;/h1&gt;&lt;h2 id=&quot;概率模型&quot;&gt;&lt;a href=&quot;#概率模型&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://blogs.littlegenius.xin/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习笔记" scheme="https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="机器学习" scheme="https://blogs.littlegenius.xin/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>强化学习（一）强化学习的基本概念、e贪心算法、Softmax算法</title>
    <link href="https://blogs.littlegenius.xin/2020/01/12/RLNotes-1/"/>
    <id>https://blogs.littlegenius.xin/2020/01/12/RLNotes-1/</id>
    <published>2020-01-12T09:41:18.000Z</published>
    <updated>2020-01-12T15:12:09.161Z</updated>
    
    <content type="html"><![CDATA[<p><strong>强化学习</strong>（reinforcement learning，RL）是机器学习的一个领域，主要通过在<strong>环境</strong>（environment）中采取<strong>动作</strong>（action），来最大化某些指标，例如<strong>累计奖赏</strong>（cumulative reward）的一种学习方法。<strong>强化学习</strong>、<strong>有监督学习</strong>（supervised learning）与<strong>无监督学习</strong>（unsupervised learning）三者共同构成了机器学习的三个重要方面</p><blockquote><p>Reinforcement learning (RL) is an area of machine learning concerned with how software agents ought to take actions in an environment in order to maximize some notion of cumulative reward. Reinforcement learning is one of three basic machine learning paradigms, alongside supervised learning and unsupervised learning. (WikiPedia)</p></blockquote><h1 id="任务与奖赏"><a href="#任务与奖赏" class="headerlink" title="任务与奖赏"></a>任务与奖赏</h1><p>一个简单的强化学习模型如图所示</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/RL/1/1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>强化学习任务通常用<strong>马尔可夫决策过程</strong>（Markov Decision Process，MDP）来描述：机器处于<strong>环境</strong>E中，<strong>状态空间</strong>为X，其中每个状态x∈X是机器感知到的环境的描述，机器能采取的动作构成了<strong>动作空间</strong>A，若某个动作a∈A作用在当前状态x上，则潜在的转移函数P将使得环境从当前状态按某种概率转移到另一个状态，同时，环境会根据潜在的奖赏函数R反馈给机器一个奖赏。综合起来，强化学习任务对应了四元组E=&lt;X,A,P,R&gt;，其中P:X×A×X→R指定了状态转移概率，R:X×A×X→R（或者R:X×X→R）指定了奖赏。</p><p>如下图所示是一个在培育农作物的过程中，浇水与否（两个动作：浇水与不浇水）与农作物的状态（健康、缺水、溢水、凋亡）的马尔可夫决策过程：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/RL/1/2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在强化学习中，机器要做的即通过在环境中不断尝试而学得一个<strong>策略</strong>（policy）π，根据这个策略，在状态x下得到要执行的动作或者以多少概率执行动作空间中的任意动作。</p><p>在强化学习中，并没有监督学习中的有标记样本，动作是否正确以及接下来要做哪些动作，需要机器通过反思之前的动作与累积奖赏进行学习。因此，强化学习在某种意义上可看作<strong>具有延迟标记信息</strong>的监督学习问题。</p><h1 id="探索与利用"><a href="#探索与利用" class="headerlink" title="探索与利用"></a>探索与利用</h1><p>强化学习的任务的最终奖赏是多部动作之后才能观察到的，所以对于每次的动作选择，可以分成两种情况：</p><ul><li><strong>探索</strong>（exploration）：若只想获得每个动作的期望奖赏是多少，则采用“仅探索”（exploration-only）策略，即将所有的尝试机会都均匀的分到每个可以执行的动作中去，从而根据最后每个动作多次尝试得到的奖赏来计算每个动作的期望奖赏。“探索”可以很好地估计每个动作的奖赏期望，但是却失去了很多选择最优动作的机会。</li><li><strong>利用</strong>（exploitation）：若只想通过执行动作得到最大的奖赏，则采用“仅利用”（exploitation-only）策略，即根据到目前为止已知的经验中得到平均奖赏最大的动作（若有多个这样的动作就随机选取一个），将所有的机会都用在这个动作上从而得到奖赏。“利用”没有很好地估计各个动作所带来的奖赏，执着于重复<strong>已知的</strong>奖赏最大的动作，从而可能经常选不到最优的动作。</li></ul><p>事实上,“探索”和“利用”两者是矛盾的，因为尝试次数有限，加强了一方则会自然削弱另一方，这就是强化学习所面临的<strong>探索-利用窘境</strong>（Exploration-Exploitation dilemma），所以必须在探索与利用之间达成较好的折中。</p><h1 id="ϵ-贪心算法"><a href="#ϵ-贪心算法" class="headerlink" title="ϵ-贪心算法"></a>ϵ-贪心算法</h1><p>ϵ-贪心算法基于一个概率来对探索和利用进行折中：每次尝试时以ϵ的概率进行探索，以1-ϵ的概率进行利用。</p><p>令Q(k)表示n次动作所得到的平均奖赏，每次得到的奖赏为v1, v2, v2, …, vn，则平均奖赏为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/RL/1/3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>使用<strong>增量式计算</strong>平均奖赏的方式即每次通过单次奖赏与前边所有次的平均奖赏来计算本次动作后的平均奖赏：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/RL/1/4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在增量计算下，每次动作仅需记录两个值：已尝试次数n-1和最近平均奖赏Qn-1即可。</p><p>ϵ-贪心算法描述如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/RL/1/5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>若每个动作奖赏的不确定性较大，如概率分布较宽时，则需更多的探索，此时需要较大的ϵ值</li><li>若每个动作奖赏的不确定性较小，如概率分布较集中时，则少量的尝试就能很好地近似真实奖赏，此时需要的ϵ较小</li><li>通常令ϵ取一个较小的常数，如0.1或0.01</li><li>若尝试次数非常大，则在一段时间后，奖赏都能很好地近似出来，不再需要探索，这种情形下可让ϵ随着尝试次数的增加而逐渐减小，例如 ϵ=1∕√t</li></ul><h1 id="Softmax算法"><a href="#Softmax算法" class="headerlink" title="Softmax算法"></a>Softmax算法</h1><p>Softmax算法基于当前已知的动作的平均奖赏来对探索和利用进行折中。若个动作的平均奖赏相当，则选取各摇臂的概率也相当；若某些动作的平均奖赏明显高于其他动作，则它们被选取的概率也明显更高。</p><p>Softmax算法中动作概率的分配是基于Boltzmann分布：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/RL/1/6.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>其中，Q(i)记录当前动作完成后的平均奖赏，τ&gt;0称为“温度”，τ越小则平均奖赏高的动作被选取的概率越高，τ趋近于0时Softmax算法趋于仅利用，τ趋于无穷大时Softmax算法趋于仅探索，算法描述如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/RL/1/7.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>以上两种算法的好坏很难对比，也和其所取的参数有关，比如下图是一个在 2-摇臂赌博机上的性能比较：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/RL/1/8.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><blockquote><p>全文参考：周志华 著 《机器学习》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;强化学习&lt;/strong&gt;（reinforcement learning，RL）是机器学习的一个领域，主要通过在&lt;strong&gt;环境&lt;/strong&gt;（environment）中采取&lt;strong&gt;动作&lt;/strong&gt;（action），来最大化某些指标，例
      
    
    </summary>
    
    
      <category term="强化学习" scheme="https://blogs.littlegenius.xin/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习笔记" scheme="https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="强化学习" scheme="https://blogs.littlegenius.xin/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="机器学习" scheme="https://blogs.littlegenius.xin/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>【机器学习】（六）支持向量机</title>
    <link href="https://blogs.littlegenius.xin/2020/01/04/%E3%80%90ML%E3%80%916%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
    <id>https://blogs.littlegenius.xin/2020/01/04/%E3%80%90ML%E3%80%916%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</id>
    <published>2020-01-04T08:02:04.000Z</published>
    <updated>2020-01-04T08:12:13.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="支持向量机基本模型"><a href="#支持向量机基本模型" class="headerlink" title="支持向量机基本模型"></a>支持向量机基本模型</h1><p>支持向量机的基本思想是，在如下的样本集中：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-6-1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>基于训练集D在样本空间中找到一个划分超平面，将不同类别的样本分开</p><p>划分超平面可以表示成如下的线性方程：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-6-2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>其中w为法向量，b为位移项，空间内任意一点到以上超平面的距离为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-6-3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>则有</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-6-4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>距离超平面最近的几个训练样本点使得上式的等号成立，它们被称为<strong>支持向量</strong>（support vector），两个异类支持向量到超平面的距离之和为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-6-5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>称之为<strong>间隔</strong>（margin）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-6-6.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>支持向量机的目的即找到<strong>最大间隔</strong>（maximum margin）的划分超平面，即解如下的不等式约束的凸优化问题：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-6-7.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>等价于：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-6-8.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上述模型即<strong>支持向量机</strong>（Support Vector Machine，SVM）的基本模型</p><h1 id="SMO算法"><a href="#SMO算法" class="headerlink" title="SMO算法"></a>SMO算法</h1><h2 id="对偶问题求解"><a href="#对偶问题求解" class="headerlink" title="对偶问题求解"></a>对偶问题求解</h2><p>支持向量机的基本模型是一个<strong>凸二次规划</strong>（convex quadratic programming）问题，可以使用拉格朗日乘子得到其<strong>对偶问题</strong>（dual problem）从而求解</p><p>对于式子：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-6-9.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>对每一条约束增加拉格朗日乘子，得到该问题的拉格朗日函数：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-6-10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>从而得到对偶问题为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-6-11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上述过程的KKT（Karush-Kuhn-Tucker）方程为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-6-12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>可以求解支持向量机的模型</p><p>支持向量机有一个<strong>重要性质</strong>：训练完成后，大部分的训练样本都不需保留，最终模型仅与支持向量有关</p><h2 id="SMO算法-1"><a href="#SMO算法-1" class="headerlink" title="SMO算法"></a>SMO算法</h2><p>为了求解该对偶问题，<strong>SMO</strong>（Sequential Minimal Optimization）算法是一个很高效的算法，其基本思路是，先固定 ai 之外的所有参数，然后求 ai 上的极值。由于存在约束 Σaiyi=0 ，若固定 ai 之外的其他变量，则 ai 可由其他变量导出。于是，SMO每次选择两个变量 ai 和 aj ，并固定其他参数。在参数初始化后，SMO不断执行如下两个步骤直至收敛：</p><ul><li>选取一对需更新的变量 ai 和 aj</li><li>固定 ai 和 aj 以外的参数，求解对偶问题获得更新后的 ai 和 aj </li></ul><p>支持向量机的超平面中的偏移量 b 的求算方式为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-6-13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="软间隔与正则化"><a href="#软间隔与正则化" class="headerlink" title="软间隔与正则化"></a>软间隔与正则化</h1><h2 id="软间隔支持向量机"><a href="#软间隔支持向量机" class="headerlink" title="软间隔支持向量机"></a>软间隔支持向量机</h2><p>并不是每一组训练集在特种空间内都是线性可分的，为了缓解该问题，在有些时候可以允许支持向量机在一些样本上出错，使用<strong>软间隔</strong>（soft margin）的方式：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-6-14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>软间隔指允许某些样本不满足如下的约束条件：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-6-15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>但在最大化间隔的同时也使得不满足约束的样本应该尽可能的少，于是优化目标可以写为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-6-16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>其中，C&gt;0，为常数，C为无穷大时，上式要求所有样本均满足约束条件，C取有限值时，上式允许一些样本不满足约束条件。</p><p>l0/1是“0/1损失函数”：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-6-17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>一些<strong>替代损失</strong>（surrogate loss）如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-6-18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>图像如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-6-19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>引入<strong>松弛变量</strong>（slack variables）可以改写式子成为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-6-20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>解以上的二次规划问题，依然使用对偶函数法，得到其拉格朗日函数为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-6-21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>对偶问题为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-6-22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>KKT方程为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-6-23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="优化目标的一般形式"><a href="#优化目标的一般形式" class="headerlink" title="优化目标的一般形式"></a>优化目标的一般形式</h2><p>优化目标的一般形式为：第一项用来描述划分超平面的间隔大小，另一项用来表述训练集上的误差：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-6-24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>第一项称为<strong>结构风险</strong>（structural risk），用于描述模型的某些性质</li><li>第二项称为<strong>经验风险</strong>（empirical risk），用于描述模型与训练数据的契合程度</li><li>C用于对二者进行折中</li></ul><h1 id="支持向量回归"><a href="#支持向量回归" class="headerlink" title="支持向量回归"></a>支持向量回归</h1><p>考虑回归问题，给定样本</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-6-25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>希望得到一个回归模型：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-6-26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>使得y和f(x)尽可能接近，w和b是待定参数</p><p><strong>支持向量回归</strong>（Support Vector Rrgression，SVR）假设能容忍f(x)和y之间有一个偏差，当f(x)和y之间的差别大于该偏差的时候才计算损失，相当于以f(x)为中心构建了一个宽度为两倍偏差的间隔带，若训练样本落入此间隔带则认为模型预测正确</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-6-27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>SVR问题可以表示为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-6-28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>其中的l为<strong>不敏感损失函数</strong>（insensitive loss function）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-6-29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>引入松弛变量后可以重写为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-6-3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>依然可以使用对偶问题求解</p><blockquote><p>全文参考：周志华 著 《机器学习》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;支持向量机基本模型&quot;&gt;&lt;a href=&quot;#支持向量机基本模型&quot; class=&quot;headerlink&quot; title=&quot;支持向量机基本模型&quot;&gt;&lt;/a&gt;支持向量机基本模型&lt;/h1&gt;&lt;p&gt;支持向量机的基本思想是，在如下的样本集中：&lt;/p&gt;
&lt;figure class=&quot;i
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://blogs.littlegenius.xin/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习笔记" scheme="https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="机器学习" scheme="https://blogs.littlegenius.xin/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>【机器学习】（五）神经网络</title>
    <link href="https://blogs.littlegenius.xin/2020/01/02/%E3%80%90ML%E3%80%915%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>https://blogs.littlegenius.xin/2020/01/02/%E3%80%90ML%E3%80%915%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</id>
    <published>2020-01-02T11:17:32.000Z</published>
    <updated>2020-01-02T12:07:40.162Z</updated>
    
    <content type="html"><![CDATA[<h1 id="神经元模型"><a href="#神经元模型" class="headerlink" title="神经元模型"></a>神经元模型</h1><p><strong>神经网络</strong>（neural networks）定义为：神经网络是由具有适应性的简单单元组成的广泛并行互连的网络，它的组织能够模拟生物神经系统对真实世界物体所作出的交互反应。</p><p>神经网络中最基本的成分是<strong>神经元</strong>（neuron）模型，其中最典型的是“M-P神经元模型”，其由多个输入信号，神经元模型通过将输入信号在加权求和，然后与该神经元阈值比较，通过<strong>激活函数</strong>（activation function）处理后产生结果输出。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-5-1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>理想的激活函数为阶跃函数，但是为避免其不连续不光滑的性质，常用Sigmoid函数代替作为激活函数，由于其将输入值挤压到了(0,1)的输出范围，因此也称<strong>挤压函数</strong>（squashing function）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-5-2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>把许多个这样的神经元按一定的层次结构连接起来,就得到了神经网络 </p><h1 id="感知机与多层网络"><a href="#感知机与多层网络" class="headerlink" title="感知机与多层网络"></a>感知机与多层网络</h1><p><strong>感知机</strong>（Perceptron）由两层神经元组成，输入层接收外界输入信号后传递给输出层，输岀层是M-P神经元，亦称阈值<strong>逻辑单元</strong>（threshold logic unit）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-5-3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>感知机能够很简单的实现逻辑与、或、非运算</li><li>通过训练集可以对感知机进行训练，训练的过程即对阈值参数、权重参数进行调整的过程，其中η称<strong>学习率</strong>（learning rate）</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-5-4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>感知机只拥有单层<strong>功能神经元</strong>（functional neuron），只能解决<strong>线性可分</strong>（linearly separable）问题，感知机在处理线性可分问题的过程中一定会<strong>收敛</strong>（converge），对于非线性可分问题则会发生<strong>振荡</strong>（fluctuation）：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-5-5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>要解决非线性可分问题，需要考虑多层功能神经元，输出层与输入层之间的层神经元，称<strong>隐层</strong>或<strong>隐含层</strong>（hidden layer），隐含层和输出层神经元都是拥有激活函数的功能神经元。比如使用两层功能神经元解决异或问题：</p><h2 id="多层前馈神经网络（multi-layer-feedforward-neural-networks）"><a href="#多层前馈神经网络（multi-layer-feedforward-neural-networks）" class="headerlink" title="多层前馈神经网络（multi-layer feedforward neural networks）"></a>多层前馈神经网络（multi-layer feedforward neural networks）</h2><p><strong>多层前馈神经网络</strong>（multi-layer feedforward neural networks）由输入层、输入层和隐层组成，其中输入层神经元接收外界输入，隐层与输出层神经元对信号进行加工，最终结果由输出层神经元输出。每层神经元与下层神经元全互连，神经元之间不存在同层连接，也不存在跨层连接。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-5-7.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>多层前馈神经网络的训练过程即调整各个神经元结构中的阈值与神经元之间的<strong>连接权</strong>（connection weight）的过程</p><h1 id="误差逆传播算法"><a href="#误差逆传播算法" class="headerlink" title="误差逆传播算法"></a>误差逆传播算法</h1><p><strong>误差逆传播</strong>（error BackPropagation，BP）算法是一种多层网络的训练过程的调整参数的算法，一般的神经网络大多是使用BP算法训练的，因此也称BP网络</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-5-8.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上图中的网络有(d+l+1)q+l个参数需确定：输入层到隐层的d×q个权值、隐层到输出层的q×l个权值、q个隐层神经元的阈值、l个输出层神经元的阈值。</p><h2 id="标准BP算法"><a href="#标准BP算法" class="headerlink" title="标准BP算法"></a>标准BP算法</h2><p>标准BP算法每次仅针对一个训练样例更新连接权和阈值，其更新规则是基于单个的均方误差推导而得。</p><p>对于训练样例(xk,yk)，设神经网络的输出为</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-5-9.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>则该网络在样例(xk,yk)上的均方误差为</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-5-10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>BP是一个迭代学习算法，在迭代的每一轮中采用广义的感知机学习规则对参数进行更新估计，任意参数v的更新估计式为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-5-11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="链式求导法则"><a href="#链式求导法则" class="headerlink" title="链式求导法则"></a>链式求导法则</h2><p>BP算法基于<strong>梯度下降</strong>（gradient descent）策略，以目标的负梯度方向对参数进行调整。因此对于任意参数v，均方误差Ek均可以对其求偏导从而得到梯度，当v与输出层有多个层次间隔时，需要使用链式求导法则求得梯度。</p><h2 id="积累误差逆传播算法"><a href="#积累误差逆传播算法" class="headerlink" title="积累误差逆传播算法"></a>积累误差逆传播算法</h2><p>累积误差逆传播（accumulated error backpropagation）算法是基于累积误差最小化的更新规则。</p><ul><li>标准BP算法每次更新只针对单个样例，参数更新得非常频繁，对不同样例进行更新的效果可能出现“抵消”现象。为了达到同样的累积误差极小点，标准BP算法往往需进行更多次数的迭代。</li><li>累积BP算法直接针对累积误差最小化，在读取整个训练集D一遍后才对参数进行更新，其参数更新的频率低得多。</li><li>在很多任务中，累积误差下降到一定程度之后，进步下降会非常缓慢，标准BP往往会更快获得较好的解，尤其是在训练集D非常大时更明显。 </li></ul><h2 id="BP神经网络的过拟合问题"><a href="#BP神经网络的过拟合问题" class="headerlink" title="BP神经网络的过拟合问题"></a>BP神经网络的过拟合问题</h2><p>可以使用两种策略缓解BP网络的过拟合问题：</p><ul><li>早停（early stopping）：将数据分成训练集和验证集，训练集用来计算梯度、更新连接权和阙值，验证集用来估计误差，若训练集误差降低但验证集误差升高，则停止训练，同时返回具有最小验证集误差的连接权和阈值</li><li>正则化（regularization）：在误差目标函数中增加一个用于描述网络复杂度的部分</li></ul><h1 id="局部极小与全局最小"><a href="#局部极小与全局最小" class="headerlink" title="局部极小与全局最小"></a>局部极小与全局最小</h1><p>当在寻找函数的全局最小值时，由于算法问题被困在了局部极小值处，无法跳出局部极小的情况称为“参数寻优陷入了局部极小”，为了跳出局部极小，可以有以下一些解决方案：</p><ul><li>以多组不同参数值初始化多个神经网络，按标准方法训练后，取其中误差最小的解作为最终参数。</li><li>使用模拟退火（simulated annealing）技术，模拟退火在每一步都以一定的概率接受比当前解更差的结果，从而有助于跳出局部极小。</li><li>使用随机梯度下降。随机梯度下降法在计算梯度时加入了随机因素。即便陷入局部极小点，计算出的梯度仍可能不为零，有机会跳出局部极小继续搜索。</li></ul><blockquote><p>全文参考：周志华 著 《机器学习》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;神经元模型&quot;&gt;&lt;a href=&quot;#神经元模型&quot; class=&quot;headerlink&quot; title=&quot;神经元模型&quot;&gt;&lt;/a&gt;神经元模型&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;神经网络&lt;/strong&gt;（neural networks）定义为：神经网络是由具有适应性的简单单元
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://blogs.littlegenius.xin/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习笔记" scheme="https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="机器学习" scheme="https://blogs.littlegenius.xin/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>【机器学习】（四）决策树</title>
    <link href="https://blogs.littlegenius.xin/2019/12/30/%E3%80%90ML%E3%80%914%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <id>https://blogs.littlegenius.xin/2019/12/30/%E3%80%90ML%E3%80%914%E5%86%B3%E7%AD%96%E6%A0%91/</id>
    <published>2019-12-30T13:36:20.000Z</published>
    <updated>2019-12-30T13:43:54.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h1><p><strong>决策树</strong>（decision tree）是基于树结构进行决策的，是一种符合人类面临决策问题时的思考方式。采用了<strong>分而治之</strong>（divide-and-conquer）的策略。</p><p>决策树建立的基本流程</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-4-1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>决策树的构建是一个递归的 过程，决策树生成算法中有三种情形会导致递归：</p><ul><li>当前结点包含的样本全属于同一类别，无需划分</li><li>当前属性集为空，或是所有样本在所有属性上取值相同，无法划分</li><li>当前结点包含的样本集合为空，不能划分</li></ul><h1 id="划分选择"><a href="#划分选择" class="headerlink" title="划分选择"></a>划分选择</h1><p>一般而言，随着划分过程不断进行，希望决策树的分支结点所包含的样本尽可能属于同一类别，即结点的“纯度”（purity）越来越高。有一些用来衡量和选择划分方式的基准与方法。 </p><h2 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h2><p><strong>信息熵</strong>（information entropy）是度量样本集合纯度最常用的一种指标。</p><p>假定当前样本集合D中第k类样本所占的比例为pk(k=1,2,…, |y|)，则D的信息熵定义为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-4-2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Ent(D)的值越小，D的纯度越高</p><p>假设离散属性a有V个可能的取值{a1, a2, a3, …, aV}，若使用a来对样本集D进行划分，则会产生V个分支节点。可以计算用属性a对样本集D进行划分所获得的<strong>信息增益</strong>（information gain）为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-4-3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>一般而言，信息增益越大，则意味着使用属性a来进行划分所获得的纯度提升越大，因此，如果选择信息增益进行决策树划分属性的选择，则选择属性满足：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-4-4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>信息增益准则对可取值数目较多的属性有所偏好</strong></p><h2 id="增益率"><a href="#增益率" class="headerlink" title="增益率"></a>增益率</h2><p>为了减少信息增益准则对可取值数目较多的属性有所偏好而带来的不利影响，可以使用<strong>增益率</strong>（gain ratio）来选择最优化分属性。增益率定义为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-4-5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>其中</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-4-6.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>成为属性a的<strong>固有值</strong>（intrinsic value）。属性a的可能取值数目越多，IV(a)的值通常也会越大。</p><p>基于增益率的属性划分采用一个启发式判定：<strong>先从候选划分属性中找出信息增益高于平均水平的属性，再从中选择增益率最高的属性</strong></p><p><strong>信息增益率准则对可取值数目较少的属性有所偏好</strong></p><h2 id="基尼指数"><a href="#基尼指数" class="headerlink" title="基尼指数"></a>基尼指数</h2><p><strong>CART**</strong>决策树<strong>（Classfication and Regression Tree）使用</strong>基尼指数<strong>（Gini index）选择划分属性。数据集D的纯度可以使用</strong>基尼值**来衡量：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-4-7.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Gini(D)反映了从数据集D中随机抽取两个样本，其类别标记不一致的概率，因此Gini(D)越小，数据集D的纯度越高。 </p><p>属性a的基尼指数定义：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-4-8.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>属性划分时选择：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-4-9.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="剪枝处理"><a href="#剪枝处理" class="headerlink" title="剪枝处理"></a>剪枝处理</h1><p><strong>剪枝</strong>（pruning）是决策树学习算法对付“过拟合”的主要手段。</p><ul><li><strong>预剪枝</strong>（prepruning）：在决策树生成过程中，对每个结点在划分前先进行估计，若当前结点的划分不能带来决策树泛化性能提升，则停止划分并将当前结点标记为叶结点。</li><li><strong>后剪枝</strong>（postpruning）：先从训练集生成一棵完整的决策树，然后自底向上地对非叶结点进行考察，若将该结点对应的子树替换为叶结点能带来决策树泛化性能提升，则将该子树替换为叶结点。</li></ul><p>两种剪枝处理的优缺点比较：</p><ul><li>预剪枝显著减少了决策树的训练时间开销和测试时间开销；后剪枝的训练时间开销比未剪枝和预剪枝都大得多</li><li>预剪枝基于贪心算法本质禁止一些分支展开，给预剪枝决策树带来了欠拟合的风险；后剪枝决策树通常比预剪枝决策树保留了更多的分支，且其欠拟合风险很小，泛化性能往往优于预剪枝</li></ul><h1 id="连续与缺失值"><a href="#连续与缺失值" class="headerlink" title="连续与缺失值"></a>连续与缺失值</h1><h2 id="连续值处理"><a href="#连续值处理" class="headerlink" title="连续值处理"></a>连续值处理</h2><p>由于连续属性的可取值数目不在有限，所以需要进行<strong>连续属性的离散化技术</strong>。</p><p>连续值处理的最常用方式：<strong>二分法</strong>（bi-partition）</p><p>将连续属性值使用一个划分点t进行划分，划分成Dt+和Dt-两个子集，对于相邻的两个属性值ai和ai+1，t可以去其中间值，对于连续属性a，可以考察包含n-1个元素的候选划分点集合：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-4-10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>然后像离散属性值一样考察这些划分点，选取最优的划分点进行样本集合的划分，例如Gain公式可以修改成：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-4-11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>计算后选择使得Gain(D, a, t)最大化的划分点 </p><h2 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h2><p>当样本数据中有些样本在某些属性下出现数据缺失的情况是，需要有两个问题进行解决：</p><ul><li>如何在属性值缺失的情况下进行划分属性选择？</li><li>给定划分属性，若样本在该属性上的值缺失，如何对样本进行划分？</li></ul><p>给定训练集D和属性a，令D’a表示D中在属性a上没有缺失值的样本子集。对于问题第一点，仅可根据D’a来判断属性a的优劣。</p><p>假定我们为每个样本x赋予一个权重wx，并定义：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-4-12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>从而可以将信息增益推广为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-4-13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>其中</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-4-14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>对于问题的第二点，若样本x在划分属性a上的取值已知，则将x划入与其取值对应的子结点，且样本权值在子结点中保持为wx，若样本x在划分属性a上的取值未知，则将x同时划入所有子结点，且样本权值在与属性值av对应的子结点中调整为 rv×wx，即让同一个样本以不同的概率划入到不同的子结点中去。</p><h1 id="多变量决策树"><a href="#多变量决策树" class="headerlink" title="多变量决策树"></a>多变量决策树</h1><p>当把每个属性视为坐标空间中的一个坐标轴，则d个属性描述的样本就对应了d维空间中的一个数据点，对样本分类则意味着在这个坐标空间中寻找不同类样本之间的分类边界。决策树所形成的分类边界有一个明显的特点：轴平行（axis-parallel），即它的分类边界由若干个与坐标轴平行的分段组成：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-4-15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>若使用斜线划分边界，则可以视为<strong>多变量决策树</strong>（multivariate decision tree），实现“斜划分”甚至更复杂的划分，即每个非叶节点变为属性的线性组合，形如</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-4-17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>的一个线性分类器，学习的过程也是确定wi的过程</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-4-16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><blockquote><p>全文参考：周志华 著 《机器学习》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本流程&quot;&gt;&lt;a href=&quot;#基本流程&quot; class=&quot;headerlink&quot; title=&quot;基本流程&quot;&gt;&lt;/a&gt;基本流程&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;决策树&lt;/strong&gt;（decision tree）是基于树结构进行决策的，是一种符合人类面临决策问题时的
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://blogs.littlegenius.xin/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习笔记" scheme="https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="机器学习" scheme="https://blogs.littlegenius.xin/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>【机器学习】（三）线性模型</title>
    <link href="https://blogs.littlegenius.xin/2019/12/26/%E3%80%90ML%E3%80%913%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"/>
    <id>https://blogs.littlegenius.xin/2019/12/26/%E3%80%90ML%E3%80%913%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/</id>
    <published>2019-12-26T12:09:17.000Z</published>
    <updated>2019-12-26T12:28:39.966Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式"></a>基本形式</h1><p>给定由d个属性描述的示例x=(x1; x2; …; xd)，其中xi是x在第i个属性上的取值，<strong>线性模型</strong>（linear model）试图学得一个通过属性的线性组合来进行预测的函数，即</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-3-1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>写成向量形式即</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-3-2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>确定w与b后模型即随之确定</li><li><strong>非线性模型</strong>（nonlinear model）可在线性模型基础上通过引入层级结构或高维映射得到</li><li>线性模型具有很好的<strong>解释性</strong>（comprehensibility）</li></ul><h1 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h1><p>线性回归（linear regression）目的即确定一个w和b，是的f(x)与y的均方误差最小化。</p><ul><li>均方误差对应欧几里得距离即欧氏距离（Euclidean distance）</li><li>基于均方误差最小化进行模型求解的方法称最小二乘法（least square method）</li><li>最小二乘法即试图找到一条直线，使所有样本到直线上的欧氏距离之和最小</li></ul><p>w和b最优解的闭式（closed-form）解为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-3-3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="多元线性回归"><a href="#多元线性回归" class="headerlink" title="多元线性回归"></a>多元线性回归</h2><p>更一般的情形是对于d个属性描述的变量，进行多元线性回归（multivariate linear regression）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-3-4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>为便于讨论，令w’=(w;b)，数据集D表示为一个m×(d+1)大小的矩阵X，器每一行对应一个示例，每行前d个元素对应于示例的d个属性值，最后一个元素恒置为1，即</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-3-5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>标记向量为y，则有</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-3-6.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>令</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-3-7.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>并将其对w’求导得到：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-3-8.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>令其为0可以得到w’的最优解的闭式解</p><ul><li>若XTX为满秩矩阵（full-rank matrix）或正定矩阵（positive definite     matrix）时，则求得<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-3-9.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>线性回归模型为<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-3-10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li>若XTX不是满秩矩阵（往往不是），则会得到多个可行解，由归纳偏好选择哪一组解为输出，常见的做法为引入正则化（regularization）项</li></ul><h2 id="广义线性模型"><a href="#广义线性模型" class="headerlink" title="广义线性模型"></a>广义线性模型</h2><p>广义线性模型（generalized linear model）即当f与x不是标准的线性关系时，可以选取一个恰当的单调可微函数g，令</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-3-11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>得到广义线性模型，g称为联系函数（link function）</p><p>例如当g(·)=ln(·)时可以得到对数线性回归（log-linear regression）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-3-12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="对数几率回归"><a href="#对数几率回归" class="headerlink" title="对数几率回归"></a>对数几率回归</h1><p>对于二分类任务，可以通过将输出标记y归到0或1，从而使用线性回归的方法，即将预测值转换成0/1值，可以使用单位阶跃函数（unit-step function）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-3-13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>但是由于其不连续，可以使用单位阶跃函数的替代函数（surrogate function）并希望其单调可微，从而可以选取对数几率函数（logistic function），一种Sigmoid函数（即形似S的函数）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-3-14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-3-15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>它可以将z值转换成一个0/1值，从而</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-3-16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>将y视为样本x作为正例的可能性，则1-y是其反例可能性，两者的比值成为几率（odds），反映了x作为正例的相对可能性，对其取对数即对数几率（log odds，或logit）</p><h2 id="确定w与b"><a href="#确定w与b" class="headerlink" title="确定w与b"></a>确定w与b</h2><p>通过<strong>极大似然法</strong>（maximum likelihood method）估计w和b，给定数据集(xi,yi)，对率回归模型最大化对数似然（log-likelihood）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-3-17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上式最大化等价于最小化下式</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-3-18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>该式是关于β的高阶可导连续凸函数，根据<strong>凸优化理论</strong>可以使用梯度下降法、牛顿法等求其最优解得到：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-3-19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="线性判别分析"><a href="#线性判别分析" class="headerlink" title="线性判别分析"></a>线性判别分析</h1><p>线性判别分析（Linear Discriminant Analysis，LDA）是一种经典的线性学习方法，适用于二分类问题。</p><p>LDA的<strong>思想</strong>为：给定训练样例集，设法将样例投影到一条直线上，使得同类样例的投影点尽可能接近、异类样例的投影点尽可能远离；在对新样本进行分类时，将其投影到同样的这条直线上，再根据投影点的位置来确定新样本的类别。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-3-20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>类内散度矩阵（within-class scatter matrix）用于表示每一个类内的分散程度，希望其越小越好<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-3-21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li>类间三度矩阵（between-class scatter     matrix）用于表示类与类之间的分散程度，希望其越大越好<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-3-22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul><p>LDA欲最大化的目标即Sb和Sw的广义瑞利商（generalized Rayleigh quotient）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-3-23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>求算方式：由于不失一般性（J式中分子和分母都是关于w的二次项，因此J的解与w的长度无关，只与其方向有关），可以设分母为1，等价于等式条件约束下的凸优化问题：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-3-24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>使用拉格朗日乘子可以求解其对偶问题，从而求解该优化问题，考虑到数值解的稳定性，一般会将Sw进行奇异值分解</p><ul><li>LDA可从贝叶斯决策理论的角度来阐释，并可证明，当两类数据同先验、满足高斯分布且协方差相等时，LDA可达到最优分类</li><li>LDA可以推广到多分类任务中，需要定义全局散度矩阵</li><li>LDA也常被视为一种经典的监督降维技术</li></ul><h1 id="多分类学习"><a href="#多分类学习" class="headerlink" title="多分类学习"></a>多分类学习</h1><p>多分类学习的基本思路是拆解法，即将多分类任务拆为若干个二分类任务求解。先对问题进行拆分，然后为拆出的每个二分类任务训练一个分类器；在测试时，对这些分类器的预测结果进行集成以获得最终的多分类结果。</p><p>经典的拆分策略有</p><ul><li>一对一（One vs. One，OvO)</li><li>一对其余（One vs. Rest，OvR)</li><li>多对多（Many vs. Many，MvM）</li></ul><h2 id="一对一-与-一对其余"><a href="#一对一-与-一对其余" class="headerlink" title="一对一 与 一对其余"></a>一对一 与 一对其余</h2><p>假设有N个类别。</p><ul><li>OvO将这N个类别两两配对，从而产生N(N-1)/2个二分类任务。在测试阶段，新样本将同时提交给所有分类器，于是将得到N(N-1)/2个分类结果，最终结果可通过投票产生：即把被预测得最多的类别作为最终分类结果。</li><li>OvR每次将一个类的样例作为正例、所有其他类的样例作为反例来训练N个分类器。在测试时若仅有一个分类器预测为正类，则对应的类别标记作为最终分类结果。若有多个分类器预测为正类，则通常考虑各分类器的预测置信度,选择置信度最大的类别标记作为分类结果。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-3-25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>OvR只需训练N个分类器，而OvO需训练N(N-1)/2个分类器。因此，OvO的存储开销和测试时间开销通常比OvR更大</li><li>在训练时，OvR的每个分类器均使用全部训练样例，而OvO的每个分类器仅用到两个类的样例，因此，在类别很多时，OvO的训练时间开销通常比OvR更小</li></ul><h2 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h2><p>MvM是每次将若干个类作为正类，若干个其他类作为反类（OvO和OvR是MvM的特例）。MvM的正、反类构造可以使用最常用的纠错输出码（Error Correcting Output Codes，ECOC)技术。</p><p>ECOC是将编码的思想引入类别拆分，并尽可能在解码过程中具有容错性。ECOC工作过程主要分为两步</p><ul><li>编码：对N个类别做M次划分，每次划分将一部分类别划为正类，一部分划为反类，从而形成一个二分类训练集；这样一共产生M个训练集，可训练出M个分类器</li><li>解码：M个分类器分别对测试样本进行预测，这些预测标记组成一个编码。将这个预测编码与每个类别各自的编码进行比较，返回其中距离最小的类别作为最终预测结果</li></ul><h3 id="常用的编码方式"><a href="#常用的编码方式" class="headerlink" title="常用的编码方式"></a>常用的编码方式</h3><ul><li>二元码，每个类别分别指定为正类和反类</li><li>三元码，每个类别可以指定为正类、反类或者停用类 </li></ul><p><img src="http://cdn.littlegenius.xin/ML-3-26.png" alt=""></p><p>纠错输出码具有一定的容错能力</p><h1 id="类别不平衡问题"><a href="#类别不平衡问题" class="headerlink" title="类别不平衡问题"></a>类别不平衡问题</h1><p>类别不平衡（class-imbalance）指分类任务中不同类别的训练样例数目差别很大的情况。一般的应对方式是再缩放（rescaling）</p><ul><li>直接对训练集里的多的一类样例进行欠采样（undersampling），即去除一些多的一类样例，使得正、反例数目接近，然后再进行学习</li><li>直接对训练集里的少的一类样例进行过采样（oversampling），即增加一些少的一类样例，使得正、反例数目接近，然后再进行学习</li><li>直接基于原始训练集进行学习，但在用训练好的分类器进行预测时，将样例数量比例嵌入决策过程，称为阙值移动（threshold-moving）<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-3-27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul><p><strong>注意！</strong></p><ul><li>欠采样法的时间开销通常远小于过采样法，因为前者丢弃了很多样例，使得分类器训练集远小于初始训练集，而过采样法增加了很多样例，其训练集大于初始训练集</li><li>过采样法不能简单地对初始样例进行重复采样，否则会招致严重的过拟合；过采样法的代表性算法SMOTE是通过对训练集里的一类样例进行插值来产生额外的样例</li><li>欠采样法若随机丢弃样例，可能丢失一些重要信息；欠采样法的代表性算法Easy Ensemble则是利用集成学习机制，将少的一类样例划分为若干个集合供不同学习器使用，这样对每个学习器来看都进行了欠采样，但在全局来看却不会丢失重要信息</li></ul><blockquote><p>全文参考：周志华 著 《机器学习》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本形式&quot;&gt;&lt;a href=&quot;#基本形式&quot; class=&quot;headerlink&quot; title=&quot;基本形式&quot;&gt;&lt;/a&gt;基本形式&lt;/h1&gt;&lt;p&gt;给定由d个属性描述的示例x=(x1; x2; …; xd)，其中xi是x在第i个属性上的取值，&lt;strong&gt;线性模型&lt;/s
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://blogs.littlegenius.xin/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习笔记" scheme="https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="机器学习" scheme="https://blogs.littlegenius.xin/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>【机器学习】（二）模型估计与选择</title>
    <link href="https://blogs.littlegenius.xin/2019/12/25/%E3%80%90ML%E3%80%912%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/"/>
    <id>https://blogs.littlegenius.xin/2019/12/25/%E3%80%90ML%E3%80%912%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/</id>
    <published>2019-12-25T13:35:26.000Z</published>
    <updated>2019-12-25T14:18:30.799Z</updated>
    
    <content type="html"><![CDATA[<h1 id="误差与过拟合"><a href="#误差与过拟合" class="headerlink" title="误差与过拟合"></a>误差与过拟合</h1><h2 id="误差"><a href="#误差" class="headerlink" title="误差"></a>误差</h2><p>假设m个样本中有a个样本分类错误</p><ul><li>错误率（error rate）：分类错误的样本数占样本总数的比例，E=a/m</li><li>精度（accuracy）：分类正确的样本数占样本总数的比例，1-a/m</li><li>精度=1-错误率</li><li>误差（error）：学习器的实际预测输出与样本的真实输出之间的差异</li><li>学习器在训练集上的误差称为<strong>训练误差</strong>（training error）/<strong>经验误差</strong>（empirical error）</li><li>学习器在新样本上的误差称为<strong>泛化误差</strong>（generalization error）</li><li>机器学习的目标是得到泛化误差小的学习器，但是实际能做的是努力使经验误差最小化</li></ul><h2 id="过拟合与欠拟合"><a href="#过拟合与欠拟合" class="headerlink" title="过拟合与欠拟合"></a>过拟合与欠拟合</h2><p>当学习器把训练样本学得太好的时候，很可能已经把训练样本自身的一些特点当作了所有潜在样本都会具有的一般性质，这样就会导致泛化性能下降。这种现象在机器学习中称为<strong>过拟合</strong>（overfitting）。与过拟合相对的是<strong>欠拟合</strong>（underfitting），这是指对训练样本的一般性质尚未学好。</p><ul><li>过拟合是机器学习中的<strong>关键障碍</strong></li></ul><h1 id="评估方法"><a href="#评估方法" class="headerlink" title="评估方法"></a>评估方法</h1><p>通常，通过实验测试来对学习器的泛化误差进行评估。为此，需使用一个<strong>测试集</strong>（testing set）来测试学习器对新样本的判别能力，然后以测试集上的<strong>测试误差</strong>（testing error）作为泛化误差的近似。</p><ul><li>通常我们假设测试样本也是从样本真实分布中独立同分布采样而得</li><li>测试集应该尽可能与训练集互斥</li><li>验证集（validation set）指用于评估模型的不包含在训练样本与测试样本的其他真实数据</li></ul><p>评估方法即通过适当的处理，从包含m个样例的数据集D中产生出训练集S和测试集T</p><h2 id="留出法（hold-out）"><a href="#留出法（hold-out）" class="headerlink" title="留出法（hold-out）"></a>留出法（hold-out）</h2><p>留出法（hold-out）直接将数据集D划分为两个<strong>互斥</strong>的集合，其中一个集合作为训练集S，另一个作为测试集T，即 D=SUT，S∩T=。在S上训练出模型后，用T来评估其测试误差，作为对泛化误差的估计。</p><ul><li>划分过程中需要采取均匀的分层取样（stratified sampling）</li><li>一般单次留出法往往不可靠，需要反复多次进行留出法产生不同的训练集与测试集，对评估结果取均值</li><li>常见的分法是训练集占总数据集的2/3~4/5</li></ul><h2 id="交叉验证法（cross-validation）"><a href="#交叉验证法（cross-validation）" class="headerlink" title="交叉验证法（cross validation）"></a>交叉验证法（cross validation）</h2><p>交叉验证法（cross validation）先将数据集D划分为k个大小相似的互斥子集，即 D=D1 U D2 U … U Dn，Di ∩ Dj =  (i≠j)。每个子集都尽可能保持数据分布的一致性，即通过分层采样得到。每次用 k-1 个子集的并集作为训练集，余下的那个子集作为测试集。这样就可获得 k 组训练测试集，从而可进行 k 次训练和测试，最终返回的是这 k 个测试结果的均值。</p><ul><li>通常把交叉验证法称为<strong>k**</strong>折交叉验证**（k-fold cross validation）。k最常用的取值是10，此时称为10折交叉验证</li><li>k折交叉验证通常也要随机使用不同的划分重复p次，最终会得到p×k次结果并取均值</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-2-1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="留一法（Leave-One-Out，LOO）"><a href="#留一法（Leave-One-Out，LOO）" class="headerlink" title="留一法（Leave-One-Out，LOO）"></a>留一法（Leave-One-Out，LOO）</h3><p>假定数据集D中包含m个样本，当k=m，则得到了交叉验证法的一个特例：留一法（Leave-One-Out，LOO）</p><ul><li>在绝大多数情况下，留一法中被实际评估的模型与期望评估的用D训练出的模型很相似。因此，留一法的评估结果往往被认为<strong>比较准确</strong></li><li>缺点：在数据集比较大时运算量无法接受</li></ul><h2 id="自助法（bootstrapping）"><a href="#自助法（bootstrapping）" class="headerlink" title="自助法（bootstrapping）"></a>自助法（bootstrapping）</h2><p>自助法（bootstrapping）直接以自助采样法（bootstrap sampling）为基础。</p><p>给定包含m个样本的数据集D，我们对它进行采样产生数据集D’。每次随机从D中挑选一个样本，将其拷贝放入D′，然后再将该样本放回初始数据集D中，使得该样本在下次采样时仍有可能被到。这个过程重复执行m次后，我们就得到了包含m个样本的数据集D’，即自助采样的结果。</p><p>D中有一部分样本会在D’中多次出现，而另一部分样本不出现。可以做一个简单的估计，样本在m次采样中始终不被采到的概率是(1-1/m)^m，取极限得到</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-2-2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>即通过自助采样，初始数据集D中约有36.8%的样本未出现在采样数据集D中。于是可将D’用作训练集，D\D’用作测试集。这样，实际评估的模型与期望评估的模型都使用m个训练样本，而我们仍有数据总量约1/3的、没在训练集中出现的样本用于测试这样的测试结果，亦称包外估计（out-of-bag-estimate） </p><ul><li>自助法在数据集较小、难以有效划分训练/测试集时很有用</li><li>在初始数据量足够时，留出法和交叉验证法更常用一些</li></ul><h2 id="调参（parameter-tuning）"><a href="#调参（parameter-tuning）" class="headerlink" title="调参（parameter tuning）"></a>调参（parameter tuning）</h2><ul><li>在进行模型评估与选择时，除了要对适用学习算法进行选择，还需对算法参数进行设定，这就是通常所说的<strong>参数调节/调参</strong>（parameter tuning）</li><li>实际操作中一般会对每个参数选定一个范围或者步长</li><li>在研究对比不同算法的泛化性能时，用测试集上的判别效果来估计模型在实际使用时的泛化能力，而把训练数据另外划分为训练集和验证集，基于验证集上的性能来进行模型选择和调参</li></ul><h1 id="性能度量"><a href="#性能度量" class="headerlink" title="性能度量"></a>性能度量</h1><p>性能度量（performance measure）即模型泛化能力的评价标准</p><p>给定样例集 D={(x1,y1), (x2,y2), …, (xm,ym)}，其中的 yi 是 xi 的真实标记，评估学习器 f 的性能，即比较 f(xi) 与 yi</p><h2 id="均方误差"><a href="#均方误差" class="headerlink" title="均方误差"></a>均方误差</h2><p>均方误差（mean squared error）：回归任务最常用</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-2-3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>对于数据分布D和概率密度函数p(·)，均方误差为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-2-4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="错误率与精度"><a href="#错误率与精度" class="headerlink" title="错误率与精度"></a>错误率与精度</h2><p>错误率与精度适用于分类任务</p><ul><li>错误率（error rate）<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-2-5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>对于数据分布D和概率密度函数p(·)，误差为：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-2-6.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li>精度（accuracy）<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-2-7.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>对于数据分布D和概率密度函数p(·)，精度为：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-2-8.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul><h2 id="查准率、查全率与F1"><a href="#查准率、查全率与F1" class="headerlink" title="查准率、查全率与F1"></a>查准率、查全率与F1</h2><p>查准率（precision）又称精确度，二分类（0，1分类）中，代表预测为1的所有结果中，预测正确的比例。</p><p>查全率（recall）又称召回率，二分类（0，1分类）中，代表真实情况为1的所有样本中，预测结果同样为1的比例</p><p>对于二分类问题，可以将真实情况与预测情况组合为如下四种：真正例（true positive）、假正例（false positive）、真反例（true negative）、假反例（false negative）四种情形，令TP、FP、TN、FN分别表示其对应的样例数，则显然有TP+FP+TN+FN=样例总数。分类结果的<strong>混淆矩阵</strong>（confusion matrix）如下</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-2-9.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>查准率P与查全率R分别定义为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-2-10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>查准率和查全率是一对矛盾的度量。一般来说，查准率高时，查全率往往偏低；查全率高时，查准率往往偏低。</p><h3 id="PR曲线与PR图"><a href="#PR曲线与PR图" class="headerlink" title="PR曲线与PR图"></a>PR曲线与PR图</h3><p>在很多情形下，可根据学习器的预测结果对样例进行排序，排在前面的是学习器认为最可能是正例的样本，排在最后的则是学习器认为最不可能是正例的样本。（或者理解为，对分类结果是否更加被认为是正例给定一个概率，0-1，按照该概率从高到低排序，确定一个阈值（threshold）来控制正例与反例的划分）。按此顺序逐个把样本作为正例进行预测，则每次可以计算出当前的查全率、查准率。以查准率为纵轴、查全率为横轴作图，就得到了<strong>査准率-查全率曲线</strong>，简称<strong>PR曲线</strong>，该曲线的图称为<strong>PR图</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-2-11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>如果有曲线完全包住了另一条曲线，如A包住了C，则A比C优秀</li><li>如果两条曲线有交叉，如A和B<ul><li>比较各自曲线下的包裹面积，面积大的优于面积小的</li><li>使用平衡点比较：平衡点（Break-Event Point，BEP）为查准率=查全率时对应的取值，该值大的优于小的。如A优于B</li></ul></li></ul><p>由于平衡的BEP过于简化，更常用Fβ度量</p><ul><li>F1度量：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-2-12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>其实F1是基于查准率与查全率的调和平均（harmonic mean）定义的：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-2-13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li>Fβ度量：当对查准率和查全率的重视程度不同时可以调节β的值体现这一差异：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-2-14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>其实Fβ是基于查准率与查全率的加权调和平均（harmonic mean）定义的：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-2-15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul><p>与算术平均和几何平均相比，调和平均更重视较小值</p><p>其中β&gt;0度量了查全率对查准率的相对重要性。<strong>β=1时退化为标准的F1，β&gt;1时查全率有更大影响，β&lt;1时查准率有更大影响</strong></p><h3 id="多个二分类混淆矩阵下的查准率、查全率与F1"><a href="#多个二分类混淆矩阵下的查准率、查全率与F1" class="headerlink" title="多个二分类混淆矩阵下的查准率、查全率与F1"></a>多个二分类混淆矩阵下的查准率、查全率与F1</h3><p>当对一个二分类问题多次重复训练得到多个二分类混淆矩阵，或者当对多分类任务下，两两类别组合都对应一个二分零混淆矩阵等情况时，需要在n个二分类混淆矩阵上计算查准率、查全率与F1</p><ul><li>先在各混淆矩阵上分别计算出查准率和查全率，再计算平均值，得到<strong>宏查准率</strong>（macro-P）、<strong>宏查全率</strong>（macro-R），以及相应的<strong>宏F1</strong>（macro-F1）<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-2-16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li>先将各混淆矩阵的对应元素进行平均，得到TP、FP、TN、FN的平均值，再基于这些平均值计算出<strong>微查准率</strong>（micro-P）、<strong>微査全率</strong>（micro-R）和<strong>微F1</strong>（micro-F1）<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-2-17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul><h2 id="ROC与AUC"><a href="#ROC与AUC" class="headerlink" title="ROC与AUC"></a>ROC与AUC</h2><p>当采用阈值（threshold）对分类概率进行排序的时候，阈值可以看成是按照预测概率从大到小排列的样本数据的一个截断点（cut point），截断点前是正例，后是反例。</p><p>ROC（受试者工作特性（Receiver Operating Characteristic））曲线，和PR曲线意义相似，横纵坐标表示不同，ROC横轴为假正例率（False Positive Rate，FPR），纵轴是真正例率（True Positive Rate，TPR）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-2-18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>ROC图中，对角线对应于<strong>随机猜想</strong>模型，而点（0,1）对应将所有正例排在所有反例之前的<strong>理想模型</strong></li><li>现实任务中，根据学习器预测结果对样例进行排序，先把分类阈值设为最大，即把所有样例均预测为反例，此时真正例率和假正例率均为0，在坐标(0,0)处标记一个点；然后，将分类阈值依次设为每个样例的预测值，分别计算真正例率和假正例率，然后画点</li><li>若一条ROC曲线能够完全包裹另一条ROC曲线，则前者优于后者</li><li>AUC（Area Under ROC Curve）即ROC曲线下包裹的面积，面积大的一般为优</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-2-19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>图b中有限样例绘制的ROC曲线计算AUC即：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-2-20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>给定m+个正例，m-个反例时，排序损失（rank loss）定义为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-2-21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>即考虑每一对正、反例，若正例的预测值小于反例，则记一个罚分，若相等，则记0.5个罚分。lrank对应的是ROC曲线之上的面积，因此有：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-2-22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="代价敏感错误率与代价曲线"><a href="#代价敏感错误率与代价曲线" class="headerlink" title="代价敏感错误率与代价曲线"></a>代价敏感错误率与代价曲线</h2><p>非均等代价（unequal cost），权衡不同类型错误所造成的不同损失</p><p>代价矩阵（cost matrix）比较所有分类的两两比较中，相对的损失大小，costij表示i对j类造成的损失大小。一般costii=0，costij&gt;costji表示i对j损失更大</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-2-23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>非均等代价下希望得到最小化的总体代价（total cost），例如m个样例的D集中，D+和D-分别表示正例集和反例集，则<strong>代价敏感</strong>（cost-sensitive）错误率为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-2-24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>代价曲线（cost curve）可以反应学习器的期望总体代价。</p><p>代价曲线图的横轴时取值为[0,1]的正例概率代价，其中p是样例为正例的概率</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-2-25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>纵轴是取值为[0,1]的归一化代价，其中FPR为假正例率，FNR=1-TPR是假反利率</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-2-26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>代价曲线的绘制：ROC曲线上每一点对应了代价平面上的一条线段，设ROC曲线上点的坐标为(TPR,FPR)，则可相应计算出FNR，然后在代价平面上绘制条从(0,FPR)到(1,FNR)的线段，线段下的面积即表示了该条件下的期望总体代价；将ROC曲线上的每个点转化为代价平面上的一条线段，然后取所有线段的下界，围成的面积即为在所有条件下学习器的期望总体代价</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-2-27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="比较检验"><a href="#比较检验" class="headerlink" title="比较检验"></a>比较检验</h1><p>比较检验即确定多个学习器之间的关系，孰强孰弱。</p><h2 id="假设检验"><a href="#假设检验" class="headerlink" title="假设检验"></a>假设检验</h2><p>统计假设检（hypothesis test）为进行学习器性能比较提供了重要依据。基于假设检验结果可推断出，若在测试集上观察到学习器A比B好，则A的泛化性能是否在统计意义上优于B，以及这个结论的把握有多大。如果二者接近的可能性比较大，则可以根据测试错误率推出泛化错误率（即检验“测试错误率和泛化错误率相等”此假设在多大的置信区域内是成立的）</p><p>常用的假设检验方法</p><ul><li>二项检验（binomial test）：对于验证假设“泛化错误率&lt;=给定错误率（一般是测试错误率）”此假设能否被拒绝</li><li>t检验（t-test）：对于多次留出法得到的测试错误率做估计</li><li>交叉验证t检验<ul><li>对于k折交叉验证法得到的测试错误率使用成对t检验（paired t-tests）</li><li>由于进行有效的假设检验的重要前提是测试错误率均为泛化错误率的独立采样。然而，通常情况下由于样本有限，在使用交叉验证等实验估计方法时不同轮次的训练集会有一定程度的重叠。为缓解这一问题，可采用 <strong>5×2交叉验证</strong> 法</li></ul></li></ul><h2 id="McNemar-检验"><a href="#McNemar-检验" class="headerlink" title="McNemar 检验"></a>McNemar 检验</h2><p>McNemar检验用于对二分类问题，使用留出法估计学习器的测试错误率的情况。</p><p>二分类问题下的留出法可获得两学习器分类结果的差别，即两者都正确、都错误、一个正确另一个错误的样本数，得到一个<strong>列联表</strong>（contingency table）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-2-28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>若假设“两个学习器的性能相同”，则应有 e01=e10，从而 |e01-e10| 应服从正态分布，且均值为1，方差为 e10+e01。从而变量</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-2-29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>服从自由度为1的卡方分布，即标准正态分布变量的平方，给定显著度α可以做假设检验</p><h2 id="Friedman-检验-与-Nemenyi-后续检验"><a href="#Friedman-检验-与-Nemenyi-后续检验" class="headerlink" title="Friedman 检验 与 Nemenyi 后续检验"></a>Friedman 检验 与 Nemenyi 后续检验</h2><p>交叉验证t检验和McNemar检验都是在一个数据集上比较两个算法的性能。当在一组数据集上对多个算法进行比较时，一种做法是在每个数据集上分别列出两两比较的结果，在两两比较时可使用以上方法；另一种方法是使用基于算法排序的 Friedman 检验。</p><p>Friedman 检验可以判断“所有算法的性能相同”此假设是否可以被拒绝，如果不可以，则需要进行后续检验（post-hoc test）进一步区分算法，常用Nemenyi后续检验。</p><p>Friedman检验图可以直观地展示检验结果，其纵轴是各个算法，横轴为平均序值。对每个算法，用一个圆点显示其平均序值，以圆点为中心的横线段表示临界值域的大小。若两个算法的横线段有交叠，则说明这两个算法没有显著差别，否则即说明有显著差别。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-2-30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="偏差与方差"><a href="#偏差与方差" class="headerlink" title="偏差与方差"></a>偏差与方差</h1><p>偏差-方差分解（bias-variance decomposition）试图对学习算法的期望泛化错误率进行拆解，是解释学习算法泛化性能的重要工具。</p><p>对测试样本x，令yD为x在数据集中的标记，y为x的真是标记，f(x;D)为训练集D上学得模型f在x上的预测输出，在回归任务中</p><p>学习算法的期望预测为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-2-31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>使用样本数相同的不同训练集产生的方差为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-2-32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>噪声为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-2-33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>期望输出与真实标记的差别称为偏差（bias）：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-2-34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在假定噪声期望为零的情况下，有：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-2-35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>即<strong>泛化误差可分解为偏差、方差与噪声之和</strong></p><p>推导过程： </p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-2-36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>偏差度量了学习算法的期望预测与与选择真实结果的偏离程度，即刻画了学习算法本身的拟合能力；方差度量了同样大小的训练集的变动所导致的学习性能的变化，即刻画了数据扰动所造成的影响；噪声表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界，即刻画了学习问题本身的难度。</p><p>偏差-方差分解说明，泛化性能是由<strong>学习算法的能力</strong>、<strong>数据的充分性</strong>以及<strong>学习任务本身的难度</strong>所共同决定的。</p><p> 一般来说，偏差与方差是有冲突的，称之为偏差-方差窘境（bias-variance dilemma）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-2-37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><blockquote><p>全文参考：周志华 著 《机器学习》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;误差与过拟合&quot;&gt;&lt;a href=&quot;#误差与过拟合&quot; class=&quot;headerlink&quot; title=&quot;误差与过拟合&quot;&gt;&lt;/a&gt;误差与过拟合&lt;/h1&gt;&lt;h2 id=&quot;误差&quot;&gt;&lt;a href=&quot;#误差&quot; class=&quot;headerlink&quot; title=&quot;误差&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://blogs.littlegenius.xin/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习笔记" scheme="https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="机器学习" scheme="https://blogs.littlegenius.xin/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>【机器学习】（一）机器学习基础</title>
    <link href="https://blogs.littlegenius.xin/2019/12/25/%E3%80%90ML%E3%80%911%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    <id>https://blogs.littlegenius.xin/2019/12/25/%E3%80%90ML%E3%80%911%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/</id>
    <published>2019-12-25T09:22:24.000Z</published>
    <updated>2019-12-25T09:31:24.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="机器学习（Machine-Learning）"><a href="#机器学习（Machine-Learning）" class="headerlink" title="机器学习（Machine Learning）"></a>机器学习（Machine Learning）</h2><p>机器学习研究的内容是关于在计算机上从<strong>数据/经验</strong>（data/experience）中产生<strong>模型</strong>（model）的算法，即<strong>学习算法</strong>（learning algorithm）。</p><p>Mitchell于1997年给出的定义：假设用P来评估计算机程序在某任务类T上的性能，若一个程序通过利用经验E在T中任务上获得了性能改善，则我们就说关于T和P，该程序对E进行了学习。</p><h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><ul><li>数据集（data set）：数据的集合，数据是若干条属性与其取值，记录关于对一个事件或对象的描述</li><li>示例（instance）/样本（sample）：数据集中的每一条数据</li><li>属性（attribute）/特征（feature）：反映事件或对象在某方面的表现或性质的事项</li><li>属性值（attribute value）：属性上的取值</li><li>属性空间（attribute space）/样本空间（sample space）/输入空间（input space）</li><li>特征向量（feature vector）：属性空间中任何一点所对应的向量</li><li>标记（lable）：表示示例结果的信息</li><li>样例（example）：带有标记的信息示例</li><li>标记空间（lable space）/输出空间（output space）：所有的标签的集合</li><li>测试样本（testing sample）：用于对学习模型进行测试的样本数据</li></ul><p>一般地，令 D={x1, x2, …, xm} 表示包含 m 个示例的数据集，每个示例由 d 个属性描述，则每个示例 xi=(xi1, xi2, …, xid) 是 d 维样本空间 X 中的一个向量，xi∈X，其中 xij 是 xi 在第 j 个属性上的取值，d 称为样本 xi 的<strong>维数</strong>(dimensionality)。用(xi,yi)表示第i个样例及其标签yi，yi∈Y。</p><ul><li>泛化（generalization）：将学习得到的模型应用于新的数据集（测试集）的能力成为泛化能力</li></ul><p>通常假设样本空间中全体样本服从一个未知<strong>分布</strong>（distribution）D，我们获得的每个样本都是独立地从这个分布上采样获得的，即<strong>独立同分布</strong>（independent and identically distributed，简称<strong>iid</strong>）。一般而言，训练样本越多，我们得到的关于D的信息越多，这样就越有可能通过学习获得具有<strong>强泛化能力</strong>的模型。</p><h2 id="机器学习的分类"><a href="#机器学习的分类" class="headerlink" title="机器学习的分类"></a>机器学习的分类</h2><h3 id="基于学习任务"><a href="#基于学习任务" class="headerlink" title="基于学习任务"></a>基于学习任务</h3><ul><li>分类（classification）：预测值是离散的<ul><li>二分类（binary      classification）：预测值只有两个类别，通常将其中一个成为正类（positive class），另一个成为反类/负类（negative class）</li><li>多分类（mutil-class      classification）：预测值是多个离散的类别</li></ul></li><li>回归（regression）：预测值是连续值，其标记空间为实数集</li><li>聚类（clustering）：将训练集中的数据分成若干个簇，通常情况下这种学习的数据集是<strong>无标签的</strong></li></ul><h3 id="基于训练数据是否拥有标签"><a href="#基于训练数据是否拥有标签" class="headerlink" title="基于训练数据是否拥有标签"></a>基于训练数据是否拥有标签</h3><ul><li>监督学习（supervised learning）：训练数据有标签，比如分类和回归</li><li>无监督学习（unsupervised learning）：训练数据无标签，比如聚类</li></ul><h2 id="假设空间"><a href="#假设空间" class="headerlink" title="假设空间"></a>假设空间</h2><p>我们把学习过程看作一个在所有<strong>假设</strong>（hypothesis）组成的空间（<strong>假设空间</strong>（hypothesis space））中进行搜索的过程，搜索目标是找到与训练集<strong>匹配</strong>（fit）的假设。假设的表示一旦确定，假设空间及其规模大小就确定了。</p><p>现实问题中我们常面临很大的假设空间，但学习过程是基于有限样本训练集进行的，因此，可能有多个假设与训练集一致，即存在着一个与训练集一致的假设集合，称之为<strong>版本空间</strong>（version space）</p><h2 id="归纳偏好"><a href="#归纳偏好" class="headerlink" title="归纳偏好"></a>归纳偏好</h2><p>机器学习算法在学习过程中对某种类型假设的偏好，称为<strong>归纳偏好</strong>（inductive bias），简称为偏好。</p><p>任何一个有效的机器学习算法必有其归纳偏好。归纳偏好可看作学习算法自身在一个可能很庞大的假设空间中对假设进行选择的启发式或价值观。</p><h3 id="奥卡姆剃刀原则（Occam’s-razor）"><a href="#奥卡姆剃刀原则（Occam’s-razor）" class="headerlink" title="奥卡姆剃刀原则（Occam’s razor）"></a>奥卡姆剃刀原则（Occam’s razor）</h3><p>奥卡姆剃刀原则称“若有多个假设与观察一致，则选最简单的那个”。比如我们通过训练得到有两条可以描述训练样本的曲线，平滑的A曲线可能意味着更加简单。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-1-1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="没有免费的午餐定理（No-Free-Lunch-Theorem，NFL）"><a href="#没有免费的午餐定理（No-Free-Lunch-Theorem，NFL）" class="headerlink" title="没有免费的午餐定理（No Free Lunch Theorem，NFL）"></a>没有免费的午餐定理（No Free Lunch Theorem，NFL）</h3><p>没有免费的午餐定理指机器学习的模型总误差与学习算法无关，即学习算法的期望性能相同</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-1-2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>但是显然NFL定理是基于一个前提的：所有问题出现的机会相同、或所有问题同等重要。但实际情形并不是这样。</p><p>NFL的意义在于让我们更加清楚的认识到，脱离具体问题空泛地比较学习算法的好坏毫无意义</p><p><strong>学习算法自身的归纳偏好与问题是否相配，往往会起到决定性的作用</strong></p><blockquote><p>NFL 定理的简单证明过程</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/ML-1-3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><blockquote><p>全文参考：周志华 著 《机器学习》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;h2 id=&quot;机器学习（Machine-Learning）&quot;&gt;&lt;a href=&quot;#机器学习（Machine-Learning）&quot;
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://blogs.littlegenius.xin/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习笔记" scheme="https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="机器学习" scheme="https://blogs.littlegenius.xin/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构】（六）不相交集类</title>
    <link href="https://blogs.littlegenius.xin/2019/08/29/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%85%AD%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86%E7%B1%BB/"/>
    <id>https://blogs.littlegenius.xin/2019/08/29/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%85%AD%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86%E7%B1%BB/</id>
    <published>2019-08-29T04:14:30.000Z</published>
    <updated>2019-08-29T05:12:25.643Z</updated>
    
    <content type="html"><![CDATA[<h1 id="等价关系"><a href="#等价关系" class="headerlink" title="等价关系"></a>等价关系</h1><p>在离散数学（Discrete Mathematics）中提到过<strong>等价关系</strong>（equivalence relation）,等价关系是对于任意一对元素 (a,b)，存在一个关系R满足以下三个属性：</p><ul><li>自反性：对于所有的元素a，a R a</li><li>对称性：a R b == b R a</li><li>传递性：若 a R b 且 b R c 则 a R c</li></ul><p>比如空间中的相互平行的线就满足等价关系，线与自身平行、两条平行线相互平行，如果a平行于b，b平行于c，a也就平行于c，所以平行关系是等价关系。</p><p>一个集合S上的元素之间存在的等价关系是对集合S的一个划分，相互等价的元素可以划分到一个子集中，而没有等价关系的两个元素肯定不会被分到同一个子集中，所以按照等价关系划分可以将S划分为多个子集，每个子集中的元素都相互等价，这些子集是不相交的，而且他们的并正好是集合S。具有这种特性的集合可以视为一个<strong>不相交集类</strong>（The Disjoint Sets Class）</p><p>不相交集类的适合用于查找，有两个重要的操作：<code>find</code>和<code>union</code>：</p><ul><li><code>find</code>：查找操作，<code>find(x)</code>是返回x所在的子集的名字</li><li><code>union</code>：合并操作，如果我们发现两个元素a和b相互等价，但是他们没有在同一个子集中，那么很显然，a所在的子集和b所在的子集中的所有元素都相互等价，我们可以将其合并成一个新的子集</li></ul><h1 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h1><p>如果不要求find操作返回任意特定的名字，而是要求当且仅当两个元素属于相同的子集时，则作用在这两个元素上的find操作能返回相同的明自。那么我就需要对集合S进行划分，并且每一个子集都有唯一的名字。</p><p>一种简单的实现方式时是哟个森林，森林中的树就是一个子集，节点就是元素，同一棵树上的所有节点就都属于这个子集，显然可以将子集的名字存储到树的根节点中。这种方式很简单，使用数组就可以实现。比如我们有一个8元素的集合，他们分别是0 1 2 3 4 5 6 7，最初始的时候就是每个节点都单独成树，根节点中存储-1来代表这个时根节点，然后使用union方法来合并集合。像下边这样（union(a,b)默认将b挂到a上）：</p><p>初始的一个森林</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure7-1.png" alt="一个不相交集类的基本实现" title="">                </div>                <div class="image-caption">一个不相交集类的基本实现</div>            </figure><p>进行<code>union(4,5)</code>操作：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure7-2.png" alt="一个不相交集类的基本实现" title="">                </div>                <div class="image-caption">一个不相交集类的基本实现</div>            </figure><p>进行<code>union(6,7)</code>操作：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure7-3.png" alt="一个不相交集类的基本实现" title="">                </div>                <div class="image-caption">一个不相交集类的基本实现</div>            </figure><p>进行<code>union(4,6)</code>操作：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure7-4.png" alt="一个不相交集类的基本实现" title="">                </div>                <div class="image-caption">一个不相交集类的基本实现</div>            </figure><p>最终的存储这个不相交集类的数组如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure7-5.png" alt="一个不相交集类的基本实现" title="">                </div>                <div class="image-caption">一个不相交集类的基本实现</div>            </figure><h1 id="从union操作改进"><a href="#从union操作改进" class="headerlink" title="从union操作改进"></a>从union操作改进</h1><h2 id="按大小求并（union-by-size）"><a href="#按大小求并（union-by-size）" class="headerlink" title="按大小求并（union-by-size）"></a>按大小求并（union-by-size）</h2><p>这个思想是打破随意将一个集合接到另一个集合上的做法，而是根据大小将树合并，即永远将小的集合挂到大的集合上，这种实现方式很简单，并且使得森林中树的结构都不会特别复杂，避免了最坏情况的发生，存储时，<strong>将树的根节点的内容存储为此时树的大小的负数</strong>，比如继续上边的不相交集类，进行<code>union(3,4)</code>操作：</p><p>依旧按照原来的union方式合并：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure7-6.png" alt="依照一般的union方式合并" title="">                </div>                <div class="image-caption">依照一般的union方式合并</div>            </figure><p>按照小树并大树的方式进行union合并：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure7-7.png" alt="按照大小合并" title="">                </div>                <div class="image-caption">按照大小合并</div>            </figure><p>按照大小合并后的存储数组：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure7-8.png" alt="按照大小合并的存储数组" title="">                </div>                <div class="image-caption">按照大小合并的存储数组</div>            </figure><h2 id="按高度求并（union-by-height）"><a href="#按高度求并（union-by-height）" class="headerlink" title="按高度求并（union-by-height）"></a>按高度求并（union-by-height）</h2><p>根据高度将树合并，即永远将矮的集合挂到高的集合上，存储时，<strong>将树的根节点的内容存储为此时树的高度的负数</strong>，比如继续上边的不相交集类，进行按照高度的<code>union(3,4)</code>操作会得到：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure7-9.png" alt="按照高度合并" title="">                </div>                <div class="image-caption">按照高度合并</div>            </figure><p>存储数据的数组内容：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure7-10.png" alt="按照高度合并的存储数组" title="">                </div>                <div class="image-caption">按照高度合并的存储数组</div>            </figure><h1 id="从find操作改进"><a href="#从find操作改进" class="headerlink" title="从find操作改进"></a>从find操作改进</h1><p>在对union进行改进后可以对find进行改进，find改进的一种典型方式是<strong>路径压缩</strong>（Pass Compression）。即在每一次find后，将find的数据到根节点的沿途的每个节点都挂到根节点上，从而对路径进行压缩，而下次查找同一个元素或者其同子集下的元素就会非常省时间。</p><p>例如一个不相交集类如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure7-11.png" alt="一个不相交集类" title="">                </div>                <div class="image-caption">一个不相交集类</div>            </figure><p>在这个不太好的结构上进行find(14)后进行路径压缩可以得到：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure7-12.png" alt="对这个不相交集类进行路径压缩" title="">                </div>                <div class="image-caption">对这个不相交集类进行路径压缩</div>            </figure><p>这样就使得整棵树的高度、一些数据的路径深度（12、13、14、15）都得到了降低。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;等价关系&quot;&gt;&lt;a href=&quot;#等价关系&quot; class=&quot;headerlink&quot; title=&quot;等价关系&quot;&gt;&lt;/a&gt;等价关系&lt;/h1&gt;&lt;p&gt;在离散数学（Discrete Mathematics）中提到过&lt;strong&gt;等价关系&lt;/strong&gt;（equivalen
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://blogs.littlegenius.xin/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习笔记" scheme="https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/tags/C/"/>
    
      <category term="数据结构" scheme="https://blogs.littlegenius.xin/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【C++温故知新】（九）文件的输入与输出</title>
    <link href="https://blogs.littlegenius.xin/2019/08/28/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E4%B9%9D%E6%96%87%E4%BB%B6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"/>
    <id>https://blogs.littlegenius.xin/2019/08/28/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E4%B9%9D%E6%96%87%E4%BB%B6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/</id>
    <published>2019-08-28T14:47:10.000Z</published>
    <updated>2019-08-28T15:19:38.344Z</updated>
    
    <content type="html"><![CDATA[<p>文件的输入与输出也是基于<strong>流</strong>（stream）的，和<code>cout</code>、<code>cin</code>的操作类似。</p><h1 id="文件的写入"><a href="#文件的写入" class="headerlink" title="文件的写入"></a>文件的写入</h1><h2 id="基本条件"><a href="#基本条件" class="headerlink" title="基本条件"></a>基本条件</h2><ul><li>必须包含头文件 <code>fstream</code> </li><li>头文件 <code>fstream</code> 定义了一个用于处理输出的 <code>ofstream</code> 类</li><li>需要声明一个或多个 <code>ofstream</code> 变量（对象），并命名</li><li>必须指明名称空间 <code>std</code></li><li>需要将 <code>ofstream</code> 对象与文件关联起来。方法之一是使用 <code>open()</code> 方法</li><li>使用完文件后，应使用方法 <code>close()</code> 将其关闭</li><li>可结合使用 <code>ofstream</code> 对象和运算符 <code>&lt;&lt;</code> 来输出各种类型的数据</li></ul><h2 id="一个文件写入的实例"><a href="#一个文件写入的实例" class="headerlink" title="一个文件写入的实例"></a>一个文件写入的实例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> myString = <span class="string">"hello world!"</span>;</span><br><span class="line"></span><br><span class="line">    ofstream ourFile;</span><br><span class="line">    outFile.<span class="built_in">open</span>(<span class="string">"myFile.txt"</span>);</span><br><span class="line">    outFile &lt;&lt; myString;</span><br><span class="line">    outFile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="文件的读取"><a href="#文件的读取" class="headerlink" title="文件的读取"></a>文件的读取</h1><h2 id="基本条件-1"><a href="#基本条件-1" class="headerlink" title="基本条件"></a>基本条件</h2><ul><li>必须包含头文件 <code>fstream</code></li><li>头文件 <code>fstream</code> 定义了一个用于处理输入的 <code>ifstream</code> 类</li><li>需要声明一个或多个 <code>ifstream</code> 变量（对象），并命名</li><li>需要将 <code>ifstream</code> 对象与文件关联起来。方法之一是使用 <code>open()</code> 方法</li><li>读取完文件后，应使用方法 <code>close()</code> 将其关闭</li><li>可结合使用 <code>ifstream</code> 对象和运算符 <code>&gt;&gt;</code> 来读取各种类型的数据</li><li>可以使用 <code>ifstream</code> 对象和 <code>get()</code> 方法来读取一个字符，使用 <code>ifstream</code> 对象和 <code>getline()</code> 来读取一行字符</li><li>可以结合使用 <code>ifstream</code> 和 <code>cof()</code>、<code>fai()</code> 等方法来判断输入是否成功</li><li><code>ifstream</code> 对象本身被用作测试条件时，如果最后一个读取操作成功，它将被转换为布尔值 <code>true</code>，否则被转换为 <code>false</code></li></ul><h2 id="一个文件读取的实例"><a href="#一个文件读取的实例" class="headerlink" title="一个文件读取的实例"></a>一个文件读取的实例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> fileName = <span class="string">"myFile.txt"</span>;</span><br><span class="line"></span><br><span class="line">    ifstream inFile;</span><br><span class="line">    inFile.<span class="built_in">open</span>(fileName);</span><br><span class="line">    <span class="keyword">if</span> (!inFile.is_open())</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Can't open the file: "</span> &lt;&lt; fileName;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> readText;</span><br><span class="line">    inFile &gt;&gt; readText;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inFile.eof())</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"End of file reached.\n"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (inFile.fail())</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Input terminated by data mismatch.\n"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Input terminated for other reasons.\n"</span>;</span><br><span class="line"></span><br><span class="line">    inFile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文件的输入与输出也是基于&lt;strong&gt;流&lt;/strong&gt;（stream）的，和&lt;code&gt;cout&lt;/code&gt;、&lt;code&gt;cin&lt;/code&gt;的操作类似。&lt;/p&gt;
&lt;h1 id=&quot;文件的写入&quot;&gt;&lt;a href=&quot;#文件的写入&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/categories/C/"/>
    
    
      <category term="学习笔记" scheme="https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【C++温故知新】（八）异常处理</title>
    <link href="https://blogs.littlegenius.xin/2019/08/28/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E5%85%AB%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>https://blogs.littlegenius.xin/2019/08/28/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E5%85%AB%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</id>
    <published>2019-08-28T14:46:56.000Z</published>
    <updated>2019-08-28T14:53:16.689Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异常的抛出与捕获"><a href="#异常的抛出与捕获" class="headerlink" title="异常的抛出与捕获"></a>异常的抛出与捕获</h1><p>异常是程序在执行期间产生的问题，比如尝试除以零的操作。异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：<code>try</code>、<code>catch</code>、<code>throw</code>。</p><ul><li><code>throw</code>：当问题出现时，程序抛出一个异常</li><li><code>catch</code>：在想要处理问题的地方，通过异常处理程序捕获异常</li><li><code>try</code>：try块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。</li></ul><p>使用throw可以在一些特定的时候令程序抛出异常，比如当遇到除数是0的时候：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(division == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="string">"division by zero condition!"</span>;</span><br></pre></td></tr></table></figure><p>一个<code>try……catch</code>的写法通常是这这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// protected codes</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>( ExceptionName e1 )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// catch block</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>( ExceptionName e2 )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// catch block</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要捕获所有的异常，则需要在<code>catch</code>的括号中使用省略号：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// protected codes</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>( … )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// catch block</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="定义新的异常"><a href="#定义新的异常" class="headerlink" title="定义新的异常"></a>定义新的异常</h1><p>可以通过继承和重载<code>exception</code>类来定义新的异常，比如像下边这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyException</span> :</span> <span class="keyword">public</span> exception</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="title">throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"New Exception"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> MyException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> ( MyException&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"MyException caught"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (exception&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// other exceptions</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;异常的抛出与捕获&quot;&gt;&lt;a href=&quot;#异常的抛出与捕获&quot; class=&quot;headerlink&quot; title=&quot;异常的抛出与捕获&quot;&gt;&lt;/a&gt;异常的抛出与捕获&lt;/h1&gt;&lt;p&gt;异常是程序在执行期间产生的问题，比如尝试除以零的操作。异常提供了一种转移程序控制权的方式。C
      
    
    </summary>
    
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/categories/C/"/>
    
    
      <category term="学习笔记" scheme="https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【C++温故知新】（七）类的继承</title>
    <link href="https://blogs.littlegenius.xin/2019/08/28/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E4%B8%83%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/"/>
    <id>https://blogs.littlegenius.xin/2019/08/28/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E4%B8%83%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/</id>
    <published>2019-08-28T14:39:06.000Z</published>
    <updated>2019-08-28T14:54:17.937Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类继承的语法"><a href="#类继承的语法" class="headerlink" title="类继承的语法"></a>类继承的语法</h1><p>类的继承允许通过继承的方式生成新类，继承自的类为<strong>基类</strong>，继承自基类的类成为派生类，类的继承写法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derivedClass</span> :</span> <span class="keyword">public</span>/protect/<span class="keyword">private</span> baseClass</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// statements</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中基类前有一个访问限定符，不写的时候默认为private，但是我们主要使用public，又称作公有继承，三个不同的访问限定词的区别在于：</p><ul><li>公有继承（<code>public</code>）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问</li><li>保护继承（<code>protecte</code>）：      当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员</li><li>私有继承（<code>private</code>）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员</li></ul><p>例如我们定义一个基类再定义一个派生类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">baseClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    baseInt;</span><br><span class="line">    baseDouble;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    baseClass(<span class="keyword">const</span> <span class="keyword">int</span> pInt = <span class="number">1</span>, cosnt <span class="keyword">double</span> pDouble = <span class="number">2.5</span>);</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">(<span class="keyword">double</span> d)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">baseClass :: baseClass(<span class="keyword">const</span> <span class="keyword">int</span> pInt = <span class="number">1</span>, cosnt <span class="keyword">double</span> pDouble = <span class="number">2.5</span>)</span><br><span class="line">&#123;</span><br><span class="line">    baseInt = pInt;</span><br><span class="line">    baseDouble = pDouble;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">baseClass :: function(<span class="keyword">double</span> d)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derivedClass</span> :</span> <span class="keyword">public</span> baseClass</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">derivedChar;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    derivedClass(<span class="keyword">const</span> <span class="keyword">int</span> pInt, <span class="keyword">const</span> <span class="keyword">double</span> pDouble, <span class="keyword">const</span> <span class="keyword">char</span> pChar);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">anotherFunction</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">derivedClass :: derivedClass(<span class="keyword">const</span> <span class="keyword">int</span> pInt, <span class="keyword">const</span> <span class="keyword">double</span> pDouble, <span class="keyword">const</span> <span class="keyword">char</span> pChar) : baseClass(pInt,pDouble)</span><br><span class="line">&#123;</span><br><span class="line">derivedChar = pChar;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> derivedClass :: anotherFunction()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"I am the derived class."</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个例子中，我们可以看到，基类有两个私有变量，<code>baseInt</code>和<code>baseDouble</code>，两个方法，一个构造函数用于给两个私有变量赋值，一个用于充数。派生类继承自基类，于是派生类<code>derivedClass</code>就拥有了基类的两个公有方法，但是它不能访问基类的两个私有变量。派生类又定义了自己的一个新私有变量，同时有自己的构造函数和一个用于充数的函数。可见继承的作用在于方便地进行代码的重用以及组织管理项目设计。</p><h1 id="基类和派生类的关系"><a href="#基类和派生类的关系" class="headerlink" title="基类和派生类的关系"></a>基类和派生类的关系</h1><p>类的继承是“is-a”的关系，或者说是“is-a-kind-of”，即派生类对象也是一个基类对象。</p><ul><li>派生类是可以调用基类的<code>protected</code>和<code>public</code>修饰的成员变量和方法的，而派生类也可以定义自己的变量和方法。</li><li>同时，派生类还可以重载基类的方法，即声明一个和基类中相同名称的成员变量，但是在派生类中对其进行重新的定义。如果基类和派生类同时拥有同名同变量参数同返回值但是定义不同的函数，在使用基类对象调用该函数时，调用的是基类的函数，在使用派生类的对象调用该函数时，调用的是派生类的定义。</li><li>基类指针可以在不进行显式类型转换的情况下指向派生类对象；基类引用可以在不进行显式类型转换的情况下引用派生类对象。C++要求的引用和指针类型与赋给的类型匹配的规则对继承来说例外。然而，这种例外只是单向的，不可以将基类对象和地址赋给派生类引用和指针。基类指针或引用只能用于调用基类方法。</li></ul><h1 id="多态公有继承"><a href="#多态公有继承" class="headerlink" title="多态公有继承"></a>多态公有继承</h1><p>多态即一个派生类继承自一个基类后，希望可以定义一个和基类中相同名称、参数列表、返回值的函数，但这个函数的定义却与基类中的不同，即一种派生类对基类方法的重载。</p><p>首先，派生类可以重载基类的方法，如果派生类使用基类相同的函数和函数定义，那么就不需要再在派生类中声明该函数，即共有的函数需要放在基类中。如果派生类想对基类的函数进行新的定义，则需要在派生类中对其再次进行声明并定义，定义时也需要表明定义的是那个类的函数。如 <code>baseClass::function()</code> 和 <code>derivedClass::function()</code> 这样。</p><p><strong>虚方法</strong>（virtual method），需要使用关键词 <code>virtual</code> 修饰基类中的函数，如下面这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br></pre></td></tr></table></figure><p>它的作用如下：当基类和派生类都有定义过某个相同方法后，我们需要确定调用的是哪个类下的方法，特别是当方法是通过引用或指针而不是对象调用的。</p><ul><li>如果没有使用关键字 <code>virtual</code> ，程序将根据引用类型或指针类型选择方法</li><li>如果使用了关键字 <code>virtual</code> ，程序将根据引用或指针指向的对象的类型来选择方法</li><li>如果有派生类重载了基类的方法，一般需要将基类的析构函数设置成virtual的以保证释放派生类对象时能够按照正确的顺序调用析构函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用virtual</span></span><br><span class="line"><span class="function">BaseClass <span class="title">baseClass</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">DerivedClass <span class="title">derivedClass</span><span class="params">()</span></span>;</span><br><span class="line">BaseClass &amp; reference1 = baseClass; <span class="comment">// 指向baseClass的类型是BaseClass的引用变量</span></span><br><span class="line">BaseClass &amp; reference2 = derivedClass; <span class="comment">// 指向derivedClass的但是类型是BaseClass的引用变量</span></span><br><span class="line">reference1.function(); <span class="comment">// 会根据引用的类型即BaseClass调用BaseClass下的function方法</span></span><br><span class="line">reference2.function(); <span class="comment">// 会根据引用的类型即BaseClass调用BaseClass下的function方法</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用virtual</span></span><br><span class="line"><span class="function">BaseClass <span class="title">baseClass</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">DerivedClass <span class="title">derivedClass</span><span class="params">()</span></span>;</span><br><span class="line">BaseClass &amp; reference1 = baseClass; <span class="comment">// 指向baseClass的类型是BaseClass的引用变量</span></span><br><span class="line">BaseClass &amp; reference2 = derivedClass; <span class="comment">// 指向derivedClass的但是类型是BaseClass的引用变量</span></span><br><span class="line">reference1.function(); <span class="comment">// 会根据引用指向的类型即BaseClass调用BaseClass下的function方法</span></span><br><span class="line">reference2.function(); <span class="comment">// 会根据引用指向的类型即DerivedClass调用BaseClass下的function方法</span></span><br></pre></td></tr></table></figure><h1 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h1><p><strong>抽象基类</strong>（abstract base class，ABC）是一种特殊的基类，从概念上讲，将所有派生类的公用的方法进行抽象汇总声明（定义）到的一个类中，这种设计下的类可以视作一个抽象基类。但是真正的抽象基类应该是至少包含了一个<strong>纯虚函数</strong>（pure virtual function）的类，<strong>这种类不能声明对应的对象</strong>，只能作为基类。</p><p>纯虚函数是一种只在抽象基类中给出原型，但是部给出定义的函数，更像是一个接口，由所有的派生类对纯虚函数根据自己类的需求来实现其定义。纯虚函数的写法是在虚函数后面以 =0 结尾</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">pureVirtualFunction</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>应用这种方式，可以将所有派生类共有但是却又各自有着不同实现的方法抽象到一个基类中，提供其原型但是不对其进行定义（也只有纯虚函数C++允许不给出定义），然后使得各个派生类自己给出其定义。</p><h1 id="私有继承"><a href="#私有继承" class="headerlink" title="私有继承"></a>私有继承</h1><p>私有继承即继承的基类使用private修饰符修饰的继承，如果没有访问限定符的修饰，默认也是私有继承，私有继承是一种“has-a”的关系。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClass</span> :</span> <span class="keyword">private</span> BaseClass&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClass</span> :</span> BaseClass&#123; &#125;</span><br></pre></td></tr></table></figure><p>私有继承使得基类的公有成员、保护成员都被成为派生类的私有成员，这就使得基类的那些方法都不能再被派生类的实例化对象使用，而只能被派生类的成员函数在类内部使用。即派生类部继承基类的接口。</p><p>这里比较了三种继承之间的区别：</p><table><thead><tr><th align="center">特征</th><th align="center">公有继承</th><th align="center">保护继承</th><th align="center">私有继承</th></tr></thead><tbody><tr><td align="center">公有成员变成</td><td align="center">派生类的公有成员</td><td align="center">派生类的保护成员</td><td align="center">派生类的私有成员</td></tr><tr><td align="center">保护成员变成</td><td align="center">派生类的保护成员</td><td align="center">派生类的保护成员</td><td align="center">派生类的私有成员</td></tr><tr><td align="center">私有成员变成</td><td align="center">只能通过基类接口访问</td><td align="center">只能通过基类接口访问</td><td align="center">只能通过基类接口访问</td></tr><tr><td align="center">能否隐式向上转换</td><td align="center">能</td><td align="center">只能在派生类中</td><td align="center">不能</td></tr></tbody></table><h1 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h1><p><strong>多重继承</strong>（Multiple Inheritance）也是“is-a”的关系，它允许一个类继承自多个类，只需要将继承的类使用逗号隔开即可，像下面这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClass</span> :</span> <span class="keyword">public</span> BaseClass1, <span class="keyword">public</span> BaseClass2 &#123;……&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClass</span> :</span> <span class="keyword">public</span> BaseClass1, BaseClass2 &#123;……&#125; <span class="comment">// BaseClass2 is a private base</span></span><br></pre></td></tr></table></figure><p>多重继承中每一个被继承的基类都需要设置访问限定符，根据需要可以使用不同的访问限定符，不写默认为<code>private</code></p><p>例如设置一个基类Worker表示工人，然后工人可以是歌手也可以是服务员，我们使用两个类继承自这个基类，Singer和Waiter，最后，我们可以定义一个既是歌手有时服务员的类，所以它同时继承自Singer和Waiter，他们的关系就像下边这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> &#123;</span>……&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span> :</span> <span class="keyword">public</span> Worker &#123;……&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Waiter</span> :</span> <span class="keyword">public</span> Worker &#123;……&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingingWaiter</span> :</span> <span class="keyword">public</span> Singer, <span class="keyword">public</span> Waiter &#123;……&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/CPP7-1.png" alt="一个多重继承" title="">                </div>                <div class="image-caption">一个多重继承</div>            </figure><h2 id="虚基类"><a href="#虚基类" class="headerlink" title="虚基类"></a>虚基类</h2><p>首先多重继承导致了一个问题就是，当一个SingingWaiter的实例继承自Singer和Waiter时，也就间接地两次继承了Worker，也就是说一个SingingWaiter的实例结构应该是如下这样的：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/CPP7-2.png" alt="在不使用虚基类的时候" title="">                </div>                <div class="image-caption">在不使用虚基类的时候</div>            </figure><p>这样引发的问题就是，当我们把派生类对象的地址赋给一个基类的指针时就无法区分是赋给哪个基类，导致二义性：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SingingWaiter sw；</span><br><span class="line">Worker * psw = &amp;sw;</span><br></pre></td></tr></table></figure><p>因为sw中包含两个Worker对象，从而有两给地址可以选择，于是正确的写法应该是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Worker * psw1 = (Waiter *) &amp;sw;</span><br><span class="line">Worker * psw2 = (Singer *) &amp;sw;</span><br></pre></td></tr></table></figure><p>所以<strong>虚基类</strong>（Virtual Base Classes）将解决这个问题。虚基类使得从多个类派生出的对象只继承一个基类对象，需要在类继承的声明中使用virtual关键词，virtual和public的次序无所谓：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Worker &#123;……&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Waiter</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> Worker &#123;……&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingingWaiter</span> :</span> <span class="keyword">public</span> Singer, <span class="keyword">public</span> Waiter &#123;……&#125;</span><br></pre></td></tr></table></figure><p>现在，SingingWaiter对象就只包含Worker对象的一个副本，从本质上说是，继承的Singer和Waiter共享一个Worker对象，而不是各自引入一个Worker对象的副本，从而可以使用多态。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/CPP7-3.png" alt="在使用虚基类的时候" title="">                </div>                <div class="image-caption">在使用虚基类的时候</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;类继承的语法&quot;&gt;&lt;a href=&quot;#类继承的语法&quot; class=&quot;headerlink&quot; title=&quot;类继承的语法&quot;&gt;&lt;/a&gt;类继承的语法&lt;/h1&gt;&lt;p&gt;类的继承允许通过继承的方式生成新类，继承自的类为&lt;strong&gt;基类&lt;/strong&gt;，继承自基类的类成为派
      
    
    </summary>
    
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/categories/C/"/>
    
    
      <category term="学习笔记" scheme="https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【C++温故知新】（六）类和对象</title>
    <link href="https://blogs.littlegenius.xin/2019/08/27/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E5%85%AD%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <id>https://blogs.littlegenius.xin/2019/08/27/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E5%85%AD%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</id>
    <published>2019-08-27T08:41:15.000Z</published>
    <updated>2019-08-28T14:39:52.941Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类与接口"><a href="#类与接口" class="headerlink" title="类与接口"></a>类与接口</h1><p>类是一种将抽象转换为用户定义类型的C++工具，它将数据表示和操作数据的方法组合成一个整洁的包。接口提供给我们从外部访问类与类内的成员和方法的一个途径。</p><p>一般对一个类的典型的实现策略是：<strong>将接口（类的定义）放在头文件中，将其实现（类方法的代码）放在源代码文件中</strong></p><h2 id="类的声明框架"><a href="#类的声明框架" class="headerlink" title="类的声明框架"></a>类的声明框架</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// some private variables and functions</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// some public variables and functions</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p>访问限定符有三个：<code>private</code>、<code>public</code>、<code>protected</code>，它们规定了修饰的变量和方法能够被访问的范围，在没有声明时，默认是private的。</p><p>这里先对三个访问限定词做一个比较全面的介绍：</p><ul><li><code>private</code> :<ul><li>类（基类）自身的成员函数</li><li>类（基类）友元的成员函数</li></ul></li><li><code>public</code> :<ul><li>基类自身的成员函数</li><li>基类友元的成员函数</li><li>基类所产生派生类的成员函数</li><li>基类所产生的派生类的友元函数</li><li>其他的全局函数</li></ul></li><li><code>protected</code> :<ul><li>基类的成员函数</li><li>基类的友元函数</li><li>基类派生类的成员函数</li></ul></li></ul><p>例如一个类：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/CPP6-1.png" alt="一个类的结构" title="">                </div>                <div class="image-caption">一个类的结构</div>            </figure><h2 id="类的成员函数的实现"><a href="#类的成员函数的实现" class="headerlink" title="类的成员函数的实现"></a>类的成员函数的实现</h2><p>类的成员函数和一般的函数实现基本相同，还要增添如下两点：</p><ul><li>需要使用 <code>::</code> 符号（作用域解析运算符）来标识这个函数是属于哪一个类的，因为不同的类可以有相同名称的函数</li><li>类的方法可以访问类内的 <code>private</code> 的组件</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ClassName::myFunction(<span class="keyword">double</span> a);</span><br></pre></td></tr></table></figure><ul><li>类的成员函数也可以是内联的，只要加上关键词 <code>inline</code> 即可</li><li>类的成员函数可以在类内定义时同时完成逻辑，也可以在类的外部定义</li></ul><h2 id="类的使用"><a href="#类的使用" class="headerlink" title="类的使用"></a>类的使用</h2><p>类的实例化和一般的数据类型相同，调用类实例下的某个成员函数或者变量使用 <code>.</code> 点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassName myClassInstance;</span><br><span class="line">myClassInstance.aFunction();</span><br></pre></td></tr></table></figure><h1 id="类的构造函数和析构函数"><a href="#类的构造函数和析构函数" class="headerlink" title="类的构造函数和析构函数"></a>类的构造函数和析构函数</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>类的构造函数需要和类同名，是在类实例化的时候调用的，在实例化一个类的时候，虽然我们没有显示地声明，但是还是调用了构造函数，而C++对每一个类都有默认的构造函数，就是不接受任何参数，什么都不做，也无返回值。我们可以定义自己的构造函数并且调用它。</p><p>例如一个类MyClass的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> myInt;</span><br><span class="line">    <span class="keyword">double</span> myDouble;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass(<span class="keyword">int</span> mi, <span class="keyword">double</span> md) &#123; myInt = mi; myDouble = md;&#125;;</span><br><span class="line">    MyClass() &#123; myInt = <span class="number">1</span>; myDouble = <span class="number">0.2</span>;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们使用了一个包含两个参数的构造函数，它的作用是对两个private的成员变量赋值。</p><p>构造函数不能像其他成员函数一样使用对象（类的实例）来用点调用，因为构造函数是在实例化类的时候就调用的，比如如下的调用方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyClass myClass = MyClass(<span class="number">1</span>, <span class="number">0.2</span>);</span><br><span class="line"><span class="function">MyClass <span class="title">myClass</span><span class="params">(<span class="number">1</span>, <span class="number">0.2</span>)</span></span>;</span><br><span class="line">MyClass * myClassPoint = <span class="keyword">new</span> MyClass(<span class="number">1</span>, <span class="number">0.2</span>);</span><br></pre></td></tr></table></figure><p>如果是使用的默认构造函数或者构造函数没有参数的话，可以直接声明对象而不显示地调用构造函数，比如我们的类中还有一个重载的没有参数的构造函数，它可以这样被调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyClass myClass; <span class="comment">// 隐式调用</span></span><br><span class="line">MyClass myClass = MyClass(); <span class="comment">// 显示调用</span></span><br><span class="line">MyClass * myClass = <span class="keyword">new</span> MyClass(); <span class="comment">// 隐式调用</span></span><br><span class="line"><span class="function">MyClass <span class="title">myClassFunction</span><span class="params">()</span></span>; <span class="comment">// 这是一个返回值是MyClass的函数</span></span><br></pre></td></tr></table></figure><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>用构造函数创建对象后，程序负责跟踪该对象，直到其过期为止，对象过期时，程序将自动调用一个特殊的成员函数，即析构函数。</p><p>析构函数用于完成清理工作，所以非常有用，例如如果构造函数用<code>new</code>分配了内存，则可以在析构函数中用<code>delete</code>释放内存。</p><p>默认的析构函数是什么都不做的。我们以可以显示地定义自己析构函数，析构函数是一个~符号加上类名来定义的，析构函数何时调用是取决于编译器的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> myInt;</span><br><span class="line">    <span class="keyword">double</span> myDouble;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass(<span class="keyword">int</span> mi, <span class="keyword">double</span> md) &#123; myInt = mi; myDouble = md;&#125;;</span><br><span class="line">    MyClass() &#123; myInt = <span class="number">1</span>; myDouble = <span class="number">0.2</span>;&#125;;</span><br><span class="line">    ~MyClass() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"bye!"</span>; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h1><p>const成员函数是指，保证该成员函数不会改变调用的对象，声明和定义const成员函数需要将const限定符加在成员函数的后边：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">void</span> MyClass::show() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// function body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以这种方式声明和定义的类函数即const成员函数，应该尽可能地将成员函数修饰为const，只要该类的方法不修改调用对象。</p><h1 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h1><p><code>this</code>指针在类的成员函数中，用来作为指向<strong>调用类对象自身</strong>的指针，即它指向自己的类的地址。我们上面的构造函数中的 <code>myInt = mi;</code> 这一语句，其实这里的 <code>myInt</code> 就是 <code>this-&gt;myInt</code> 的简写，因为在类中，可以直接用成员变量简单地替换 <code>this-&gt;</code> 成员变量。</p><p>this指针在只操作自身类内成员的时候不会有特别多的作用，因为都可以省略它，但是一旦我们的成员函数涉及到两个及以上的类的对象时，this就发挥了很大的作用。例如我们有一个compare函数，用于比较两个MyClass类的实例的哪一个的myInt值更大，那么我们必然需要另一个MyClass的实例作为参数，然后让它的myInt和自己的myInt比较，然后返回myInt较大的那个MyClass的引用，所以可以这样声明这个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass &amp; MyClass::compare(<span class="keyword">const</span> MyClass &amp; myClass) <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure><p>函数定义中涉及到三个const：</p><ul><li>第一个const：表明返回值是一个MyClass，显然不能被改变，所以可以时const的</li><li>第二个const：传入的MyClass实例只是用于比较的，不需要改变，所以使用const</li><li>第三个const：由于成员函数不改变调用类对象，所以是const的成员函数</li></ul><p>比较myInt的函数可以使用this来这样实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass &amp; MyClass::compare(<span class="keyword">const</span> MyClass &amp; myClass) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(myClass.myInt &gt; <span class="keyword">this</span>-&gt;myInt)</span><br><span class="line">    <span class="keyword">return</span> myClass;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然，上边的 <code>this-&gt;myInt</code> 可以使用 <code>myInt</code> 直接简写，而返回自己调用类对象的时候，就只能用 this 来称呼了，而且需要注意的是，返回的是一个MyClass的引用，从而需要使用<code>*this</code>而不是直接返回<code>this</code>，因为<code>this</code>是<strong>指针</strong></p><h1 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h1><p>类和其他数据结构一样，都可以创建数组，对象的数组即可以存储多个类对象，只需要像下边这样声明它们：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyClass myClasses[<span class="number">3</span>];</span><br><span class="line">myClasses[<span class="number">0</span>].show();</span><br><span class="line">myClasses[<span class="number">1</span>].compare(myClasses[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><p>运算符重载即将C++中的运算符重载扩展到用户自定义的类型，例如，+这个运算符，只能用于整形、浮点型、字符串等基本的数据结构相加，但是我们可以通过用户的定义，将其用于两个类的对象相加，两个数组相加等等，编译器会根据操作数和目的数的类型决定使用哪种定义。</p><h2 id="运算符重载的写法"><a href="#运算符重载的写法" class="headerlink" title="运算符重载的写法"></a>运算符重载的写法</h2><p>运算符重载的格式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">op</span> <span class="params">(arguments)</span></span>;</span><br></pre></td></tr></table></figure><p>比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> +( ); <span class="comment">// 重载+运算符</span></span><br><span class="line"><span class="keyword">operator</span> *( ); <span class="comment">// 重载*运算符</span></span><br><span class="line"><span class="keyword">operator</span> [ ]( ); <span class="comment">// 重载[]运算符</span></span><br></pre></td></tr></table></figure><h2 id="一个运算符重载的例子"><a href="#一个运算符重载的例子" class="headerlink" title="一个运算符重载的例子"></a>一个运算符重载的例子</h2><p>假设我们有一个时间类Time，由两个私有成员变量 hours、minutes 来代表小时和分钟，我们来实现Time类对象的相加逻辑。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> hours;</span><br><span class="line">    <span class="keyword">int</span> minutes;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Time;</span><br><span class="line">    Time(<span class="keyword">int</span> h, <span class="keyword">int</span> m=<span class="number">0</span>);</span><br><span class="line">    Time <span class="keyword">operator</span> + (<span class="keyword">const</span> Time &amp; t) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Time::Time()</span><br><span class="line">&#123;</span><br><span class="line">hours = minutes = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Time::Time(<span class="keyword">int</span> h, <span class="keyword">int</span> m)</span><br><span class="line">&#123;</span><br><span class="line">    hours = h;</span><br><span class="line">    minutes = m;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Time Time::<span class="keyword">operator</span> + (<span class="keyword">const</span> Time &amp; t) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Time sum;</span><br><span class="line">    sum.minutes = minutes + t.minutes;</span><br><span class="line">    sum.hours = hours + t.hours + sum.minutes / <span class="number">60</span>;</span><br><span class="line">    sum.minutes %= <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这个重载的+运算符可以将两个Time的对象像其他一般数据类型一样进行相加：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Time time1;</span><br><span class="line">Time time2;</span><br><span class="line">Time total = time1 + time2;</span><br></pre></td></tr></table></figure><h2 id="运算符重载的限制"><a href="#运算符重载的限制" class="headerlink" title="运算符重载的限制"></a>运算符重载的限制</h2><p>多数C++运算符都可以用这样的方式重载。重载的运算符（有些例外情况）不必是成员函数，但必须至少有一个操作数是用户定义的类型。C++运算符重载的限制如下：</p><ul><li>重载后的运算符必须至少有一个操作数是用户定义的类型，这将防止用户为标准类型重载运算符因此，例如不能将减法运算符重载为计算两个 double 值的和，而不是它们的差。</li><li>使用运算符时不能违反运算符原来的句法规则。例如，不能将求模运算符（%）重载成使用一个操作数的运算</li><li>不能修改运算符的优先级。例如，如果将加号运算符重载成将两个类相加，则新的运算符与原来的加号具有相同的优先级</li><li>不能创建新运算符。例如，不能定义 <code>operator **()</code> 函数来表示求幂</li><li>不能重载下面的运算符<ul><li><code>sizeof</code> ：sizeof 运算符</li><li><code>.</code> ：成员运算符</li><li><code>*</code> ：成员指针运算符</li><li><code>::</code> ：作用域解析运算符</li><li><code>? :</code> ：条件运算符</li><li><code>typeid</code>：一个RTTI运算符</li><li><code>const_cast</code>：强制类型转换运算符</li><li><code>dynamic_cast</code>：强制类型转换运算符</li><li><code>reinterpret_cast</code>：强制类型转换运算符</li><li><code>static_cast</code>：强制类型转换运算符</li></ul></li><li>大多数运算符都可以通过成员函数或者非成员函数进行重载，但是如下的运算符只能通过成员函数进行重载：<ul><li><code>=</code>：赋值运算符</li><li><code>( )</code>：函数调用运算符</li><li><code>[ ]</code>：下标运算符</li><li><code>-&gt;</code>：通过指针访问类成员运算符</li></ul></li></ul><p>可以重载的运算符</p><table><thead><tr><th><code>+</code></th><th><code>-</code></th><th><code>*</code></th><th><code>/</code></th><th><code>%</code></th><th><code>^</code></th></tr></thead><tbody><tr><td><code>&amp;</code></td><td>`</td><td>`</td><td><code>~=</code></td><td><code>!</code></td><td><code>=</code></td></tr><tr><td><code>&gt;</code></td><td><code>+=</code></td><td><code>-=</code></td><td><code>*=</code></td><td><code>/=</code></td><td><code>%=</code></td></tr><tr><td><code>^=</code></td><td><code>&amp;=</code></td><td>`</td><td>=`</td><td><code>&lt;&lt;</code></td><td><code>&gt;&gt;</code></td></tr><tr><td><code>&lt;&lt;=</code></td><td><code>==</code></td><td><code>!=</code></td><td><code>&lt;=</code></td><td><code>&gt;=</code></td><td><code>&amp;&amp;</code></td></tr><tr><td>`</td><td></td><td>`</td><td><code>++</code></td><td><code>--</code></td><td><code>,</code></td></tr><tr><td><code>()</code></td><td><code>[]</code></td><td><code>new</code></td><td><code>delete</code></td><td><code>new[]</code></td><td><code>delete[]</code></td></tr></tbody></table><h1 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h1><p>类的友元函数是非成员函数，其访问权限与成员函数相同。</p><h2 id="一个友元函数的例子"><a href="#一个友元函数的例子" class="headerlink" title="一个友元函数的例子"></a>一个友元函数的例子</h2><p>回到上面的Time类，我们重载<em>运算符：将</em>运算符重载成一个double值乘以一个Time类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Time Time::<span class="keyword">operator</span> * (<span class="keyword">const</span> <span class="keyword">double</span> d) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Time result;</span><br><span class="line">    <span class="keyword">long</span> totalMinutes = hours * d * <span class="number">60</span> + minutes * d;</span><br><span class="line">    result.hours = totalMinutes / <span class="number">60</span>;</span><br><span class="line">    result.minutes = totalMinutes % <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然调用上述<code>*</code>的重载需要这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Time <span class="title">A</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Time <span class="title">B</span><span class="params">(<span class="number">1</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">A = B * <span class="number">2.5</span>;</span><br></pre></td></tr></table></figure><p>相当于调用了这样的运算符重载的成员函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = B.<span class="keyword">operator</span>*(<span class="number">2.5</span>);</span><br></pre></td></tr></table></figure><p>但是，问题来了，如果使用 A = 2.5 * B 就无法成功，这似乎违背了乘法的分配律，这一点虽然并不有违于C++的语法，但是貌似并不用户友好，我们需要告诉使用的人只能用第一种方式而不能用第二种方式。解决这个问题有两个方法：</p><ul><li>使用一个非成员函数来定义反写的情况：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Time <span class="keyword">operator</span> * (<span class="keyword">double</span> d, <span class="keyword">const</span> Time &amp; t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> t * m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这种方式不失为是一种非常好的方法，而且如果有所修改，只需要修改类内的运算符重载即可。</p><ul><li>使用友元函数<br>和上述的思想类似，我们可以定义一个非成员函数，然后这样的重载运算符，从而定义一个double乘以一个Time类对象的操作：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Time <span class="keyword">operator</span> * (<span class="keyword">double</span> d, <span class="keyword">const</span> Time &amp; t);</span><br></pre></td></tr></table></figure><p>但是问题在于类外的非成员函数无法访问类的私有变量。所以友元函数的作用在于可以访问类的私有成员，但是他是一个非成员函数。</p><h2 id="创建友元函数"><a href="#创建友元函数" class="headerlink" title="创建友元函数"></a>创建友元函数</h2><p>创建友元函数的第一步是将其原型放在<strong>类声明</strong>中，并在原型声明前加上关键字 friend：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> Time <span class="keyword">operator</span>*(<span class="keyword">double</span> m, <span class="keyword">const</span> Time t);</span><br></pre></td></tr></table></figure><p>该原型意味着下面两点：</p><ul><li>虽然 <code>operator*()</code> 函数是在类声明中声明的，但它不是成员函数，因此不能使用成员运算符来调用</li><li>虽然 <code>operator*()</code> 函数不是成员函数，但它与成员函数的访问权限相同</li></ul><p>第二步是编写函数定义。因为它不是成员函数，所以不要使用 <code>Time::</code> 限定符。另外，不能在定义中使用关键字 <code>friend</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Time <span class="keyword">operator</span> * (<span class="keyword">double</span> d, <span class="keyword">const</span> Time &amp; t)</span><br><span class="line">&#123;</span><br><span class="line">    Time result;</span><br><span class="line">    <span class="keyword">long</span> totalMinutes = hours * d * <span class="number">60</span> + minutes * d;</span><br><span class="line">    result.hours = totalMinutes / <span class="number">60</span>;</span><br><span class="line">    result.minutes = totalMinutes % <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述定义后即可使用如下的语句来使用乘法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">2.5</span> * B;</span><br></pre></td></tr></table></figure><p>相当于调用友元函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="keyword">operator</span>*(<span class="number">2.5</span>, B);</span><br></pre></td></tr></table></figure><h2 id="成员函数和非成员函数的选择"><a href="#成员函数和非成员函数的选择" class="headerlink" title="成员函数和非成员函数的选择"></a>成员函数和非成员函数的选择</h2><p>对于一般的运算符重载，比如+和-这种不会出现乘法那种左右交换的问题的，有两种解决方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time <span class="keyword">operator</span> + (<span class="keyword">const</span> Time &amp; t) <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">friend</span> Time <span class="keyword">operator</span> + (<span class="keyword">const</span> Time &amp; t1, <span class="keyword">const</span> Time &amp; t2);</span><br></pre></td></tr></table></figure><p>第一种方式是通过this隐式地传递一个参数，另一个使用函数参数显示地传递；第二种方式是两个参数都显示地通过参数传递。在调用 T1 = T2 + T3 时，会分别编译成如下的形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T1 = T2.<span class="keyword">operator</span>+(T3);</span><br><span class="line">T1 = <span class="keyword">operator</span>+(T2, T3);</span><br></pre></td></tr></table></figure><p>但是，<strong>两种方式不能同时定义</strong>，只能选择其中一个，否则会引发二义性的编译错误，基于乘法的例子，显然使用友元函数比较通用。</p><h1 id="类的自动转换和强制类型转换"><a href="#类的自动转换和强制类型转换" class="headerlink" title="类的自动转换和强制类型转换"></a>类的自动转换和强制类型转换</h1><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>C++允许一些强制类型转换，比如强制将double值转换成int值，把double的2.5转换成int会成为2从而丢失0.5。但是如果用户希望进行强制转换只需要使用如下的方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">targetType valueName = (targetType) value;</span><br><span class="line">targetType valueName = targetType (value);</span><br></pre></td></tr></table></figure><h2 id="使用构造函数进行类的自动转换"><a href="#使用构造函数进行类的自动转换" class="headerlink" title="使用构造函数进行类的自动转换"></a>使用构造函数进行类的自动转换</h2><p>假设我们有一个类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> myInt;</span><br><span class="line">    <span class="keyword">double</span> myDouble;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass(<span class="keyword">double</span> d);</span><br><span class="line">    MyClass(<span class="keyword">int</span> i, <span class="keyword">double</span> d);</span><br><span class="line">    MyClass();</span><br><span class="line">    ~MyClass();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">MyClass::MyClass(<span class="keyword">double</span> d)</span><br><span class="line">&#123;</span><br><span class="line">    myDouble = d;</span><br><span class="line">    myInt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">MyClass::MyClass(<span class="keyword">int</span> i, <span class="keyword">double</span> d)</span><br><span class="line">&#123;</span><br><span class="line">    myDouble = d;</span><br><span class="line">    myInt = i;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">MyClass::MyClass()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们尝试将一个double值赋给一个MyClass类对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass myClass;</span><br><span class="line">myClass = <span class="number">2.5</span>;</span><br></pre></td></tr></table></figure><p>这是可以的，首先创建了一个MyClass的对象，然后使用2.5将其初始化，实际上是使用了第一个构造函数 MyClass(double)，这是一个隐式转换的过程，不需要进行强制转换。</p><p>只有接受一个参数的构造函数才能作为转换函数，如果像第二个构造函数那样有两个参数，不能用来转换类型，但是如果第二个参数有默认参数，就可以：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass(<span class="keyword">int</span> i, <span class="keyword">double</span> d = <span class="number">1.5</span>);</span><br></pre></td></tr></table></figure><p>这个可以将一个int值隐式地转换成MyClass类型。</p><p>如果不希望编辑器进行这种隐式转换，可以使用explicit关键词修饰构造函数，这样就无法使用该构造函数进行类型转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="keyword">double</span> d)</span></span>;</span><br></pre></td></tr></table></figure><p>这样会关闭隐式转换，但依然允许显示转换，即使用显式地强制转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyClass myClass;</span><br><span class="line">myClass = MyClass(<span class="number">2.5</span>);</span><br><span class="line">myClass = (MyClass)<span class="number">2.5</span>;</span><br></pre></td></tr></table></figure><h2 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h2><p>上边提到了隐式或者显式地将基本数据类型的数据转换成类对象，接下来的问题是如何将一个类对象转换成其他的基本数据类型，这一点可以通过转换函数来实现。转换函数是用户定义的强制类型转换，需要这样定义：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">operator dateType()；</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ul><li>转换函数必须是类方法</li><li>转换函数不能指定返回类型</li><li>转换函数不能有参数</li></ul><p>比如我们将MyClass转换为一个double类型的变量，需要这样一个成员函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">MyClass::<span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> myDoble;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以这样使用类型转换了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyClass <span class="title">myClass</span><span class="params">(<span class="number">1</span>, <span class="number">2.5</span>)</span></span>;</span><br><span class="line"><span class="keyword">double</span> myDouble = (<span class="keyword">double</span>) myClass;</span><br><span class="line"><span class="keyword">double</span> myDouble = <span class="keyword">double</span> (myClass);</span><br></pre></td></tr></table></figure><h1 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h1><p>复制构造函数接受其所属类的对象作为参数。例如，MyClass类的复制构造函数的原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass(<span class="keyword">const</span> MyClass &amp;);</span><br></pre></td></tr></table></figure><p>在下述情况下，将使用复制构造函数：</p><ul><li>将新对象初始化为一个同类对象</li><li>按值将对象传递给函数</li><li>函数按值返回对象</li><li>编译器生成临时对象</li></ul><p>如果程序没有使用（显式或隐式）复制构造函数，编译器将提供原型，但不提供函数定义；否则，程序将定义一个执行成员初始化的复制构造函数。也就是说，新对象的每个成员都被初始化为原始对象相应成员的值。如果成员为类对象,则初始化该成员时，将使用相应类的复制构造函数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;类与接口&quot;&gt;&lt;a href=&quot;#类与接口&quot; class=&quot;headerlink&quot; title=&quot;类与接口&quot;&gt;&lt;/a&gt;类与接口&lt;/h1&gt;&lt;p&gt;类是一种将抽象转换为用户定义类型的C++工具，它将数据表示和操作数据的方法组合成一个整洁的包。接口提供给我们从外部访问类与类
      
    
    </summary>
    
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/categories/C/"/>
    
    
      <category term="学习笔记" scheme="https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【算法】（一）排序算法</title>
    <link href="https://blogs.littlegenius.xin/2019/08/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%B8%80%E6%8E%92%E5%BA%8F/"/>
    <id>https://blogs.littlegenius.xin/2019/08/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%B8%80%E6%8E%92%E5%BA%8F/</id>
    <published>2019-08-24T15:45:32.000Z</published>
    <updated>2019-08-24T15:50:37.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序算法的分类"><a href="#排序算法的分类" class="headerlink" title="排序算法的分类"></a>排序算法的分类</h1><ul><li>比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</li><li>非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。      </li></ul><p><img src="http://cdn.littlegenius.xin/Algorithm1-1.png" alt="算法的分类"></p><h1 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/Algorithm1-2.png" alt="算法的复杂度" title="">                </div>                <div class="image-caption">算法的复杂度</div>            </figure> <h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><ul><li>稳定：如果a原本在b前面，而a=b，排序之后 a 仍然在 b 的前面。</li><li>不稳定：如果a原本在b的前面，而a=b，排序之后 a      可能会出现在 b 的后面。</li><li>时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li><li>空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 </li></ul><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 </p><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ul><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序（Selection-sort）是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录      R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong>。</p><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k      趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li><li>缩小增量间隔的方法      grap=[grap/2]</li></ul><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><ul><li>从数列中挑出一个元素，称为      “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><ul><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ul><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ul><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序（Bucket sort）是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p><ul><li>设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序；</li><li>从不是空的桶里把排好序的数据拼接起来。 </li></ul><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p><ul><li>取得数组中的最大数，并取得位数</li><li>arr为原始数组，从最低位开始取每个位组成radix数组</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点） </li></ul><p><strong>参考</strong>：<a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener">https://www.cnblogs.com/onepixel/articles/7674659.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;排序算法的分类&quot;&gt;&lt;a href=&quot;#排序算法的分类&quot; class=&quot;headerlink&quot; title=&quot;排序算法的分类&quot;&gt;&lt;/a&gt;排序算法的分类&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因
      
    
    </summary>
    
    
      <category term="算法" scheme="https://blogs.littlegenius.xin/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="学习笔记" scheme="https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="算法" scheme="https://blogs.littlegenius.xin/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构】（五）堆</title>
    <link href="https://blogs.littlegenius.xin/2019/08/24/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%BA%94%E5%A0%86/"/>
    <id>https://blogs.littlegenius.xin/2019/08/24/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%BA%94%E5%A0%86/</id>
    <published>2019-08-24T07:03:50.000Z</published>
    <updated>2019-08-24T07:19:43.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h1><p><strong>堆</strong>（Heap）又称为<strong>优先队列</strong>（priority queue），在队列的基础上，堆允许所有队列中的元素不一定按照<strong>先进先出</strong>（FIFO）的规则进行，而是使得每个元素有一定的优先级，优先级高的先出队列。</p><blockquote><p>这类数据结构属于计算机科学中最雅致的一种</p></blockquote><p>优先队列至少存在两个重要的操作：</p><ul><li><code>insert</code>：插入，使得数据入队列，是一种有约束的enqueue操作</li><li><code>deleteMin</code>：删除最小项，找出、返回并删除优先队列中最小的元素，也就是最大优先级的元素，是一种有约束的dequeue操作</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-1.png" alt="优先队列" title="">                </div>                <div class="image-caption">优先队列</div>            </figure><h1 id="堆的简单实现"><a href="#堆的简单实现" class="headerlink" title="堆的简单实现"></a>堆的简单实现</h1><p>有几种简单而明显的方法实现优先队列。</p><ul><li>简单链表：在表头以O(1)执行插入操作，遍历该链表以O(N)删除最小元</li><li>始终有序的链表：插入代价以O(N)进行，删除操作以O(1)进行</li><li>二叉查找树：对插入和删除两种操作的平均运行时间都是O(log)。尽管插入是随机的，而删除则不是，但是并不影响这个结论，反复除去左子树中的结点（最小值）损害了树的平衡，使得右子树加重。在最坏情形下，即将左子树删空的情形下，右子树拥有的元素最多也就是它应具有的两倍，这只是在其期望的深度上加了一个小常数</li><li>ALV树：可能有些过分，因为它支持大量并不需要的操作</li></ul><h1 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h1><p><strong>二叉堆</strong>（binary heap）是一种对于优先队列的实现，可以简称为堆</p><h2 id="结构性质"><a href="#结构性质" class="headerlink" title="结构性质"></a>结构性质</h2><p>堆是一棵<strong>完全二叉树</strong>（complete binary tree），即所有节点都必须有左右两个子节点，除了最后一排元素从左向右填入，直到没有元素为止。</p><p>很显然，一棵高为h的完全二叉树有 2^h 到 2^(h+1)-1 个节点，即其高度为 logN 向下取整。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-2.png" alt="二叉堆" title="">                </div>                <div class="image-caption">二叉堆</div>            </figure><p>完全二叉树的好处在于其规律性，可以使用一个数组而不需要链表来表示</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-3.png" alt="二叉堆的数组表示" title="">                </div>                <div class="image-caption">二叉堆的数组表示</div>            </figure><p>对于数组中任一位置 i 上的元素，其左儿子在位置 2i 上，右儿子在左儿子后的单元 (2i+1) 上，它的父亲则在位置 i/2 向下取整上。</p><p>因此，不仅不需要链，而且遍历该树所需要的操作也极简单，在大部分计算机上都可能运行得非常快。唯一问题是最大的堆的大小需要事先估计。</p><h2 id="堆序性质"><a href="#堆序性质" class="headerlink" title="堆序性质"></a>堆序性质</h2><p>使操作可以快速执行的性质是<strong>堆序性质</strong>（heap-order property）：对于每一个节点X，X的父节点中的键小于等于X中的键，除没有父节点根节点外。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-4.png" alt="二叉堆" title="">                </div>                <div class="image-caption">二叉堆</div>            </figure><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="insert插入"><a href="#insert插入" class="headerlink" title="insert插入"></a>insert插入</h3><p>将待插入的元素首先放置在最后一个位置上，以保证他是一个完全二叉树，然后将该元素与其父节点（i/2向下取整）比较，如果比其父节点小，就将两者互换，互换后再和新的父节点比较，这种方式称为<strong>上滤</strong>（percolate up），得到一个小顶堆（min heap），如果比较的时候是较大的值向上走，就会得到一个大顶堆（max heap） </p><p>比如向一个小顶堆中插入元素14的操作：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-5.png" alt="小顶堆的插入" title="">                </div>                <div class="image-caption">小顶堆的插入</div>            </figure><h3 id="deleteMin删除"><a href="#deleteMin删除" class="headerlink" title="deleteMin删除"></a>deleteMin删除</h3><p>找出、返回并删除最小元非常简单，最小元就是根节点处的元素，将其返回并删除。接下来是处理这个B。首先拿下最后一个元素X，如果元素X比B的两个子节点都小，可以直接将X插入到B的位置，如果X比B的两个子节点中的任意一个大，就不能插入，此时找到两个子节点中较小的那个放到B处，B转而移至这个子结点处。重复如上的步骤直到X可以插入B处为止。这个操作成为<strong>下滤</strong>（percolate down）</p><p>比如从一个小顶堆中删除根节点</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-6.png" alt="从小顶堆中删除" title="">                </div>                <div class="image-caption">从小顶堆中删除</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-7.png" alt="从小顶堆中删除" title="">                </div>                <div class="image-caption">从小顶堆中删除</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-8.png" alt="从小顶堆中删除" title="">                </div>                <div class="image-caption">从小顶堆中删除</div>            </figure><h3 id="decreaseKey"><a href="#decreaseKey" class="headerlink" title="decreaseKey"></a>decreaseKey</h3><p><code>decreaseKey(p, A)</code> 操作减小在位置p处的元素的值，减少量为A，可以理解为调高了某个元素的优先级。操作破坏了堆的性质，从而需要上滤操作进行堆的调整。</p><h3 id="increaseKey"><a href="#increaseKey" class="headerlink" title="increaseKey"></a>increaseKey</h3><p><code>increaseKey(p, A)</code> 操作增加在位置p处的元素的值，增加量为A，可以理解为降低了某个元素的优先级。操作破坏了堆的性质，从而需要下滤操作进行堆的调整。</p><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p><code>remove(p)</code> 操作删除在堆中位置p处的节点，这种操作可以通过连续执行 <code>decreaseKey(p, ∞)</code> 和 <code>deleteMin()</code> 完成，可以理解马上删除某个一般优先级的元素</p><h3 id="buildHeap"><a href="#buildHeap" class="headerlink" title="buildHeap"></a>buildHeap</h3><p>即将一个原始集合构建成二叉堆，这个构造过程即进行N次连续的<code>insert</code>操作完成</p><p><strong>定理</strong>：包含 2^(h+1)-1 个节点且高度为h的理想二叉树（perfect binary tree）的节点的高度和为 2^(h+1)-1-(h+1)</p><h1 id="d堆"><a href="#d堆" class="headerlink" title="d堆"></a>d堆</h1><p><strong>d堆</strong>（d-Heaps）是二叉堆的简单推广，它与二叉堆很像，但是每个节点都有d个子节点，所以二叉堆是d为2的d堆。d堆是完全d叉树。比如下边的一个3堆。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-9.png" alt="一个3堆" title="">                </div>                <div class="image-caption">一个3堆</div>            </figure><p>d堆比二叉堆浅很多，其insert的运行时间改进到 O(logdN) 。但是deleteMin操作比较费时，因为要在d个子节点中找到最小的一个，需要进行d-1次比较。d堆无法进行find操作，而且将两个堆合二为一是很困难的事情，这个附加操作为merge合并。</p><p><strong>注意！</strong>在寻找节点的父节点、子节点的时候，乘法和除法都有因子d。如果d是一个2的幂，则可以通过使用二进制的<strong>移位</strong>操作计算，这在计算机中是非常省时间的。但是如果d不是一个2的幂，则使用一般的乘除法计算，时间开销会急剧增加。有证据显示，实践中，堆可以胜过二叉堆</p><h1 id="左式堆"><a href="#左式堆" class="headerlink" title="左式堆"></a>左式堆</h1><p>这些高级的数据结构很难使用一个数据结构来实现，所以一般都要用到链式数据结构，这种结构可能会使得其操作变慢。</p><h2 id="左式堆的定义"><a href="#左式堆的定义" class="headerlink" title="左式堆的定义"></a>左式堆的定义</h2><p><strong>零路径长</strong>（null path length）npl(X)：定义为从一个X节点到其不具有两个子节点的子节点的最短路径长，即具有0个或者1个子节点的节点npl=0，npl(null)=-1，任意节点的零路径长都比其各个子节点中零路径长最小值多1。</p><p><strong>左式堆</strong>（leftist heap）是指对于任意一个节点X，其左子节点的零路径长都大于等于其右子节点的零路径长。很显然，左式堆趋向于加深左路径。比如下边的两个堆，只有左边的是左式堆，堆的节点标示的是该节点的零路径长。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-10.png" alt="左式堆" title="">                </div>                <div class="image-caption">左式堆</div>            </figure><p>左式堆的实现中，需要有四个值：数据、左指针、右指针和零路径长。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LeftistHeap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Object data;</span><br><span class="line">    LeftistHeap* leftChild;</span><br><span class="line">    LeftishHeap* rightChild;</span><br><span class="line">    <span class="keyword">int</span> npl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定理</strong>：在右路径上有r个节点的左式堆必然至少有 2^r-1 个节点</p><h2 id="左式堆的合并"><a href="#左式堆的合并" class="headerlink" title="左式堆的合并"></a>左式堆的合并</h2><p><code>merge</code>是左式堆的基本操作，<code>insert</code>插入可以看成是一个单节点的堆与一个大堆的<code>merge</code>，<code>deleteMin</code>删除最小值操作可以看成是首先返回、删除根节点，然后将根节点的左右子树进行<code>merge</code>。所以<code>merge</code>是左式堆的基本操作。</p><p>假设现在有两个非空的左式堆H1和H2，merge操作递归地进行如下的步骤：</p><ul><li>将H1和H2中根节点较的堆（比如是H2）与根节点较小的堆（比如是H1）的右子堆进行merge</li><li>让新的merge的堆成为根节点较小的堆（H1）的右字堆</li><li>如果在根结点处出现左右子堆不符合左式堆的条件的情况，互换左右子堆的位置并更新npl的值</li></ul><p>例如如下的两个堆：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-11.png" alt="合并两个左式堆" title="">                </div>                <div class="image-caption">合并两个左式堆</div>            </figure><p>将H2与H1的右子树（8–17–26）进行merge操作，此时（8–17–26）和H2的merge操作中又需要（8–17–26）和H2的右子堆（7–37–18）进行merge操作……如此递归得到如下的堆：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-12.png" alt="合并两个左式堆" title="">                </div>                <div class="image-caption">合并两个左式堆</div>            </figure><p>然后根据递归的最外层（回到H1和H2的merge的第二步），将上边合并的堆成为H1的右子堆</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-13.png" alt="合并两个左式堆" title="">                </div>                <div class="image-caption">合并两个左式堆</div>            </figure><p>此时根节点（3）处出现了左右子堆不符合左式堆的情况，互换左右子堆并更新零路径长的值</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-14.png" alt="合并两个左式堆" title="">                </div>                <div class="image-caption">合并两个左式堆</div>            </figure><h1 id="斜堆"><a href="#斜堆" class="headerlink" title="斜堆"></a>斜堆</h1><p><strong>斜堆</strong>（skew heap）是左式堆的自调节形式，实现起来极其简单。斜堆和左式堆的关系类似于伸展树和AVL树之间的关系。斜堆是具有堆序的二叉树，但是不存在对树的结构的现限制。不同于左式堆，关于任意结点的零路径长的任何信息都不保留。斜堆的右路径在任何时刻都可以任意长，因此，所有操作的最坏情形运行时间均为O(N)。然而，正如伸展树一样，可以证明对任意M次连续操作，总的最坏情形运行时间是 O(MlogN)。因此，斜堆每次操作的<strong>摊还开销</strong>（amortized cost）为O(logN)</p><h2 id="斜堆的合并"><a href="#斜堆的合并" class="headerlink" title="斜堆的合并"></a>斜堆的合并</h2><p>斜堆的基本操作也是merge合并，和左式堆的合并相同，但是不需要对不满足左右子堆的左式堆条件的节点进行左右子堆的交换。斜堆的交换是无条件的，除右路径上所有节点的最大者不交换它的左右儿子外，都要进行这种交换。</p><p>比如将上述的H1和H2进行merge合并操作</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-15.png" alt="合并两个斜堆" title="">                </div>                <div class="image-caption">合并两个斜堆</div>            </figure><p>首先进行第一步，除了交换左右子树的操作与左式堆不同，其他的操作都相同</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-16.png" alt="合并两个斜堆" title="">                </div>                <div class="image-caption">合并两个斜堆</div>            </figure><p>将合并的堆作为H1的右子堆并交换左右子堆，得到合并后的斜堆</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-17.png" alt="合并两个斜堆" title="">                </div>                <div class="image-caption">合并两个斜堆</div>            </figure><h1 id="二项队列"><a href="#二项队列" class="headerlink" title="二项队列"></a>二项队列</h1><p><strong>二项队列</strong>（binomial queue）支持merge、insert和deleteMin三种操作，并且每次操作的最坏情形运行时间为O(logN)，插入操作平均花费常数时间。</p><h2 id="二项队列的结构"><a href="#二项队列的结构" class="headerlink" title="二项队列的结构"></a>二项队列的结构</h2><p>二项队列不是一棵堆序的树，而是堆序的树的集合，成为<strong>森林</strong>（forest）。堆序树中的每一棵都是有约束的<strong>二项树</strong>（binomial tree）。二项树是每一个高度上至多存在一棵二项树。高度为0的二项树是一棵单节点树，高度为k的二项树Bk通过将一棵二项树Bk-1附接到另一棵二项树Bk-1的根上而构成的。如下图的二项树B0、B1、B2、B3和B4。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-18.png" alt="二项树" title="">                </div>                <div class="image-caption">二项树</div>            </figure><p>可以看到二项树Bk由一个带有儿子B0，B1，……，Bk-1的根组成。高度为k的二项树恰好有2^k个节点，而在深度d处的节点数为二项系数Cdk。</p><p>我们可以使用二项树的集合唯一地表示任意大小的优先队列。以大小为13的队列为例，13的二进制表示为1101，从而我们可以使用二项树森林B3、B2、B0表示，即二进制表示的数中，第k位为1表示Bk树出现，第k位为0表示Bk树不出现。比如上述的堆H1和堆H2可以表示为如下的两个二项队列：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-19.png" alt="H1和H2的二项队列表示" title="">                </div>                <div class="image-caption">H1和H2的二项队列表示</div>            </figure><h2 id="二项队列的合并"><a href="#二项队列的合并" class="headerlink" title="二项队列的合并"></a>二项队列的合并</h2><p>二项队列额merge合并操作非常简单，以上边的二项队列H1、H2为例。需要将其合并成一个大小为13的队列，即B3、B2、B0。</p><p>首先H2中有一个B0，H1中没有，所以H2中的B0可以直接作为新的队列的B0的树</p><p>其次H1和H2中两个B1的树可以合并成一个新的B2的树，只需要将其中根节点较小的堆挂到根节点较大的堆的根节点上。这样就得到了三棵B2堆，将其中根节点最大的堆直接放到新队列中成为它的B2堆。</p><p>最后将两个B2堆合并成一个新队列中的B3堆。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-20.png" alt="二项队列的合并" title="">                </div>                <div class="image-caption">二项队列的合并</div>            </figure><p>二项队列的deleteMin很简单，只需要比较队列中所有二项堆的根节点，返回和删除最小的值即可，时间复杂度为O(logN)，然后进行一次merge操作，也可以使用一个单独的空间每次记录最小值，这样就可以以O(1)的时间返回。 </p><h2 id="二项队列的实现"><a href="#二项队列的实现" class="headerlink" title="二项队列的实现"></a>二项队列的实现</h2><p>森林中树的实现采用“左子右兄弟”的表示方法，然后二项队列可以使用一个数组来记录森林中每个树的根节点。</p><p>例如上边的合成的二项队列可以表示成如下的样子：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure6-21.png" alt="二项堆列的实现" title="">                </div>                <div class="image-caption">二项堆列的实现</div>            </figure><h1 id="标准库中的优先队列"><a href="#标准库中的优先队列" class="headerlink" title="标准库中的优先队列"></a>标准库中的优先队列</h1><p>STL中，二叉堆是通过<code>priority_queue</code>模板类实现的，在头文件<code>queue</code>中，STL实现一个大顶堆而不是小顶堆，其关键的成员函数如下：</p><ul><li><code>void push( const object &amp; x );</code></li><li><code>const Object &amp; top( ) const;</code></li><li><code>void pop( );</code></li><li><code>bool empty( );</code></li><li><code>void clear( );</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;堆（Heap）&quot;&gt;&lt;a href=&quot;#堆（Heap）&quot; class=&quot;headerlink&quot; title=&quot;堆（Heap）&quot;&gt;&lt;/a&gt;堆（Heap）&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;堆&lt;/strong&gt;（Heap）又称为&lt;strong&gt;优先队列&lt;/strong&gt;（p
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://blogs.littlegenius.xin/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习笔记" scheme="https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/tags/C/"/>
    
      <category term="数据结构" scheme="https://blogs.littlegenius.xin/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构】（四）散列</title>
    <link href="https://blogs.littlegenius.xin/2019/08/19/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%9B%9B%E6%95%A3%E5%88%97/"/>
    <id>https://blogs.littlegenius.xin/2019/08/19/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%9B%9B%E6%95%A3%E5%88%97/</id>
    <published>2019-08-19T15:22:06.000Z</published>
    <updated>2019-08-19T15:30:28.470Z</updated>
    
    <content type="html"><![CDATA[<p><strong>哈希</strong>（hashing）又称散列，是实现散列表的技术。散列是一种用于以常数平均时间执行插入、删除和查找的技术，因此涉及到元素间排序信息的操作不会得到支持，如树的<code>findMin</code>、<code>findMax</code>以及按照顺序打印列表这些操作散列是不支持的。</p><h1 id="散列的基本思想"><a href="#散列的基本思想" class="headerlink" title="散列的基本思想"></a>散列的基本思想</h1><p>散列是一个固定大小的数组，存储的是键值对（Key–Value），键一般是好操作的数据，值一般存储比较大的实际意义强的数据，键的存在是便于使用键进行数据的查找。</p><p>散列的基本思想是使用一个对应关系（映射关系），这里称之为<strong>散列函数</strong>（hashing function），将哈希表的存储位置（0到TableSize-1）与键做一个对应，理想情况下是得到一个一一映射。但是这是不可能的，从而还需要确定一个方案来解决当两个键都被对应到同一个存储位置上时的情况，这个过程叫做解决冲突（collision）</p><h1 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h1><ul><li>如果键时整数，一般使用 <code>Key mod TableSize</code> 作为对应的索引。通常，为了使哈希的分布均匀，通常采取素数大小的哈希表，当输入的键是随机整数的时候，散列函数不仅运算简单而且键的分配也很均匀</li><li>如果键时字符串<ul><li>一种策略是将字符串中字符的ASCLL码值求和，然后使用整数策略，这种方式不够均匀</li><li>一种策略是取字符串的前几位的ASCLL码值求和，然后使用整数策略，这种方式不够均匀</li><li>一种较好的策略是递归地求 <code>h = k0+37 k1+37^2 k2</code> 作为键，或者对一些选取的字符（而不是整个字符串）采用如上的策略</li></ul></li></ul><h1 id="解决冲突的方法"><a href="#解决冲突的方法" class="headerlink" title="解决冲突的方法"></a>解决冲突的方法</h1><p>无论如何设计散列函数，都能保证对于任何一个键都可以找到唯一的存储索引而不发生冲突，所以解决冲突是哈希实现的关键</p><h2 id="分离链接法"><a href="#分离链接法" class="headerlink" title="分离链接法"></a>分离链接法</h2><p>分离链接法（separate chaining）将散列到同一个值的所有元素保存到一个链表中</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure5-1.png" alt="分离链接法" title="">                </div>                <div class="image-caption">分离链接法</div>            </figure><p>这种方式的缺点是使用了一些链表，所以给新单元分配地址需要较多的时间开销。</p><h2 id="探测散列表"><a href="#探测散列表" class="headerlink" title="探测散列表"></a>探测散列表</h2><p>一般为了减少使用链表带来的较大的时间开销，通常避免使用链表，而将所有的数据都放入表内，所以这种方式需要散列表要比较大才行。一般要求装填的数据和总数据含量之比小于0.5，这样的表成为探测散列表（probing hash tables）。</p><p>探测散列表的散列函数为 h(x)=(hash(x)+f(i)) mod TableSize 且 f(0)=0，说白了就是如果应该在的位置冲突了，就按照一定的规律去找下一个空位置，以此类推。根据寻找下一个空位置的方式不同可以分为如下的几种探测方式。</p><h3 id="线性探测（Linear-Probing）"><a href="#线性探测（Linear-Probing）" class="headerlink" title="线性探测（Linear Probing）"></a>线性探测（Linear Probing）</h3><p>f(i)=i，当一个位置出现冲突时，顺序查找下一个位置，直到找到一个空位置为止</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure5-2.png" alt="线性探测" title="">                </div>                <div class="image-caption">线性探测</div>            </figure><h3 id="平方探测（Quadratic-Probing）"><a href="#平方探测（Quadratic-Probing）" class="headerlink" title="平方探测（Quadratic Probing）"></a>平方探测（Quadratic Probing）</h3><p>f(i)=i^2，即冲突函数为二次函数的探测方法</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure5-3.png" alt="二次探测" title="">                </div>                <div class="image-caption">二次探测</div>            </figure><p>关于二次探测，这里有一个<strong>定理</strong>：如果表的大小是素数，那么当表至少有一半是空的时候，总能够插入一个新的元素</p><h2 id="双散列（Double-Hashing）"><a href="#双散列（Double-Hashing）" class="headerlink" title="双散列（Double Hashing）"></a>双散列（Double Hashing）</h2><p>双散列（Double Hashing）也是一种解决冲突的方式，对于双散列，一种流行的方式是选择 f(i)=i*hash’(x), hash’(x)=R-(x  mod R), 其中R通常选取一个素数。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure5-4.png" alt="双散列" title="">                </div>                <div class="image-caption">双散列</div>            </figure><h2 id="再散列（Rehashing）"><a href="#再散列（Rehashing）" class="headerlink" title="再散列（Rehashing）"></a>再散列（Rehashing）</h2><p>再散列（Rehashing）的思想是当一个散列表将要被耗尽时，建立一个新的比原来的表大约两倍的表并且使用新的散列函数，将原表中的数据通过新的散列函数安排到新表中。例如下边的例子：</p><p>首先有一个大小为7的散列表：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure5-5.png" alt="再散列例子" title="">                </div>                <div class="image-caption">再散列例子</div>            </figure><p>向这个表中插入数据23，得到了如下的表，由于此时数据已占用超过70%，从而创建一个新的大小为17的散列表。新的表的选取，是按照原来的散列表的二倍的后边第一个素数来规定。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure5-6.png" alt="再散列例子" title="">                </div>                <div class="image-caption">再散列例子</div>            </figure><p>将原来哈希表中的五个数据根据 key mod 17 再重新计算位置，添加到新的散列中去</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure5-7.png" alt="再散列例子" title="">                </div>                <div class="image-caption">再散列例子</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;哈希&lt;/strong&gt;（hashing）又称散列，是实现散列表的技术。散列是一种用于以常数平均时间执行插入、删除和查找的技术，因此涉及到元素间排序信息的操作不会得到支持，如树的&lt;code&gt;findMin&lt;/code&gt;、&lt;code&gt;findMax&lt;/code&gt;
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://blogs.littlegenius.xin/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习笔记" scheme="https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/tags/C/"/>
    
      <category term="数据结构" scheme="https://blogs.littlegenius.xin/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构】（三）树</title>
    <link href="https://blogs.littlegenius.xin/2019/08/19/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%B8%89%E6%A0%91/"/>
    <id>https://blogs.littlegenius.xin/2019/08/19/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%B8%89%E6%A0%91/</id>
    <published>2019-08-18T16:16:53.000Z</published>
    <updated>2019-08-19T15:30:22.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="树的实现"><a href="#树的实现" class="headerlink" title="树的实现"></a>树的实现</h2><p>实现树时，对于每一个节点，除了存储该节点的数据以外，还需要存储一些外链。</p><p>一个典型的存储方式是：左孩子右兄弟法，即对于每一个节点，存储节点的数据、指向其孩子中最左边的孩子的指针、指向其紧邻的右侧的兄弟节点的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Object element;</span><br><span class="line">    TreeNode * firstChild;</span><br><span class="line">    TreeNode * nextSiling;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如下边的这棵树通过这种方式表现的结果是这样的：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure4-1.png" alt="采用“左子右兄弟”表示树" title="">                </div>                <div class="image-caption">采用“左子右兄弟”表示树</div>            </figure><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>二叉树（binary tree）是一棵每个节点都不能有多于两个儿子的树</p><h2 id="二叉树的特点"><a href="#二叉树的特点" class="headerlink" title="二叉树的特点"></a>二叉树的特点</h2><ul><li>二叉树第i层上至多有 2i-1 个节点</li><li>深度为k的二叉树至多有 2k-1 个节点</li><li>对于一棵非空二叉树，如果其叶子节点数为n0，度为2的节点数为n2，则n0=n2+1</li><li>具有n个节点的完全二叉树的深度为 [log2n]+1      (向下取整数)</li><li>如果对于n个节点的完全二叉树，第 i&gt;0      的节点，其父节点为 [(i-1)/2] (向下取整)</li></ul><p>二叉树的一个性质是平均二叉树的深度要比结点个数N小得多，这个性质有时很重要。分析表明，这个平均深度为O(√N)，而对于特殊类型的二叉树，即二叉查找树( binary search tree)，其深度的平均值是O(logN)。当然极端的树的深度也可以大到N-1。</p><h2 id="二叉树的实现"><a href="#二叉树的实现" class="headerlink" title="二叉树的实现"></a>二叉树的实现</h2><p>由于二叉树的每个节点最多有两个儿子，所以可以直接连接到它们。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Object element;</span><br><span class="line">    BinaryNode * left;</span><br><span class="line">    BinaryNode * red;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><p>二叉查找树（Binary Search Trees）是二叉树，它的特点是：对于任何一个节点X，其左子树中的所有节点的值都小于该节点X，其右子树中的所有节点的值都大于该节点X。如下图中的左边就是一棵二叉查找是，而右侧不是：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure4-2.png" alt="二叉查找树" title="">                </div>                <div class="image-caption">二叉查找树</div>            </figure><h2 id="重要的方法与其实现"><a href="#重要的方法与其实现" class="headerlink" title="重要的方法与其实现"></a>重要的方法与其实现</h2><ul><li><code>isEmpty</code>：是否为空树，这一点很重要，一般在进行树的相关操作时都会先确定是否是一个空树，只要指向根节点的指针为<code>NULL</code>，就表示是一个空树</li><li><code>contains</code>：是否包含某项，在确定树非空后，查找是否包含某个项，将目标项与根节点进行比较开始，如果比该节点大，就从右子树查找，如果比该节点小，就从左子树查找，如果出现相等的则表示包含该项，如果一直不相等且无子树可以继续查找，则不包含此项</li><li><code>findMin</code>：找到最小值，一直找左子树，直到找到没有左子树的左子树最左边的节点就是最小值</li><li><code>findMax</code>：找到最大值，一直找右子树，直到找到没有右子树的右子树最右边的节点就是最大值</li><li><code>insert</code>：插入某个值，从根节点开始比较，如果目标值比该节点大就插入其右子树，否则插入左子树，如果出现相等的情况说明有该元素不需要再插入，直到插入某个空节点为止</li><li><code>remove</code>：删除节点<ul><li>删除叶子节点：直接删除</li><li>删除有一个子节点的节点：将该子节点挂到被删除的节点的父节点上，取代删除节点的位置<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure4-3.png" alt="删除只有一个子节点的子节点" title="">                </div>                <div class="image-caption">删除只有一个子节点的子节点</div>            </figure></li><li>删除有两个子节点的节点：找到该节点右子树中的最小值或者左子树中的最大值，将其替换要删除的元素，然后递归地删除用来替换的最大/小值，为什么是递归地删除呢？因为被拿出来替换被删除值的那个最大/小值也会有子树，所以删除它的时候还要执行删除remove操作。但是最多只进行一次单子节点的删除工作，因为无论是右子树中的最小值还是左子树中的最大值，最多只有一个子树<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure4-4.png" alt="删除有两个子节点的子节" title="">                </div>                <div class="image-caption">删除有两个子节点的子节</div>            </figure></li></ul></li></ul><h2 id="平均情况分析"><a href="#平均情况分析" class="headerlink" title="平均情况分析"></a>平均情况分析</h2><table><thead><tr><th align="center">操作</th><th align="center">平均时间复杂度</th></tr></thead><tbody><tr><td align="center">isEmpty</td><td align="center">O(1)</td></tr><tr><td align="center">contains</td><td align="center">O(logN)</td></tr><tr><td align="center">findMin/findMax</td><td align="center">O(logN)</td></tr><tr><td align="center">insert</td><td align="center">O(logN)</td></tr><tr><td align="center">remove</td><td align="center">O(1)</td></tr></tbody></table><h1 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h1><p>AVL（Adelson-Velskii and Landis）树是带有平衡条件（balance condition）的二叉查找树，这个平衡条件很容易保持并且保证了树的深度为O(logN)。</p><p>AVL树要求每个节点的左子树和右子树的高度差最多为1。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure4-5.png" alt="AVL树" title="">                </div>                <div class="image-caption">AVL树</div>            </figure><p>AVL树除了插入操作外，其他所有的操作都可以最多以O(logN)的时间执行</p><h2 id="AVL树的插入"><a href="#AVL树的插入" class="headerlink" title="AVL树的插入"></a>AVL树的插入</h2><p>AVL树的插入比较复杂的点在于插入的值可能会破坏树原本的平衡，所以在插入值后需要进行<strong>旋转</strong>（rotation）</p><p>旋转的情况可以根据插入后的树的情况分为如下四种：</p><blockquote><p>示意图来源：<a href="https://blog.csdn.net/gabriel1026/article/details/6311339" target="_blank" rel="noopener">https://blog.csdn.net/gabriel1026/article/details/6311339</a></p></blockquote><table><thead><tr><th align="center">插入后的情况</th><th align="center">描述</th><th align="center">旋转方式</th></tr></thead><tbody><tr><td align="center">LL-左子树左高</td><td align="center">在左子树根节点的左子树上插入节点而破坏平衡</td><td align="center">右旋转</td></tr><tr><td align="center">RR-右子树右高</td><td align="center">在右子树根节点的右子树上插入节点而破坏平衡</td><td align="center">左旋转</td></tr><tr><td align="center">LR-左子树右高</td><td align="center">在左子树根节点的右子树上插入节点而破坏平衡</td><td align="center">先左旋后右旋</td></tr><tr><td align="center">RL-右子树左高</td><td align="center">在右子树根节点的左子树上插入节点而破坏平衡</td><td align="center">先右旋后左旋</td></tr></tbody></table><ul><li>LL-左子树左高的情况  <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure4-6.png" alt="LL-左子树左高" title="">                </div>                <div class="image-caption">LL-左子树左高</div>            </figure></li><li>RR-右子树右高的情况  <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure4-7.png" alt="RR-右子树右高" title="">                </div>                <div class="image-caption">RR-右子树右高</div>            </figure></li><li>LR-左子树右高的情况  <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure4-8.png" alt="LR-左子树右高" title="">                </div>                <div class="image-caption">LR-左子树右高</div>            </figure></li><li>RL-右子树左高的情况  <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure4-9.png" alt="RL-右子树左高" title="">                </div>                <div class="image-caption">RL-右子树左高</div>            </figure></li></ul><h1 id="伸展树"><a href="#伸展树" class="headerlink" title="伸展树"></a>伸展树</h1><h2 id="伸展树与摊还时间"><a href="#伸展树与摊还时间" class="headerlink" title="伸展树与摊还时间"></a>伸展树与摊还时间</h2><p>伸展树（splay tree）保证从空树开始任意连续M此对树的操作最多花费O(MlogN)的时间，即这M次连续的操作中即使有些操作耗时长，但是也有一些耗时短的操作，使得这M个连续的操作花费的总时间最坏为O(MlogN)。</p><p><strong>摊还</strong>（amortized）：一般说来，当M次操作的序列总的最坏情形运行时间为O(M f(N))时,我们就说它的摊还(amortized)运行时间为O(f(N))。因此，一棵伸展树每次操作的摊还代价是O(logN)。经过一系列的操作，有的操作可能花费时间多一些，有的可能要少一些，不存在不好的输入队列。 </p><p>如果任意特定操作可以有最坏时间界O(N)，而我们仍然要求一个O(logN)的摊还时间界，那么很清楚，只要有一个结点被访问，它就必须被移动。否则，一旦我们发现一个深层的结点，就有可能不断地对它进行访问。如果这个结点不改变位置，而每次访问又花费O(N)，那么M次访问将花费O(MN)的时间。这个思想和数据库中将经常访问到的数据前移以及操作系统中将经常访问的数据放入cache高速缓存等思想相同。（在许多应用中，当一个结点被访问时，它就很可能不久再被访问。研究表明，这种情况的发生比人们预料的要频繁得多。）</p><h2 id="伸展（splaying）"><a href="#伸展（splaying）" class="headerlink" title="伸展（splaying）"></a>伸展（splaying）</h2><p>伸展树的基本思想是将访问到的一个较深的节点通过旋转的方式将其旋转到根节点的位置，但是为了保证旋转过程中不让一些较浅的节点也被沦落到较深的位置，这里的伸展采用一定的策略：</p><ul><li>首先，一个要被旋转到树根处的深节点X，如果X的父节点就是根节点，那么只要旋转X和树根即可</li><li>如果X的父节点不是根节点，将其父节点命名为P，同时X一定有祖父节点G，X、P、G三个节点存在两种排列关系：<ul><li>“之字形”（zig-zag）：这种情况下执行一次AVL树同理的双旋转<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure4-10.png" alt="“之字形”（zig-zag）" title="">                </div>                <div class="image-caption">“之字形”（zig-zag）</div>            </figure></li><li>“一字形”（zig-zig）：这种情况下直接将树左右对调（类似于跷跷板）<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure4-11.png" alt="“一字形”（zig-zig）" title="">                </div>                <div class="image-caption">“一字形”（zig-zig）</div>            </figure></li></ul></li></ul><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>如下图，想把 K1 节点调至树根处</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure4-12.png" alt="一个伸展树的例子" title="">                </div>                <div class="image-caption">一个伸展树的例子</div>            </figure><p>首先由K1、K2、K3构成了一个“之字形”结构，使用双旋转方式得到如下的第一次调整</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure4-13.png" alt="一个伸展树的例子" title="">                </div>                <div class="image-caption">一个伸展树的例子</div>            </figure><p>然后由K1、K4、K5构成了一个“一字形”结构，采用跷跷板的方式做第二次调整</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure4-14.png" alt="一个伸展树的例子" title="">                </div>                <div class="image-caption">一个伸展树的例子</div>            </figure><h1 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h1><p>树的遍历分为三种</p><ul><li>先根遍历：每棵树按照 根-左子树-右子树 顺序遍历</li><li>中根遍历：每棵树按照 左子树-根-右子树 顺序遍历</li><li>后根遍历：每棵树按照 左子树-右子树-根 顺序遍历</li></ul><h1 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h1><p>B树的思想很简单，如果我们使用二叉树，树的平均深度为logN，如果我们是一个M叉树（每个节点最多有M个子树），则树的平均深度为logMN，显然这样会使得树的深度降低。</p><h2 id="M阶B树的规范"><a href="#M阶B树的规范" class="headerlink" title="M阶B树的规范"></a>M阶B树的规范</h2><ul><li>数据项存储在树叶上</li><li>非叶结点存储直到 M-1 个键，以指示搜索的方向；键 i 代表子树 i+1 中的最小的键</li><li>树的根或者是一片树叶，或者其儿子数在2和M之间</li><li>除根外，所有非树叶结点的儿子数在 [M/2]（向上取整）和M之间</li><li>所有的树叶都在相同的深度上并有 [L/2]（向上取整）和L之间个数据项</li></ul><h2 id="一个5阶B树的例子"><a href="#一个5阶B树的例子" class="headerlink" title="一个5阶B树的例子"></a>一个5阶B树的例子</h2><p>一个5阶的B树，所有的非叶子节点的儿子都在3和5之间，从而有2到4个键，根可能只有两个的儿子，L=5，因此每个树叶有3到5个数据项，要求节点一半满，保证B树不致退化成简单的二叉树</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure4-15.png" alt="一个5阶B树的例子" title="">                </div>                <div class="image-caption">一个5阶B树的例子</div>            </figure><p>向B树中插入 57 数据项：按照键索引到插入数据的位置，插入数据项</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure4-16.png" alt="一个5阶B树的例子" title="">                </div>                <div class="image-caption">一个5阶B树的例子</div>            </figure><p>再插入 55  数据项，导致该叶子节点数据超出5，所以需要分裂其父节点成为两个叶子</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure4-17.png" alt="一个5阶B树的例子" title="">                </div>                <div class="image-caption">一个5阶B树的例子</div>            </figure><p>再插入 40 数据项，引起树叶被分裂成两片然后又造成父结点的分裂</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure4-18.png" alt="一个5阶B树的例子" title="">                </div>                <div class="image-caption">一个5阶B树的例子</div>            </figure><p>从B树中删除 99 数据项导致叶子节点的数据少于3从而合并叶子，而父节点也少于3从而再一次合并</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure4-19.png" alt="一个5阶B树的例子" title="">                </div>                <div class="image-caption">一个5阶B树的例子</div>            </figure><h1 id="标准库（SLT）中的set和map"><a href="#标准库（SLT）中的set和map" class="headerlink" title="标准库（SLT）中的set和map"></a>标准库（SLT）中的set和map</h1><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set是一个排序后的容器，不允许重复。set特有的操作是高效的插入、删除和执行基本查找。set也允许使用iterator来遍历。</p><h3 id="set的方法"><a href="#set的方法" class="headerlink" title="set的方法"></a>set的方法</h3><ul><li>与<code>vector</code>和<code>list</code>相同的方法<ul><li><code>iterator begin()</code>：返回容器开始的迭代器</li><li><code>iterator end()</code>：返回容器结尾处的迭代器</li><li><code>int size() const</code>：返回容器内的元素个数</li><li><code>bool empty()</code>：如果容器没有元素，返回 <code>true</code>，否则返回 <code>false</code></li></ul></li><li>特有的插入操作，<code>set</code>使用<code>insert</code>进行插入操作，由于非重复性，导致插入有可能会失败，<code>insert</code>操作返回一个<code>iterator</code>指明插入新项的位置或者失败时已有的项的位置.。pair是一个类模板，并且提供两个成员 first 和 second 用来访问返回值的两项成员<ul><li><code>pair&lt;iterator, bool&gt; insert( const Object &amp; x);</code> ：插入Object x</li><li><code>pair&lt;iterator, bool&gt; insert( iterator hint, const Object &amp; x);</code>：在指定索引hint处插入Object x，比单参数的插入快得多，通常为O(1)</li></ul></li><li><code>erase</code>删除操作<ul><li><code>int erase( const Object &amp; x);</code> ：删除x，如果找到的话，返回删除元素的个数，显然只能返回0或者1</li><li><code>iterator erase( iterator itr);</code>：删除有iterator指定的位置的对象</li><li><code>iterator erase( iterator start, iterator end);</code>：删除由两个iterator指定的位置对象中间包含的所有元素，包含前不包含后</li></ul></li><li><code>find</code>查找操作<ul><li><code>iterator find( const Object &amp; x) const;</code>：查找x返回其位置</li></ul></li></ul><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map用来存储排序后的由键和值组成的项的集合，键必须唯一，但是多个键可以同时对应一个值，即值不需要唯一，键保持逻辑排序后的顺序</p><h3 id="map的方法"><a href="#map的方法" class="headerlink" title="map的方法"></a>map的方法</h3><p>map的方法和set很像，但是其返回值是一个键-值对： <code>pair&lt;KeyType, ValueType&gt;</code>，map支持 <code>begin</code>、<code>end</code>、<code>size</code>、<code>enmty</code>、<code>insert</code>、<code>find</code>、<code>erase</code>、<code>find</code></p><ul><li><code>insert</code>操作必须提供 <code>pair&lt;KeyType, ValueType&gt;</code> 对象</li><li><code>find</code>仅需要一个键，但是返回值的<code>iterator</code>还是指向一个 <code>pair&lt;KeyType, ValueType&gt;</code> 对象，并可以用 <code>first</code> 访问返回的键，使用 <code>second</code> 访问返回的值</li></ul><p>map还重载了数组索引的操作符 <code>[]</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ValueType &amp; <span class="keyword">operator</span>[] ( <span class="keyword">const</span> KeyType &amp; key );</span><br></pre></td></tr></table></figure><p>如果map中存在key就返回只想相应值的引用，如果不存在key就在map中插入一个默认的值，然后返回指向这个插入的默认值的引用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;树&quot;&gt;&lt;a href=&quot;#树&quot; class=&quot;headerlink&quot; title=&quot;树&quot;&gt;&lt;/a&gt;树&lt;/h1&gt;&lt;h2 id=&quot;树的实现&quot;&gt;&lt;a href=&quot;#树的实现&quot; class=&quot;headerlink&quot; title=&quot;树的实现&quot;&gt;&lt;/a&gt;树的实现&lt;/h2&gt;&lt;p
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://blogs.littlegenius.xin/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习笔记" scheme="https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/tags/C/"/>
    
      <category term="数据结构" scheme="https://blogs.littlegenius.xin/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【C++温故知新】（五）多文件架构与名称空间</title>
    <link href="https://blogs.littlegenius.xin/2019/08/18/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E4%BA%94%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4/"/>
    <id>https://blogs.littlegenius.xin/2019/08/18/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E4%BA%94%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4/</id>
    <published>2019-08-18T03:21:51.000Z</published>
    <updated>2019-08-18T03:27:18.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="头文件与源文件"><a href="#头文件与源文件" class="headerlink" title="头文件与源文件"></a>头文件与源文件</h1><p>一般我们将大量公用的代码段存放在头文件中，然后使用其他源文件引用这个头文件，从而使得很多代码段不需要在每个源文件中都书写一遍。一种推荐的策略是这样的，将整个项目/程序包分为三个部分：</p><ul><li>头文件（.h）：包含结构体等数据类型的声明，类的框架、函数原型等等抽象而公用的部分</li><li>源代码文件（.cpp）：负责头文件中的抽象部分的具体化，如函数的主体、类的实现等</li><li>源代码文件（.cpp）：负责调用头文件中的函数以及实例化类模型等从而完成项目逻辑</li></ul><p>头文件中不要包含函数的定义或者变量的声明，头文件中一般只包含如下的部分：</p><ul><li>函数原型</li><li>使用 #define 或 const 定义的符号常量</li><li>结构声明</li><li>类声明</li><li>模板声明</li><li>内联函数</li></ul><p>头文件通常的书写架构如下，例如我们创建了一个命名为 headFile.h 的头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HEADFILE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEADFILE_H_</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// the head file</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>对头文件与源代码文件编译时是单独编译的，编译器会创建每个源代码文件的目标代码文件，生成 <strong>.o</strong> 后缀的文件，然后使用连接器将两个部分连接起来，将库代码和启动代码合并，生成一个 <strong>.out</strong> 后缀的文件，进而生成 <strong>.exe</strong> 后缀的可执行文件。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/CPP5-1.png" alt="多文件编译的过程" title="">                </div>                <div class="image-caption">多文件编译的过程</div>            </figure><h1 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h1><p>名称空间可以理解为为了区分不同的库类不同的厂商的代码中所包含的同命名的变量、函数等来问题的。例如我的程序包含了两个厂家开发的库，但这两个库中都有一个名为 List 的类，为了区分使用哪个厂家的类，就需要这两个厂家将自己的 List 类封装在自己的名称空间中，从而方便区分。 </p><h2 id="名称空间的创建"><a href="#名称空间的创建" class="headerlink" title="名称空间的创建"></a>名称空间的创建</h2><p>我们自己也可以创建名称空间，例如我们声明一个int类型的变量myInt，将其放在我们定义的一个名称空间MHZ中，可以这样写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> MHZ</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> myInt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="名称空间的使用"><a href="#名称空间的使用" class="headerlink" title="名称空间的使用"></a>名称空间的使用</h2><p>如果我想在我的程序中调用名称空间<code>MHZ</code>中的<code>myInt</code>变量，需要使用该名称空间，有以下的一些方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译使用整个名称空间</span></span><br><span class="line"><span class="comment">// 这种方式最不安全</span></span><br><span class="line"><span class="comment">// 因为会将整个名称空间的内容全部编译使用</span></span><br><span class="line"><span class="comment">// 很容易出现不同名称空间重名的问题</span></span><br><span class="line"><span class="keyword">using</span> MHZ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; myInt;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 指定编译使用名称空间中的某个变量/函数等</span></span><br><span class="line"><span class="comment">// 这种方式相对安全</span></span><br><span class="line"><span class="comment">// 使用哪个因素就声明那个因素</span></span><br><span class="line"><span class="keyword">using</span> MHZ::myInt;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; myInt;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在调用的时候指明名称空间</span></span><br><span class="line"><span class="comment">// 这种方式虽然繁琐，但是最不容易出错</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; MHZ::myInt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;头文件与源文件&quot;&gt;&lt;a href=&quot;#头文件与源文件&quot; class=&quot;headerlink&quot; title=&quot;头文件与源文件&quot;&gt;&lt;/a&gt;头文件与源文件&lt;/h1&gt;&lt;p&gt;一般我们将大量公用的代码段存放在头文件中，然后使用其他源文件引用这个头文件，从而使得很多代码段不需要
      
    
    </summary>
    
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/categories/C/"/>
    
    
      <category term="学习笔记" scheme="https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【C++温故知新】（四）函数</title>
    <link href="https://blogs.littlegenius.xin/2019/08/12/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E5%9B%9B%E5%87%BD%E6%95%B0/"/>
    <id>https://blogs.littlegenius.xin/2019/08/12/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E5%9B%9B%E5%87%BD%E6%95%B0/</id>
    <published>2019-08-12T04:44:00.000Z</published>
    <updated>2019-08-18T03:22:11.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h1><h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">typeName <span class="title">functionName</span><span class="params">(parameterList)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">statement;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数有多个参数，使用逗号间隔。</p><p>函数在执行完第一个 <code>return</code> 语句后结束，如果返回值是<code>void</code>，可以直接使用 <code>return</code>; 或者不写返回语句。</p><h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h2><p>函数原型描述了函数到编译器的接口，需要写在main函数前边，通常放在头文件引用后。函数原型需要说明函数的<strong>返回类型、函数名、函数的参数类型</strong>，不需要写变量名，以分号结尾。</p><h1 id="函数与一些数据类型"><a href="#函数与一些数据类型" class="headerlink" title="函数与一些数据类型"></a>函数与一些数据类型</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>函数是使用指针来处理数组的。已知C++中将数组名解释为该数组中第一个元素的地址，即 <code>arrayName = &amp;arrayName[0]</code>，在函数中，当将数组作为函数的参数传递时，实际上传递的是数组的第一个元素的地址，即在调用函数时，传入的参数是数组名。</p><p>以数组为参数的函数声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">arrayFunction</span><span class="params">(<span class="keyword">int</span> arr [], <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>调用该函数时，只将数组的名字作为参数传入（即传入的是指向数组首元素的指针）即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> myArray[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> result = arrayFunction(myArray,<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>所以实际上传入的类型应该是一个<code>int</code>的指针，也就是说函数其实是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">arrayFunction</span><span class="params">(<span class="keyword">int</span> * arr, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/CPP4-1.png" alt="将数组作为参数出入函数" title="">                </div>                <div class="image-caption">将数组作为参数出入函数</div>            </figure><p>可以看到，我们使用 <code>int arr []</code> 替换了 <code>int *arr</code> 。既然这两个函数头都是正确的，那么就证明了一个问题：在C++中，当(且仅当）用于函数头或函数原型中，<code>int* arr</code> 和 <code>int arr[]</code> 的含义才是相同的，它们都表示<code>arr</code>是一个<code>int</code>指针。然而，数组表示法（<code>int ar[]</code>）提醒用户，<code>arr</code>不仅指向<code>int</code>，还指向<code>int</code>数组的第一个<code>int</code>值。<br><strong>但是！</strong>在其他的上下文中，<code>int*ar</code> 和 <code>int arr[]</code> 的含义并不相同。</p><p>数组名与指针对应是一件好事。将数组地址作为参数可以节省复制整个数组所需的时间和内存。如果数组很大，则使用拷贝的系统开销将非常大，程序不仅需要更多的计算机内存，还需要花费时间来复制大块的数据。但是另一方面，使用原始数据增加了破坏数据的风险，所以要尽可能的使用const限定词来保护数组。</p><h3 id="使用const来保护数组"><a href="#使用const来保护数组" class="headerlink" title="使用const来保护数组"></a>使用const来保护数组</h3><p>由于数组名与指针对应，所以数组是按照引用传递的，不是按值传递，因此保护传入的数组不被函数修改破坏非常重要，因此如果函数内部没有修改传入的数组的理由（例如便利打印数组），则最好用<code>const</code>来限定参数，从而起到保护数组的作用。</p><p>通常分为如下两种声明方法：</p><ul><li><code>void functionModify(int arr[], int size);</code></li><li><code>void functionNoChange(const int arr[], int size);</code></li></ul><h3 id="使用数组区间的函数"><a href="#使用数组区间的函数" class="headerlink" title="使用数组区间的函数"></a>使用数组区间的函数</h3><p>传统的传递数组到函数中的方式为：传递一个数组名称作为指向第一个元素的指针，再传递一个整数告知函数数组的大小。</p><p>还有一种方式是通过传递两个指针来告知函数要处理的元素区间（range），一个指针标识数组的开头，另一个指针标识数组的结尾。例如下边这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumArray</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> * <span class="built_in">begin</span>, <span class="keyword">const</span> <span class="keyword">int</span> * <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * pt;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(pt=<span class="built_in">begin</span>;pt!=<span class="built_in">end</span>;pt++)</span><br><span class="line">sum+=*pt;</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> arrayName[arraySize]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> sum = sumArray(arrayName,arrayName+arraySize);</span><br></pre></td></tr></table></figure><h3 id="指针、数组与函数的参数传递"><a href="#指针、数组与函数的参数传递" class="headerlink" title="指针、数组与函数的参数传递"></a>指针、数组与函数的参数传递</h3><p>我们知道，函数对于传递数组作为参数，根据函数是否有权限改变数组的值，通常有两种声明方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionModify</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;<span class="comment">// 1号函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionNoChange</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> arr[], <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;<span class="comment">// 2号函数</span></span><br></pre></td></tr></table></figure><p>此时，如果我们有两个数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cosnt <span class="keyword">int</span> array1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">// 1号数组</span></span><br><span class="line"><span class="keyword">int</span> array2 = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;<span class="comment">// 2号数组</span></span><br></pre></td></tr></table></figure><p>很明显，一个是常量数组，一个是变量数组。两种数组对于两个函数的关系是这样的：</p><ul><li>禁止将常量数组的地址赋给非常量指针，即：1号数组不能传递给2号函数，只能传递给1号函数</li><li>可以将非常量数组赋给常量或非常量指针，即：2号数组可以被传递给1和2号函数</li></ul><p>因此，在设计函数时，要尽可能地使用const，因为将指针参数声明为指向常量数据的指针可以：</p><ul><li>避免由于无意间修改数据而导致的编程错误</li><li>使用const使得函数能够处理const和非const实参，否则将只能接受非const数据</li></ul><p>所以，如果条件允许，则应将指针形参声明为指向<code>const</code>的指针</p><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>编写以二维数组作为参数的方法如下：首先，数组名称被视为其地址，而且数组名可以认为是指向第一层元素的指针（第一层的元素是数组（第二层））。</p><p>例如下边的这个数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> data[<span class="number">3</span>][<span class="number">4</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;, &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;, &#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>可以这样声明一个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span> <span class="params">(<span class="keyword">int</span> (*arr)[<span class="number">4</span>], <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>或者这样声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span> <span class="params">(<span class="keyword">int</span> arr[][<span class="number">4</span>], <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>然后这样使用它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = sum(data,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>可以看到，传入的参数是数组名，即表示大数组data中第一个元素的引用，而这个元素又是一个4维的数组，所以其实传入的第一个参数是一个<strong>指向由4个int组成的数组的指针</strong>。而且，第一种声明方式中，必须将 <code>*arr</code> 用括号括起来，否则 <code>int *arr[4]</code> 将表示的是一个由4个指向int的指针组成的数组，然而函数的参数不可能是数组。以上两种声明方式都表明 arr 是指针而不是数组，只是在声明时需要表明它是一个由4个int组成的数组罢了，这也就意味着已经将数组的列数传入函数，所以只需要单独传入一个行数作为参数即可。</p><p>在函数中，可以直接将 arr 看成数组名，然后像这样使用它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result+=arr[i][j];</span><br></pre></td></tr></table></figure><p>显然，这里存在如下的一个关系：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[i][j] == *(*(arr+i)+j)</span><br></pre></td></tr></table></figure><p>实际上，是这样推演过来的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr  <span class="comment">// 指向第一行的由4个int组成的数组的指针</span></span><br><span class="line">arr+i  <span class="comment">// 指向低i行的元素的指针（这个元素是一个4元int数组）</span></span><br><span class="line">*(arr+i)  <span class="comment">// 第i行的元素，也就是第i行数组，即第i行的指向这个数组第一个元素的指针，等同于 arr[i]</span></span><br><span class="line">*(arr+i)+j  <span class="comment">// 指向第i行第j个元素的指针，等同于 arr[i]+j</span></span><br><span class="line">*(*arr+i)+j)  <span class="comment">// 第i行第j列的元素值，等同于 arr[i][j]</span></span><br></pre></td></tr></table></figure><h2 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a>C风格字符串</h2><p>C风格字符串只一系列字符，以空值结尾的字符串。</p><h3 id="作为参数"><a href="#作为参数" class="headerlink" title="作为参数"></a>作为参数</h3><p>将C风格的字符串作为参数传递给函数，有三种表示字符串的方式：</p><ul><li>char数组</li><li>用引号括起来的字符串常量（字符串字面值）</li><li>被设置为字符串的地址的char指针</li></ul><p>但其实这三种方式都是传递了一个char指针（<code>char*</code>），由于C风格的字符串与一般的char数组的最主要区别是，C风格字符串自带了结束字符（\0），所以不需再传入一个数组的长度作为参数。</p><p>变量的声明与传入函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> myChar[<span class="number">6</span>] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> * ch = <span class="string">"hello"</span>;</span><br><span class="line">charFunction(myChar);  <span class="comment">// myChar 是hello的第一个元素（h）的地址</span></span><br><span class="line">charFunction(ch);  <span class="comment">// ch是指向char（h）的一个指针</span></span><br><span class="line">charFunction(<span class="string">"hello"</span>);  <span class="comment">// 直接传入字符串的地址</span></span><br></pre></td></tr></table></figure><p>函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">charFunction(<span class="keyword">char</span> * str);</span><br><span class="line">charFunction(<span class="keyword">char</span> str[]);</span><br></pre></td></tr></table></figure><p>函数中对参数的使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">charFunction(<span class="keyword">const</span> <span class="keyword">char</span> * str)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(*str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*str;</span><br><span class="line">        str++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作为返回值"><a href="#作为返回值" class="headerlink" title="作为返回值"></a>作为返回值</h3><p>函数无法直接返回一个字符串，但是可以返回字符串的地址，比如可以这样声明一个返回值为字符串的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">buildChar</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * pstr = <span class="keyword">new</span> <span class="keyword">char</span>[n+<span class="number">1</span>];</span><br><span class="line">    pstr[n]=<span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--&gt;<span class="number">0</span>)</span><br><span class="line">pstr[n]=c;</span><br><span class="line">    <span class="keyword">return</span> pstr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="传递结构的值"><a href="#传递结构的值" class="headerlink" title="传递结构的值"></a>传递结构的值</h3><p>当结构体较小时，按值传递结构比较合理，且安置传递可以将结构体看成和int、double等一样的普通单值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> myInt;</span><br><span class="line">    <span class="keyword">double</span> myDouble;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">myStruct <span class="title">sum</span><span class="params">(myStruct str1, myStruct str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    myStruct result;</span><br><span class="line">    result.myInt = str1.myInt + str2.myInt;</span><br><span class="line">    result.myDouble = str1.myDouble + str2.myDouble;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="传递结构的地址"><a href="#传递结构的地址" class="headerlink" title="传递结构的地址"></a>传递结构的地址</h3><p>当结构体较大时，传递结构体的地址更为合理，可以节省时间与空间，此时需要将参数由结构体变成指向它的指针，并且访问结构体内的元素时需要使用 <code>-&gt;</code> 代替点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStruct</span><span class="params">(<span class="keyword">const</span> myStruct * str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"myInt = "</span>&lt;&lt;str-&gt;myInt;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"myDouble = "</span>&lt;&lt;str-&gt;myDouble;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="string对象"><a href="#string对象" class="headerlink" title="string对象"></a>string对象</h2><p>由于string是对象，对象是可以赋值的，所以和结构体类似，可以直接将string的实体按值传递给函数，也可以直接从函数返回，如果需要多个string，可以使用string的数组而不需要一个char的二维数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pringStrings</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> str[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">" : "</span>&lt;&lt; str[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="array对象"><a href="#array对象" class="headerlink" title="array对象"></a>array对象</h2><p>array对象也是对象，所以依然有两种传递给函数的方式：按值传递和按引用传递（传递地址）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="built_in">array</span>&lt;<span class="keyword">int</span>,<span class="number">3</span>&gt; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="built_in">array</span>&lt;<span class="keyword">int</span>,<span class="number">3</span>&gt; * arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">3</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(*arr)[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>递归就是函数自己调用自己。在递归的过程中，需要设置终止条件，否则将无限循环下去，例如下边的test为false时将会断开递归。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recurs</span><span class="params">(argumentlist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    statements1;</span><br><span class="line">    <span class="keyword">if</span>(test)</span><br><span class="line">        recurs(arguments)</span><br><span class="line">    statements2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归对于函数的调用是基于栈这种数据结构的，即后进先出，例如三次递归上边的函数，会首先有三次statements1，然后发现终止条件满足后再倒叙执行三次statements2，形成一个栈的后进先出的结果。</p><p>函数递归一般会在时间上对于程序有所缩短，但是占用内存的开销却一般较大，因为所以未完成递归的函数都需要存储在内存中，直到整个递归结束才会释放。</p><h1 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h1><p>函数也有地址，指向函数的存储地址的数据类型为函数指针，在存储机器语言代码的内存块中，函数指针指向这个函数的内存块的开始地址。利用函数指针，我们可以使用一个函数找到另一个函数，亦或者让函数成为另一个函数的变量。那为什么不直接使用函数调用呢？因为函数调用的代码是写好的，只能调用那一个固定的函数，但是函数指针如果作为一个变量来使用的话，可以传入不同的值，即可以选择使用不同的函数。</p><h2 id="获取函数指针"><a href="#获取函数指针" class="headerlink" title="获取函数指针"></a>获取函数指针</h2><p>函数名（不带参数）即为指向该函数的指针，若将函数作为参数传递，必须传递函数名（函数指针）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">invoke(myFunction); <span class="comment">// 传入的是函数指针，即函数</span></span><br><span class="line">invoke(myFunction()); <span class="comment">// 传入的是函数的返回值</span></span><br></pre></td></tr></table></figure><h2 id="声明函数指针"><a href="#声明函数指针" class="headerlink" title="声明函数指针"></a>声明函数指针</h2><p>声明函数指针时必须指定指针指向的函数类型，即说明函数的返回类型与参数列表，和函数原型的声明方式非常类似。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myFunction</span><span class="params">(<span class="keyword">double</span>)</span></span>; <span class="comment">// 函数原型</span></span><br><span class="line"><span class="keyword">int</span> (*myFunctionPoint)(<span class="keyword">double</span>); <span class="comment">// myFunction是函数指针</span></span><br></pre></td></tr></table></figure><p>这里将 <code>(*myFunctionPoint)</code> 替换了 <code>myFunction</code> ，从而 <code>myFunction</code>是函数名， <code>myFunctionPoint</code>是函数指针</p><p>注意区分如下的两种情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*myFunctionPoint)(<span class="keyword">double</span>); <span class="comment">// myFunction是函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">myFunction</span><span class="params">(<span class="keyword">double</span>)</span></span>; <span class="comment">// 返回一个指向int的指针的函数</span></span><br></pre></td></tr></table></figure><p>在正确的声明函数指针后，要通过赋值使得函数指针指向函数，由于上文提到函数名（不带参数）即是函数的地址，从而赋值的方式就很简单（赋值必须保证返回类型和参数列表均相同）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myFunctionPoint = myFunction; <span class="comment">// 左侧为函数指针，右侧为函数的地址</span></span><br></pre></td></tr></table></figure><h2 id="使用指针调用函数"><a href="#使用指针调用函数" class="headerlink" title="使用指针调用函数"></a>使用指针调用函数</h2><p>已知，<code>(*myFunctionPoint)</code>和<code>myFunction</code>扮演的角色相同，所以可以使用任何一种形式来调用这个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = myFunction(<span class="number">1.2</span>); <span class="comment">// 使用函数名调用函数</span></span><br><span class="line"><span class="keyword">int</span> result = (*myFunctionPoint)(<span class="number">5.6</span>); <span class="comment">// 使用函数指针调用函数</span></span><br><span class="line"><span class="keyword">int</span> result = myFunctionPoint(<span class="number">3.7</span>); <span class="comment">// 实际上这也是一种可行的方式</span></span><br></pre></td></tr></table></figure><h2 id="函数指针数组"><a href="#函数指针数组" class="headerlink" title="函数指针数组"></a>函数指针数组</h2><p>函数指针的神奇之处在于它可以保存成数组类型。假设我们有三个返回类型和参数列表均相同但是作用却不同的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f3</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>我们可以使用一个指向这种函数类型的函数指针的数组来存储这三个函数的指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> (*fp[<span class="number">3</span>]) (<span class="keyword">int</span>) = &#123;f1,f2,f3&#125;;</span><br></pre></td></tr></table></figure><p>现在说明一下数组索引3的位置：fp是一个包含三个元素的数组，而要声明这样的数组，首先需要使用<code>fp[3]</code>，该声明的其他部分指出了数组包含的元素是什么样的。运算符<code>[]</code>的优先级高于<code>*</code>，因此<code>fp[3]</code>表明<code>fp</code>是一个包含三个指针的数组。上述声明的其他部分指出了每个指针指向的是什么：参数为int，且返回类型为double的函数。因此，<code>fp</code>是一个包含三个指针的数组，其中每个指针都指向这样的函数，即将int作为参数，并返回一个double。</p><p><strong>注意</strong>，此处无法使用auto赋值，因为auto只能用于单值初始化，无法用于初始化列表。</p><p>接下来使用该数组调用函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> = fp[<span class="number">0</span>](<span class="number">1</span>);</span><br><span class="line"><span class="keyword">double</span> = (*fp[<span class="number">1</span>])(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><p>内联函数与其他函数的区分之处在于编译器对函数的处理方式，常规函数在编译时，函数调用就是函数调用，在调用到该函数时，运行程序会跳转到存储该函数的代码块去执行这个函数，执行结束后再跳转回来继续执行；而内联函数再编译时直接将整个函数编译到调用的地方，即用函数的内容替换函数调用。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/CPP4-2.png" alt="内联函数与常规函数" title="">                </div>                <div class="image-caption">内联函数与常规函数</div>            </figure><p>这个性质就决定了，内联函数最好是简单的函数，如果函数过于复杂，不适合被声明为内联函数，因为如果复杂的函数作为了内联函数，那么编译时每一个函数调用都会复制一次整个函数放在调用的位置，是非常耗费空间的。但是对于简单的却调用次数很多的函数，适合声明为内联函数，这样其实相当于将一些多次多处重复的代码单独拎出来写了，但是编译时编译器帮你放了回去。</p><p>内联函数的声明方法：在函数生命和定义前都加上关键词 inline，而且通常由于内联函数很简单，会直接写在原型处：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="keyword">return</span> x*x; &#125;</span><br></pre></td></tr></table></figure><h1 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h1><p>引用变量被定义为一个变量的别名，即引用变量和其指向的变量代表同一个值，指向同一个存储单元，并且引用变量自从赋值起就已知跟着这个变量，不会再发生改变，也就是一个变量两个名字，所以更改其中的任何一个这个变量都会发生改变。</p><p><code>&amp;</code>符号可以指示变量的地址，同时它的另一个含义就是用来声明引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> genius;</span><br><span class="line"><span class="keyword">int</span> &amp; me = genius;</span><br></pre></td></tr></table></figure><p>这里的<code>&amp;</code>不是地址运算符，而是类型标识符的一部分，就像<code>int *</code>是<code>int</code>类型的指针一样，<code>int &amp;</code>是指向<code>int</code>的引用。上述声明将me和genius等价，它们指向相同的值和内存单元，就是说me就是genius，而genius就是me。</p><h2 id="引用和指针"><a href="#引用和指针" class="headerlink" title="引用和指针"></a>引用和指针</h2><p>引用和指针貌似很相像，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> genius = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> &amp; me = genius;</span><br><span class="line"><span class="keyword">int</span> * myself = &amp;genius;</span><br></pre></td></tr></table></figure><p>这样，神奇的事情来了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">me == *myself == genius</span><br><span class="line">&amp;me == myself == &amp;genius</span><br></pre></td></tr></table></figure><p>引用与指针也有区别，例如必须再声明时将引用的值初始化，不能像指针一样，先声明在赋值；而且引用变量一旦赋值将不会再更改，这一点更接近于const指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp; me = genius;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> myself = &amp;genius;</span><br></pre></td></tr></table></figure><p>从而，<code>me == *myself</code></p><h2 id="将引用用作函数参数"><a href="#将引用用作函数参数" class="headerlink" title="将引用用作函数参数"></a>将引用用作函数参数</h2><p>按值传递与按引用传递</p><ul><li>按值传递：函数复制一份传入的值，然后对复制的数据进行操作，与被传入的数据无关</li><li>按引用传递：函数直接使用传入的数据，不对其进行拷贝，修改的内容会直接体现在原数据上，这一点可以轻松地使用引用变量完成，抑或通过使用指针传递变量的地址来完成</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/CPP4-3.png" alt="按值传递与按引用传递" title="">                </div>                <div class="image-caption">按值传递与按引用传递</div>            </figure><p>例如，完成一个交换两个变量的值的函数：</p><p>按值传递</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapByValue</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按引用传递：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapByReference</span><span class="params">(<span class="keyword">int</span> &amp; a, <span class="keyword">int</span> &amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按地址（指针）传递:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapByPoint</span><span class="params">(<span class="keyword">int</span> * a, <span class="keyword">int</span> * b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种函数的调用方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">swapByValue(intA, intB);</span><br><span class="line">swapByReference(intA, intB);</span><br><span class="line">swapByPoint(&amp;intA, &amp;intB);</span><br></pre></td></tr></table></figure><p>可以看出，按指针传递的声明方法和调用方法与其他两种均不同，需要在函数定义时告知传入的变量时 <code>int*</code> 类型，在调用时传入变量的地址 <code>&amp;intA</code> 才可以；按值传递和按引用传递的调用方式相同，直接将变量名传入，只有在定义函数处才可以直到两者的不同，一个是按值传递，一个指出了是按地址传递 <code>&amp; int</code>。</p><p>按引用传递的一个重要方面是被传入的值会被直接使用或者修改，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">squareByValue</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a *= a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">squareByReference</span><span class="params">(<span class="keyword">int</span> &amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a *= a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用时会出现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a =<span class="number">2</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; squareByValue(a) &lt;&lt; <span class="string">" = square of "</span> &lt;&lt; a; <span class="comment">// 输出：4 = square of 2</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; squareByReference(a) &lt;&lt; <span class="string">" = square of "</span> &lt;&lt; a; <span class="comment">// 输出：4 = square of 4</span></span><br></pre></td></tr></table></figure><p>可见，按照引用传递时，被传入的变量的更改会影响到原始的变量。</p><h2 id="将引用用于结构"><a href="#将引用用于结构" class="headerlink" title="将引用用于结构"></a>将引用用于结构</h2><p>声明一个结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> myInt;</span><br><span class="line">    <span class="keyword">double</span> myDouble;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将引用用于结构-1"><a href="#将引用用于结构-1" class="headerlink" title="将引用用于结构"></a>将引用用于结构</h3><p>将结构的引用作为参数传递非常简单，同时需要注意的是最好使用引用作为返回值。否则的话，函数需要先将待返回的结构体赋予一个临时变量，然后将这个临时变量返回，这是非常耗费时间和空间的。所以应该像这样使用它们：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">myStruct &amp; <span class="title">sum</span><span class="params">(myStruct &amp; target, <span class="keyword">const</span> myStruct &amp; source)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    target.myInt += source.myInt;</span><br><span class="line">    target.myDouble += source.myDouble;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用该函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myStruct target = &#123;<span class="number">1</span>,<span class="number">2.5</span>&#125;;</span><br><span class="line">myStruct source = &#123;<span class="number">2</span>,<span class="number">3.8</span>&#125;;</span><br><span class="line">myStruct result;</span><br><span class="line">result = sum(target, source);</span><br></pre></td></tr></table></figure><h3 id="对返回值使用const"><a href="#对返回值使用const" class="headerlink" title="对返回值使用const"></a>对返回值使用const</h3><p>如果不对返回值使用const，意味着返回值是可以被赋值的，即下边的表达式成立：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(target, source) = anotherStruct;</span><br></pre></td></tr></table></figure><p>未来避免这种情况发生，可以使用const限定返回值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> myStruct &amp; <span class="title">sum</span><span class="params">(myStruct &amp; target, <span class="keyword">const</span> myStruct &amp; source)</span></span>;</span><br></pre></td></tr></table></figure><p>从而如下的语句都不能成立：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum(target, source) = anotherStruct;</span><br><span class="line">sum(sum(target, source), source);</span><br></pre></td></tr></table></figure><p>因为无法将一个有const限定的变量传递给一个没有const限定的变量，但是可以将返回值赋给其他结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = sum(target, source);</span><br></pre></td></tr></table></figure><h2 id="何时使用引用参数"><a href="#何时使用引用参数" class="headerlink" title="何时使用引用参数"></a>何时使用引用参数</h2><p>使用引用参数的主要原因有两个：</p><ul><li>程序员能够修改调用函数中的数据对象</li><li>通过传递引用而不是整个数据对象，可以提高程序的运行速度</li></ul><p>当数据对象较大时（如结构和类对象），第二个原因最重要。这些也是使用指针参数的原因。这是有道理的，因为引用参数实际上是基于指针的代码的另一个接口。那么，什么时候应使用引用、什么时候应使用指针呢？什么时候应按值传递呢？下面是一些<strong>参考原则</strong>：</p><ul><li>对于使用传递的值而不作修改的函数<ul><li>如果数据对象很小，如内置数据类型或小型结构，则按值传递</li><li>如果数据对象是数组，则使用指针，因为这是唯一的选择，并将指针声明为指向const的指针</li><li>如果数据对象是较大的结构，则使用const指针或const引用，以提高程序的效率。这样可以节省复制结构所需的时间和空间。</li><li>如果数据对象是类对象，则使用const引用。传递类对象参数的标准方式是按引用传递</li></ul></li><li>对于修改调用函数中数据的函数<ul><li>如果数据对象是内置数据类型，则使用指针</li><li>如果数据对象是数组，则只能使用指针</li><li>如果数据对象是结构，则使用引用或指针</li><li>如果数据对象是类对象，则使用引用</li></ul></li></ul><h1 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h1><p>默认参数显然就是在调用函数时，如果没有主动传入参数，可以直接使用默认的参数。</p><p>默认参数的写法只需在函数原型中的参数后跟上默认值即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myFunction</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>, <span class="keyword">double</span> = <span class="number">1.0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>默认参数的原则如下：</p><ul><li><p>在参数列表中，带有默认参数的参数必须放到所有参数的右边，即从某个参数开始，后边的如果是带有默认参数的就都是带有默认参数的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myFunction</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">double</span> n = <span class="number">1.0</span>, <span class="keyword">char</span> c = <span class="string">'c'</span>)</span></span>; <span class="comment">// 这是可行的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myFunction</span><span class="params">(<span class="keyword">int</span> m, doubel n = <span class="number">1.0</span>, <span class="keyword">char</span> c)</span></span>; <span class="comment">// 这是不行的</span></span><br></pre></td></tr></table></figure></li><li><p>调用函数时，可以不传入有默认值的参数，但是所有参数赋值必须从左到右，不能跳过某个参数值，比如上边的第一个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = myFunction(<span class="number">1</span>); <span class="comment">// 传一个参数，1，1.0，'c'</span></span><br><span class="line"><span class="keyword">int</span> result = myFunction(<span class="number">1</span>, <span class="number">2.0</span>); <span class="comment">// 传两个参数，1，2.0，'c'</span></span><br><span class="line"><span class="keyword">int</span> result = myFunction(<span class="number">1</span>, <span class="number">2.0</span>, <span class="string">'h'</span>); <span class="comment">// 传三个参数，1，2.0，'h'</span></span><br><span class="line"><span class="keyword">int</span> result = myFunction(<span class="number">1</span>, <span class="string">'h'</span>); <span class="comment">// 不允许</span></span><br><span class="line"><span class="keyword">int</span> result = myFunction(<span class="number">1</span>,  , <span class="string">'h'</span>); <span class="comment">// 不允许</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><p>函数重载提供的功能是，定义同名、同返回值，但是参数列表不同的函数，这样在调用时，编译器根据传入参数的类型自行选择使用哪一种函数。</p><p>加入我们定义了如下的三个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">int</span> i)</span></span>; <span class="comment">// #1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">double</span> d)</span></span>; <span class="comment">// #2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="built_in">string</span> s)</span></span>; <span class="comment">// #3</span></span><br></pre></td></tr></table></figure><p>在调用时会根据参数选择使用哪一种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myPrint(<span class="number">1</span>); <span class="comment">// #1</span></span><br><span class="line">myPrint(<span class="number">2.5</span>); <span class="comment">// #2</span></span><br><span class="line">myPrint(<span class="string">"hello world!"</span>); <span class="comment">// #3</span></span><br></pre></td></tr></table></figure><h2 id="重载的一些原则"><a href="#重载的一些原则" class="headerlink" title="重载的一些原则"></a>重载的一些原则</h2><p>引用变量是无法作为两种重载函数的，比如有两个函数原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> &amp; x)</span></span>;</span><br></pre></td></tr></table></figure><p>这样，在调用函数时出入参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> result = square(x);</span><br></pre></td></tr></table></figure><p>根本无法确定是使用哪种函数模型，所以在函数重载中，编译器将类型本身和类型的引用看成是一种参数。</p><p>在匹配函数时，并不区分const和非const的变量，如以下的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">char</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> c)</span></span>;</span><br></pre></td></tr></table></figure><p>广义上来讲这也是一种重载，但是由于const函数可以处理const变量和非const变量，而非const的函数只能处理非const变量，所以其实并不是严格意义上的重载函数</p><h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><p>函数模板的作用是允许我们使用泛型定义函数，然后根据具体的数据类型替换泛型。通过将类型作为参数传递给模板，可以是编译器生成该类的函数。</p><p>比如要交换两个变量的值，这时候我们写好了一个交换两个int值的函数，又需要一个交换两个double值的函数，我们需要将第一个函数重复一遍，然后再将其中的int替换成double，是非常复杂的。尤其是当一些算法可以应用于很多数据类型时，我们无法对每一种数据类型都写一套算法函数，这就时函数模板解决的问题。 </p><h2 id="模板函数的定义与使用"><a href="#模板函数的定义与使用" class="headerlink" title="模板函数的定义与使用"></a>模板函数的定义与使用</h2><p>我们可以先定义一个模板，然后用具体的数据类型替换，像下边这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T &amp;a, T &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T temp;</span><br><span class="line">temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要建立一个模板，必须先使用<code>template</code>语法来定义一个模板变量T，这里也可以用旧的声明方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;;</span></span><br></pre></td></tr></table></figure><p>很多代码库都使用<code>class</code>开发的，这样的上下文中，两个关键词完全相同，如果不考虑向后兼容并且不介意输入长单词的话，使用<code>typename</code>而不使用<code>class</code> </p><p>调用模板函数时，和其他函数类似，编译器会根据我们传入的函数类型自行生成一个对应的函数，这个函数我们是看不到的，但是编译器会直接在背后生成并为我们使用好，例如调用下边的语句时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line">swap(i, j);</span><br></pre></td></tr></table></figure><p>这是，编译器会自动生成一个函数：使用int代替所有的T，从而完成相关的逻辑，这个函数我们看不到，但是没问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line">temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板函数的重载"><a href="#模板函数的重载" class="headerlink" title="模板函数的重载"></a>模板函数的重载</h2><p>模板函数也是可以重载的，虽然泛型使我们合并解决了很多问题，但是有些数据类型是无法合并的。比如交换变量值的函数，我们可以将上述逻辑同时用于int、double、char、string等，但是却无法用于数组，因为数组需要将每个元素交换，于是可以使用函数模板的重载：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T &amp;a, T &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T []a, T[]b, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i] = b[i];</span><br><span class="line">        b[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以用同名函数swap交换任意数据类型和数组类型了。</p><h2 id="函数模板的局限性"><a href="#函数模板的局限性" class="headerlink" title="函数模板的局限性"></a>函数模板的局限性</h2><p>定义模板函数要考虑好这个函数应用的数据类型的范围，有些操作对于数据类型是很有局限性的，比如 a&gt;b 这种操作，只能用于 int、double 等，string和char显然无法使用 </p><h2 id="显式具体化"><a href="#显式具体化" class="headerlink" title="显式具体化"></a>显式具体化</h2><p>假如定义了一个结构:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> myInt;</span><br><span class="line">    <span class="keyword">double</span> myDouble;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时我们同样可以通过上面的swap函数交换两个struct的值，因为结构体是可以直接被赋给另一个结构体的。但是如果我们只想交换两个结构体的myInt变量，而不想交换myDouble变量呢，就无法使用上述模板函数了，但是由于这种情况下我们传入的参数还是和上述模板函数相同的（两个待交换的T），所以重载无法达到这个愿望。这就用到了显式具体化（explicit specialization）。</p><p>显示具体化是我们可以提供一个具体化的函数定义，其中包含这个特殊的处理情况下的代码，当编译器找到了与函数调用匹配的具体化定义时，就不再使用模板，而是用该具体化的定义：</p><ul><li>对于给定的函数名，可以有非模板函数、模板函数和显式具体化模板函数以及它们的重载函数四个版本</li><li>显式具体化的原型和定义以<code>&lt;template&gt;</code>打头，并通过名称来指出类型</li><li>非模板函数优先于具体化和常规模板，具体化模板优先于常规模板</li></ul><p>例如对于刚才的结构体，下面是用于交换逻辑的非模板函数、模板函数和具体化函数的原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非模板函数 #1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(myStruct &amp;, myStruct &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板函数 #2</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T &amp;, T &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板具体化函数 #3</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">void</span> swap&lt;myStruct&gt;(myStruct &amp;, myStruct &amp;);</span><br></pre></td></tr></table></figure><p>在上述三个函数原型同时存在时，#1优先于#3优先于#2。在具体化函数模板中，可以省略函数名后的<code>&lt;myStruct&gt;</code>，因为参数类型已经表明了这是一个myStruct的具体化函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(myStruct &amp;, myStruct &amp;)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="实例化与具体化"><a href="#实例化与具体化" class="headerlink" title="实例化与具体化"></a>实例化与具体化</h2><p>当我们定义了一个模板函数swap后，通过调用时传入了两个int值可以使得编译器在后台自动为我们实例化了一个int类型的函数，这个函数是编译中产生的，所以我们看不到，但是它确实是产生了，这个过程成为<strong>隐式实例化</strong>。</p><p>同时我们也可以进行<strong>显式实例化</strong>（explicit instantiation），即可以直接命令编译器创建特定的实例，比如一个处理int的swap函数，只需要这样声明它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="keyword">void</span> swap&lt;<span class="keyword">int</span>&gt;(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><p>这是要和<strong>显示具体化</strong>（explicit specialization）区分开的，具体化是在<code>template</code>后还需要加一个<code>&lt;&gt;</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; &gt; <span class="keyword">void</span> swap&lt;<span class="keyword">int</span>&gt;(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">template</span> &lt; &gt; <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>在<code>template</code>后有无<code>&lt;&gt;</code>是区分显示具体化和显示实例化的重要标志。</p><p>通常的，隐式实例化、显式实例化和显示具体化都被称为<strong>具体化</strong>（specialization）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;函数基础&quot;&gt;&lt;a href=&quot;#函数基础&quot; class=&quot;headerlink&quot; title=&quot;函数基础&quot;&gt;&lt;/a&gt;函数基础&lt;/h1&gt;&lt;h2 id=&quot;函数的定义&quot;&gt;&lt;a href=&quot;#函数的定义&quot; class=&quot;headerlink&quot; title=&quot;函数的定义&quot;&gt;
      
    
    </summary>
    
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/categories/C/"/>
    
    
      <category term="学习笔记" scheme="https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构】（二）栈与队列</title>
    <link href="https://blogs.littlegenius.xin/2019/08/08/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%BA%8C%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <id>https://blogs.littlegenius.xin/2019/08/08/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%BA%8C%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</id>
    <published>2019-08-08T13:13:38.000Z</published>
    <updated>2019-08-08T13:20:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈（stack）"><a href="#栈（stack）" class="headerlink" title="栈（stack）"></a>栈（stack）</h1><p>栈（stack）是限制插入和删除操作只能在末尾位置上进行的表，该末尾成为栈的顶（top）。是一种<strong>后进先出</strong>的表（<strong>LIFO</strong>，Last In First Out）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure2-1.png" alt="栈" title="">                </div>                <div class="image-caption">栈</div>            </figure><h2 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h2><ul><li>链表实现：使用单向链表实现</li><li>数组实现：使用数组实现，是更加常用的方式。由C++中的vector中的back、push_back和pop_back可以很简单地实现一个栈。每个栈需要一个用于存储栈数据的数组（stackArray）和一个记录栈顶索引的值（topOfStack）（当空栈时索引为-1）</li></ul><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><ul><li><code>push</code>：入栈操作，将<code>topOfStack+1</code>，然后令<code>stackArray[topOfStack]=newElement;</code></li><li><code>pop</code>：出栈操作，<code>outElement=stackArray[topOfStack]</code>，然后将<code>topOfStack-1</code></li><li><code>top</code>：返回栈顶元素，返回<code>stackArray[topOfStack]</code></li></ul><p>所有操作均为<strong>常数时间O(1)</strong>运行</p><h1 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h1><p>队列也是表，是一种<strong>先进先出</strong>（First In First Out，<strong>FIFO</strong>）的数据结构，入队列的一端成为队尾，出队列的一端成为队头。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cdn.littlegenius.xin/DataStructure2-2.png" alt="队列" title="">                </div>                <div class="image-caption">队列</div>            </figure><h2 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h2><p>队列也可以使用链表来实现，但通常使用循环数组来实现。</p><p>一个队列需要一个用于存储队列中数据的数组queueArray和两个位置front、back，用于记录队列的两端。为了判定队列是否空还是满，通常还增设一个元素currentSize来记录队列中现有的元素个数。 </p><h2 id="常用操作-1"><a href="#常用操作-1" class="headerlink" title="常用操作"></a>常用操作</h2><ul><li><p><code>enqueue</code>：入队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">back = (back+<span class="number">1</span>)%queueArray.<span class="built_in">size</span>();</span><br><span class="line">queueArray[back]=newElement;</span><br><span class="line">currentSize++;</span><br></pre></td></tr></table></figure></li><li><p><code>dequeue</code>：出队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">outElement = queueArray[front];</span><br><span class="line">fornt = (front+<span class="number">1</span>)%queueArray.<span class="built_in">size</span>();</span><br><span class="line">currentSize--;</span><br></pre></td></tr></table></figure></li><li><p><code>back</code>：返回队尾元素，直接返回<code>queueArray[back]</code></p></li><li><p><code>front</code>：返回队头元素，直接返回<code>queueArray[front]</code></p></li></ul><p>以上操作均以<strong>常数时间O(1)</strong>运行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;栈（stack）&quot;&gt;&lt;a href=&quot;#栈（stack）&quot; class=&quot;headerlink&quot; title=&quot;栈（stack）&quot;&gt;&lt;/a&gt;栈（stack）&lt;/h1&gt;&lt;p&gt;栈（stack）是限制插入和删除操作只能在末尾位置上进行的表，该末尾成为栈的顶（top）。是
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://blogs.littlegenius.xin/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习笔记" scheme="https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++" scheme="https://blogs.littlegenius.xin/tags/C/"/>
    
      <category term="数据结构" scheme="https://blogs.littlegenius.xin/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
