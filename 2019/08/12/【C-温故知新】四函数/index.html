<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>【C++温故知新】（四）函数 | 小天才的杂货铺</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="学习笔记,C++">
    <meta name="description" content="函数基础函数的定义12345typeName functionName(parameterList)&amp;#123;statement;return value;&amp;#125; 函数有多个参数，使用逗号间隔。 函数在执行完第一个 return 语句后结束，如果返回值是void，可以直接使用 return; 或者不写返回语句。 函数原型函数原型描述了函数到编译器的接口，需要写在main函数前边，通常放在头">
<meta property="og:type" content="article">
<meta property="og:title" content="【C++温故知新】（四）函数">
<meta property="og:url" content="https://blogs.littlegenius.xin/2019/08/12/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E5%9B%9B%E5%87%BD%E6%95%B0/index.html">
<meta property="og:site_name" content="小天才的杂货铺">
<meta property="og:description" content="函数基础函数的定义12345typeName functionName(parameterList)&amp;#123;statement;return value;&amp;#125; 函数有多个参数，使用逗号间隔。 函数在执行完第一个 return 语句后结束，如果返回值是void，可以直接使用 return; 或者不写返回语句。 函数原型函数原型描述了函数到编译器的接口，需要写在main函数前边，通常放在头">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://cdn.littlegenius.xin/CPP4-1.png">
<meta property="og:image" content="http://cdn.littlegenius.xin/CPP4-2.png">
<meta property="og:image" content="http://cdn.littlegenius.xin/CPP4-3.png">
<meta property="article:published_time" content="2019-08-12T04:44:00.000Z">
<meta property="article:modified_time" content="2019-08-18T03:22:11.538Z">
<meta property="article:author" content="MA Haozhe">
<meta property="article:tag" content="学习笔记">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://cdn.littlegenius.xin/CPP4-1.png">
    
        <link rel="alternate" type="application/atom+xml" title="小天才的杂货铺" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/logo.png">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpeg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">MA Haozhe</h5>
          <a href="mailto:mhz2180572509@163.com" title="mhz2180572509@163.com" class="mail">mhz2180572509@163.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                存档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/mhz2180572509" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://www.littlegenius.xin" target="_blank" >
                <i class="icon icon-lg icon-link"></i>
                个人网站
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">【C++温故知新】（四）函数</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">【C++温故知新】（四）函数</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-08-12T04:44:00.000Z" itemprop="datePublished" class="page-time">
  2019-08-12
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/C/">C++</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#函数基础"><span class="post-toc-number">1.</span> <span class="post-toc-text">函数基础</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#函数的定义"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">函数的定义</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#函数原型"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">函数原型</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#函数与一些数据类型"><span class="post-toc-number">2.</span> <span class="post-toc-text">函数与一些数据类型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#数组"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">数组</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使用const来保护数组"><span class="post-toc-number">2.1.1.</span> <span class="post-toc-text">使用const来保护数组</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使用数组区间的函数"><span class="post-toc-number">2.1.2.</span> <span class="post-toc-text">使用数组区间的函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#指针、数组与函数的参数传递"><span class="post-toc-number">2.1.3.</span> <span class="post-toc-text">指针、数组与函数的参数传递</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#二维数组"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">二维数组</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#C风格字符串"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">C风格字符串</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#作为参数"><span class="post-toc-number">2.3.1.</span> <span class="post-toc-text">作为参数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#作为返回值"><span class="post-toc-number">2.3.2.</span> <span class="post-toc-text">作为返回值</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#结构体"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">结构体</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#传递结构的值"><span class="post-toc-number">2.4.1.</span> <span class="post-toc-text">传递结构的值</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#传递结构的地址"><span class="post-toc-number">2.4.2.</span> <span class="post-toc-text">传递结构的地址</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#string对象"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">string对象</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#array对象"><span class="post-toc-number">2.6.</span> <span class="post-toc-text">array对象</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#递归"><span class="post-toc-number">3.</span> <span class="post-toc-text">递归</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#函数指针"><span class="post-toc-number">4.</span> <span class="post-toc-text">函数指针</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#获取函数指针"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">获取函数指针</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#声明函数指针"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">声明函数指针</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#使用指针调用函数"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">使用指针调用函数</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#函数指针数组"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">函数指针数组</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#内联函数"><span class="post-toc-number">5.</span> <span class="post-toc-text">内联函数</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#引用变量"><span class="post-toc-number">6.</span> <span class="post-toc-text">引用变量</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#引用和指针"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">引用和指针</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#将引用用作函数参数"><span class="post-toc-number">6.2.</span> <span class="post-toc-text">将引用用作函数参数</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#将引用用于结构"><span class="post-toc-number">6.3.</span> <span class="post-toc-text">将引用用于结构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#将引用用于结构-1"><span class="post-toc-number">6.3.1.</span> <span class="post-toc-text">将引用用于结构</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#对返回值使用const"><span class="post-toc-number">6.3.2.</span> <span class="post-toc-text">对返回值使用const</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#何时使用引用参数"><span class="post-toc-number">6.4.</span> <span class="post-toc-text">何时使用引用参数</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#默认参数"><span class="post-toc-number">7.</span> <span class="post-toc-text">默认参数</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#函数重载"><span class="post-toc-number">8.</span> <span class="post-toc-text">函数重载</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#重载的一些原则"><span class="post-toc-number">8.1.</span> <span class="post-toc-text">重载的一些原则</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#函数模板"><span class="post-toc-number">9.</span> <span class="post-toc-text">函数模板</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#模板函数的定义与使用"><span class="post-toc-number">9.1.</span> <span class="post-toc-text">模板函数的定义与使用</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#模板函数的重载"><span class="post-toc-number">9.2.</span> <span class="post-toc-text">模板函数的重载</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#函数模板的局限性"><span class="post-toc-number">9.3.</span> <span class="post-toc-text">函数模板的局限性</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#显式具体化"><span class="post-toc-number">9.4.</span> <span class="post-toc-text">显式具体化</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#实例化与具体化"><span class="post-toc-number">9.5.</span> <span class="post-toc-text">实例化与具体化</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-【C-温故知新】四函数"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">【C++温故知新】（四）函数</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-08-12 12:44:00" datetime="2019-08-12T04:44:00.000Z"  itemprop="datePublished">2019-08-12</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/C/">C++</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h1><h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">typeName <span class="title">functionName</span><span class="params">(parameterList)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">statement;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数有多个参数，使用逗号间隔。</p>
<p>函数在执行完第一个 <code>return</code> 语句后结束，如果返回值是<code>void</code>，可以直接使用 <code>return</code>; 或者不写返回语句。</p>
<h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h2><p>函数原型描述了函数到编译器的接口，需要写在main函数前边，通常放在头文件引用后。函数原型需要说明函数的<strong>返回类型、函数名、函数的参数类型</strong>，不需要写变量名，以分号结尾。</p>
<h1 id="函数与一些数据类型"><a href="#函数与一些数据类型" class="headerlink" title="函数与一些数据类型"></a>函数与一些数据类型</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>函数是使用指针来处理数组的。已知C++中将数组名解释为该数组中第一个元素的地址，即 <code>arrayName = &amp;arrayName[0]</code>，在函数中，当将数组作为函数的参数传递时，实际上传递的是数组的第一个元素的地址，即在调用函数时，传入的参数是数组名。</p>
<p>以数组为参数的函数声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">arrayFunction</span><span class="params">(<span class="keyword">int</span> arr [], <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>调用该函数时，只将数组的名字作为参数传入（即传入的是指向数组首元素的指针）即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> myArray[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> result = arrayFunction(myArray,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>所以实际上传入的类型应该是一个<code>int</code>的指针，也就是说函数其实是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">arrayFunction</span><span class="params">(<span class="keyword">int</span> * arr, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://cdn.littlegenius.xin/CPP4-1.png" alt="将数组作为参数出入函数" title="">
                </div>
                <div class="image-caption">将数组作为参数出入函数</div>
            </figure>

<p>可以看到，我们使用 <code>int arr []</code> 替换了 <code>int *arr</code> 。既然这两个函数头都是正确的，那么就证明了一个问题：在C++中，当(且仅当）用于函数头或函数原型中，<code>int* arr</code> 和 <code>int arr[]</code> 的含义才是相同的，它们都表示<code>arr</code>是一个<code>int</code>指针。然而，数组表示法（<code>int ar[]</code>）提醒用户，<code>arr</code>不仅指向<code>int</code>，还指向<code>int</code>数组的第一个<code>int</code>值。<br><strong>但是！</strong>在其他的上下文中，<code>int*ar</code> 和 <code>int arr[]</code> 的含义并不相同。</p>
<p>数组名与指针对应是一件好事。将数组地址作为参数可以节省复制整个数组所需的时间和内存。如果数组很大，则使用拷贝的系统开销将非常大，程序不仅需要更多的计算机内存，还需要花费时间来复制大块的数据。但是另一方面，使用原始数据增加了破坏数据的风险，所以要尽可能的使用const限定词来保护数组。</p>
<h3 id="使用const来保护数组"><a href="#使用const来保护数组" class="headerlink" title="使用const来保护数组"></a>使用const来保护数组</h3><p>由于数组名与指针对应，所以数组是按照引用传递的，不是按值传递，因此保护传入的数组不被函数修改破坏非常重要，因此如果函数内部没有修改传入的数组的理由（例如便利打印数组），则最好用<code>const</code>来限定参数，从而起到保护数组的作用。</p>
<p>通常分为如下两种声明方法：</p>
<ul>
<li><code>void functionModify(int arr[], int size);</code></li>
<li><code>void functionNoChange(const int arr[], int size);</code></li>
</ul>
<h3 id="使用数组区间的函数"><a href="#使用数组区间的函数" class="headerlink" title="使用数组区间的函数"></a>使用数组区间的函数</h3><p>传统的传递数组到函数中的方式为：传递一个数组名称作为指向第一个元素的指针，再传递一个整数告知函数数组的大小。</p>
<p>还有一种方式是通过传递两个指针来告知函数要处理的元素区间（range），一个指针标识数组的开头，另一个指针标识数组的结尾。例如下边这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumArray</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> * <span class="built_in">begin</span>, <span class="keyword">const</span> <span class="keyword">int</span> * <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * pt;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(pt=<span class="built_in">begin</span>;pt!=<span class="built_in">end</span>;pt++)</span><br><span class="line">sum+=*pt;</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> arrayName[arraySize]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> sum = sumArray(arrayName,arrayName+arraySize);</span><br></pre></td></tr></table></figure>

<h3 id="指针、数组与函数的参数传递"><a href="#指针、数组与函数的参数传递" class="headerlink" title="指针、数组与函数的参数传递"></a>指针、数组与函数的参数传递</h3><p>我们知道，函数对于传递数组作为参数，根据函数是否有权限改变数组的值，通常有两种声明方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionModify</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;	<span class="comment">// 1号函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionNoChange</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> arr[], <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;	<span class="comment">// 2号函数</span></span><br></pre></td></tr></table></figure>

<p>此时，如果我们有两个数组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cosnt <span class="keyword">int</span> array1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;	<span class="comment">// 1号数组</span></span><br><span class="line"><span class="keyword">int</span> array2 = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;	<span class="comment">// 2号数组</span></span><br></pre></td></tr></table></figure>

<p>很明显，一个是常量数组，一个是变量数组。两种数组对于两个函数的关系是这样的：</p>
<ul>
<li>禁止将常量数组的地址赋给非常量指针，即：1号数组不能传递给2号函数，只能传递给1号函数</li>
<li>可以将非常量数组赋给常量或非常量指针，即：2号数组可以被传递给1和2号函数</li>
</ul>
<p>因此，在设计函数时，要尽可能地使用const，因为将指针参数声明为指向常量数据的指针可以：</p>
<ul>
<li>避免由于无意间修改数据而导致的编程错误</li>
<li>使用const使得函数能够处理const和非const实参，否则将只能接受非const数据</li>
</ul>
<p>所以，如果条件允许，则应将指针形参声明为指向<code>const</code>的指针</p>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>编写以二维数组作为参数的方法如下：首先，数组名称被视为其地址，而且数组名可以认为是指向第一层元素的指针（第一层的元素是数组（第二层））。</p>
<p>例如下边的这个数组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> data[<span class="number">3</span>][<span class="number">4</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;, &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;, &#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>可以这样声明一个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span> <span class="params">(<span class="keyword">int</span> (*arr)[<span class="number">4</span>], <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>或者这样声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span> <span class="params">(<span class="keyword">int</span> arr[][<span class="number">4</span>], <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>然后这样使用它：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = sum(data,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>可以看到，传入的参数是数组名，即表示大数组data中第一个元素的引用，而这个元素又是一个4维的数组，所以其实传入的第一个参数是一个<strong>指向由4个int组成的数组的指针</strong>。而且，第一种声明方式中，必须将 <code>*arr</code> 用括号括起来，否则 <code>int *arr[4]</code> 将表示的是一个由4个指向int的指针组成的数组，然而函数的参数不可能是数组。以上两种声明方式都表明 arr 是指针而不是数组，只是在声明时需要表明它是一个由4个int组成的数组罢了，这也就意味着已经将数组的列数传入函数，所以只需要单独传入一个行数作为参数即可。</p>
<p>在函数中，可以直接将 arr 看成数组名，然后像这样使用它：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result+=arr[i][j];</span><br></pre></td></tr></table></figure>
<p>显然，这里存在如下的一个关系：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[i][j] == *(*(arr+i)+j)</span><br></pre></td></tr></table></figure>
<p>实际上，是这样推演过来的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr  <span class="comment">// 指向第一行的由4个int组成的数组的指针</span></span><br><span class="line">arr+i  <span class="comment">// 指向低i行的元素的指针（这个元素是一个4元int数组）</span></span><br><span class="line">*(arr+i)  <span class="comment">// 第i行的元素，也就是第i行数组，即第i行的指向这个数组第一个元素的指针，等同于 arr[i]</span></span><br><span class="line">*(arr+i)+j  <span class="comment">// 指向第i行第j个元素的指针，等同于 arr[i]+j</span></span><br><span class="line">*(*arr+i)+j)  <span class="comment">// 第i行第j列的元素值，等同于 arr[i][j]</span></span><br></pre></td></tr></table></figure>

<h2 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a>C风格字符串</h2><p>C风格字符串只一系列字符，以空值结尾的字符串。</p>
<h3 id="作为参数"><a href="#作为参数" class="headerlink" title="作为参数"></a>作为参数</h3><p>将C风格的字符串作为参数传递给函数，有三种表示字符串的方式：</p>
<ul>
<li>char数组</li>
<li>用引号括起来的字符串常量（字符串字面值）</li>
<li>被设置为字符串的地址的char指针</li>
</ul>
<p>但其实这三种方式都是传递了一个char指针（<code>char*</code>），由于C风格的字符串与一般的char数组的最主要区别是，C风格字符串自带了结束字符（\0），所以不需再传入一个数组的长度作为参数。</p>
<p>变量的声明与传入函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> myChar[<span class="number">6</span>] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> * ch = <span class="string">"hello"</span>;</span><br><span class="line">charFunction(myChar);  <span class="comment">// myChar 是hello的第一个元素（h）的地址</span></span><br><span class="line">charFunction(ch);  <span class="comment">// ch是指向char（h）的一个指针</span></span><br><span class="line">charFunction(<span class="string">"hello"</span>);  <span class="comment">// 直接传入字符串的地址</span></span><br></pre></td></tr></table></figure>

<p>函数原型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">charFunction(<span class="keyword">char</span> * str);</span><br><span class="line">charFunction(<span class="keyword">char</span> str[]);</span><br></pre></td></tr></table></figure>

<p>函数中对参数的使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">charFunction(<span class="keyword">const</span> <span class="keyword">char</span> * str)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(*str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*str;</span><br><span class="line">        str++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="作为返回值"><a href="#作为返回值" class="headerlink" title="作为返回值"></a>作为返回值</h3><p>函数无法直接返回一个字符串，但是可以返回字符串的地址，比如可以这样声明一个返回值为字符串的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">buildChar</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * pstr = <span class="keyword">new</span> <span class="keyword">char</span>[n+<span class="number">1</span>];</span><br><span class="line">    pstr[n]=<span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--&gt;<span class="number">0</span>)</span><br><span class="line">		pstr[n]=c;</span><br><span class="line">    <span class="keyword">return</span> pstr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="传递结构的值"><a href="#传递结构的值" class="headerlink" title="传递结构的值"></a>传递结构的值</h3><p>当结构体较小时，按值传递结构比较合理，且安置传递可以将结构体看成和int、double等一样的普通单值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> myInt;</span><br><span class="line">    <span class="keyword">double</span> myDouble;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">myStruct <span class="title">sum</span><span class="params">(myStruct str1, myStruct str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    myStruct result;</span><br><span class="line">    result.myInt = str1.myInt + str2.myInt;</span><br><span class="line">    result.myDouble = str1.myDouble + str2.myDouble;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="传递结构的地址"><a href="#传递结构的地址" class="headerlink" title="传递结构的地址"></a>传递结构的地址</h3><p>当结构体较大时，传递结构体的地址更为合理，可以节省时间与空间，此时需要将参数由结构体变成指向它的指针，并且访问结构体内的元素时需要使用 <code>-&gt;</code> 代替点：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStruct</span><span class="params">(<span class="keyword">const</span> myStruct * str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"myInt = "</span>&lt;&lt;str-&gt;myInt;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"myDouble = "</span>&lt;&lt;str-&gt;myDouble;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="string对象"><a href="#string对象" class="headerlink" title="string对象"></a>string对象</h2><p>由于string是对象，对象是可以赋值的，所以和结构体类似，可以直接将string的实体按值传递给函数，也可以直接从函数返回，如果需要多个string，可以使用string的数组而不需要一个char的二维数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pringStrings</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> str[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">" : "</span>&lt;&lt; str[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="array对象"><a href="#array对象" class="headerlink" title="array对象"></a>array对象</h2><p>array对象也是对象，所以依然有两种传递给函数的方式：按值传递和按引用传递（传递地址）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="built_in">array</span>&lt;<span class="keyword">int</span>,<span class="number">3</span>&gt; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="built_in">array</span>&lt;<span class="keyword">int</span>,<span class="number">3</span>&gt; * arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">3</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;(*arr)[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>递归就是函数自己调用自己。在递归的过程中，需要设置终止条件，否则将无限循环下去，例如下边的test为false时将会断开递归。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recurs</span><span class="params">(argumentlist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    statements1;</span><br><span class="line">    <span class="keyword">if</span>(test)</span><br><span class="line">        recurs(arguments)</span><br><span class="line">    statements2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归对于函数的调用是基于栈这种数据结构的，即后进先出，例如三次递归上边的函数，会首先有三次statements1，然后发现终止条件满足后再倒叙执行三次statements2，形成一个栈的后进先出的结果。</p>
<p>函数递归一般会在时间上对于程序有所缩短，但是占用内存的开销却一般较大，因为所以未完成递归的函数都需要存储在内存中，直到整个递归结束才会释放。</p>
<h1 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h1><p>函数也有地址，指向函数的存储地址的数据类型为函数指针，在存储机器语言代码的内存块中，函数指针指向这个函数的内存块的开始地址。利用函数指针，我们可以使用一个函数找到另一个函数，亦或者让函数成为另一个函数的变量。那为什么不直接使用函数调用呢？因为函数调用的代码是写好的，只能调用那一个固定的函数，但是函数指针如果作为一个变量来使用的话，可以传入不同的值，即可以选择使用不同的函数。</p>
<h2 id="获取函数指针"><a href="#获取函数指针" class="headerlink" title="获取函数指针"></a>获取函数指针</h2><p>函数名（不带参数）即为指向该函数的指针，若将函数作为参数传递，必须传递函数名（函数指针）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">invoke(myFunction); <span class="comment">// 传入的是函数指针，即函数</span></span><br><span class="line">invoke(myFunction()); <span class="comment">// 传入的是函数的返回值</span></span><br></pre></td></tr></table></figure>

<h2 id="声明函数指针"><a href="#声明函数指针" class="headerlink" title="声明函数指针"></a>声明函数指针</h2><p>声明函数指针时必须指定指针指向的函数类型，即说明函数的返回类型与参数列表，和函数原型的声明方式非常类似。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myFunction</span><span class="params">(<span class="keyword">double</span>)</span></span>; <span class="comment">// 函数原型</span></span><br><span class="line"><span class="keyword">int</span> (*myFunctionPoint)(<span class="keyword">double</span>); <span class="comment">// myFunction是函数指针</span></span><br></pre></td></tr></table></figure>

<p>这里将 <code>(*myFunctionPoint)</code> 替换了 <code>myFunction</code> ，从而 <code>myFunction</code>是函数名， <code>myFunctionPoint</code>是函数指针</p>
<p>注意区分如下的两种情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*myFunctionPoint)(<span class="keyword">double</span>); <span class="comment">// myFunction是函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">myFunction</span><span class="params">(<span class="keyword">double</span>)</span></span>; <span class="comment">// 返回一个指向int的指针的函数</span></span><br></pre></td></tr></table></figure>

<p>在正确的声明函数指针后，要通过赋值使得函数指针指向函数，由于上文提到函数名（不带参数）即是函数的地址，从而赋值的方式就很简单（赋值必须保证返回类型和参数列表均相同）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myFunctionPoint = myFunction; <span class="comment">// 左侧为函数指针，右侧为函数的地址</span></span><br></pre></td></tr></table></figure>

<h2 id="使用指针调用函数"><a href="#使用指针调用函数" class="headerlink" title="使用指针调用函数"></a>使用指针调用函数</h2><p>已知，<code>(*myFunctionPoint)</code>和<code>myFunction</code>扮演的角色相同，所以可以使用任何一种形式来调用这个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = myFunction(<span class="number">1.2</span>); <span class="comment">// 使用函数名调用函数</span></span><br><span class="line"><span class="keyword">int</span> result = (*myFunctionPoint)(<span class="number">5.6</span>); <span class="comment">// 使用函数指针调用函数</span></span><br><span class="line"><span class="keyword">int</span> result = myFunctionPoint(<span class="number">3.7</span>); <span class="comment">// 实际上这也是一种可行的方式</span></span><br></pre></td></tr></table></figure>

<h2 id="函数指针数组"><a href="#函数指针数组" class="headerlink" title="函数指针数组"></a>函数指针数组</h2><p>函数指针的神奇之处在于它可以保存成数组类型。假设我们有三个返回类型和参数列表均相同但是作用却不同的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f3</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们可以使用一个指向这种函数类型的函数指针的数组来存储这三个函数的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> (*fp[<span class="number">3</span>]) (<span class="keyword">int</span>) = &#123;f1,f2,f3&#125;;</span><br></pre></td></tr></table></figure>

<p>现在说明一下数组索引3的位置：fp是一个包含三个元素的数组，而要声明这样的数组，首先需要使用<code>fp[3]</code>，该声明的其他部分指出了数组包含的元素是什么样的。运算符<code>[]</code>的优先级高于<code>*</code>，因此<code>fp[3]</code>表明<code>fp</code>是一个包含三个指针的数组。上述声明的其他部分指出了每个指针指向的是什么：参数为int，且返回类型为double的函数。因此，<code>fp</code>是一个包含三个指针的数组，其中每个指针都指向这样的函数，即将int作为参数，并返回一个double。</p>
<p><strong>注意</strong>，此处无法使用auto赋值，因为auto只能用于单值初始化，无法用于初始化列表。</p>
<p>接下来使用该数组调用函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> = fp[<span class="number">0</span>](<span class="number">1</span>);</span><br><span class="line"><span class="keyword">double</span> = (*fp[<span class="number">1</span>])(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><p>内联函数与其他函数的区分之处在于编译器对函数的处理方式，常规函数在编译时，函数调用就是函数调用，在调用到该函数时，运行程序会跳转到存储该函数的代码块去执行这个函数，执行结束后再跳转回来继续执行；而内联函数再编译时直接将整个函数编译到调用的地方，即用函数的内容替换函数调用。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://cdn.littlegenius.xin/CPP4-2.png" alt="内联函数与常规函数" title="">
                </div>
                <div class="image-caption">内联函数与常规函数</div>
            </figure>

<p>这个性质就决定了，内联函数最好是简单的函数，如果函数过于复杂，不适合被声明为内联函数，因为如果复杂的函数作为了内联函数，那么编译时每一个函数调用都会复制一次整个函数放在调用的位置，是非常耗费空间的。但是对于简单的却调用次数很多的函数，适合声明为内联函数，这样其实相当于将一些多次多处重复的代码单独拎出来写了，但是编译时编译器帮你放了回去。</p>
<p>内联函数的声明方法：在函数生命和定义前都加上关键词 inline，而且通常由于内联函数很简单，会直接写在原型处：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="keyword">return</span> x*x; &#125;</span><br></pre></td></tr></table></figure>


<h1 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h1><p>引用变量被定义为一个变量的别名，即引用变量和其指向的变量代表同一个值，指向同一个存储单元，并且引用变量自从赋值起就已知跟着这个变量，不会再发生改变，也就是一个变量两个名字，所以更改其中的任何一个这个变量都会发生改变。</p>
<p><code>&amp;</code>符号可以指示变量的地址，同时它的另一个含义就是用来声明引用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> genius;</span><br><span class="line"><span class="keyword">int</span> &amp; me = genius;</span><br></pre></td></tr></table></figure>

<p>这里的<code>&amp;</code>不是地址运算符，而是类型标识符的一部分，就像<code>int *</code>是<code>int</code>类型的指针一样，<code>int &amp;</code>是指向<code>int</code>的引用。上述声明将me和genius等价，它们指向相同的值和内存单元，就是说me就是genius，而genius就是me。</p>
<h2 id="引用和指针"><a href="#引用和指针" class="headerlink" title="引用和指针"></a>引用和指针</h2><p>引用和指针貌似很相像，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> genius = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> &amp; me = genius;</span><br><span class="line"><span class="keyword">int</span> * myself = &amp;genius;</span><br></pre></td></tr></table></figure>
<p>这样，神奇的事情来了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">me == *myself == genius</span><br><span class="line">&amp;me == myself == &amp;genius</span><br></pre></td></tr></table></figure>
<p>引用与指针也有区别，例如必须再声明时将引用的值初始化，不能像指针一样，先声明在赋值；而且引用变量一旦赋值将不会再更改，这一点更接近于const指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp; me = genius;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> myself = &amp;genius;</span><br></pre></td></tr></table></figure>
<p>从而，<code>me == *myself</code></p>
<h2 id="将引用用作函数参数"><a href="#将引用用作函数参数" class="headerlink" title="将引用用作函数参数"></a>将引用用作函数参数</h2><p>按值传递与按引用传递</p>
<ul>
<li>按值传递：函数复制一份传入的值，然后对复制的数据进行操作，与被传入的数据无关</li>
<li>按引用传递：函数直接使用传入的数据，不对其进行拷贝，修改的内容会直接体现在原数据上，这一点可以轻松地使用引用变量完成，抑或通过使用指针传递变量的地址来完成</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://cdn.littlegenius.xin/CPP4-3.png" alt="按值传递与按引用传递" title="">
                </div>
                <div class="image-caption">按值传递与按引用传递</div>
            </figure>

<p>例如，完成一个交换两个变量的值的函数：</p>
<p>按值传递</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapByValue</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按引用传递：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapByReference</span><span class="params">(<span class="keyword">int</span> &amp; a, <span class="keyword">int</span> &amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按地址（指针）传递:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapByPoint</span><span class="params">(<span class="keyword">int</span> * a, <span class="keyword">int</span> * b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三种函数的调用方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">swapByValue(intA, intB);</span><br><span class="line">swapByReference(intA, intB);</span><br><span class="line">swapByPoint(&amp;intA, &amp;intB);</span><br></pre></td></tr></table></figure>

<p>可以看出，按指针传递的声明方法和调用方法与其他两种均不同，需要在函数定义时告知传入的变量时 <code>int*</code> 类型，在调用时传入变量的地址 <code>&amp;intA</code> 才可以；按值传递和按引用传递的调用方式相同，直接将变量名传入，只有在定义函数处才可以直到两者的不同，一个是按值传递，一个指出了是按地址传递 <code>&amp; int</code>。</p>
<p>按引用传递的一个重要方面是被传入的值会被直接使用或者修改，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">squareByValue</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a *= a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">squareByReference</span><span class="params">(<span class="keyword">int</span> &amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a *= a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用时会出现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a =<span class="number">2</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; squareByValue(a) &lt;&lt; <span class="string">" = square of "</span> &lt;&lt; a; <span class="comment">// 输出：4 = square of 2</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; squareByReference(a) &lt;&lt; <span class="string">" = square of "</span> &lt;&lt; a; <span class="comment">// 输出：4 = square of 4</span></span><br></pre></td></tr></table></figure>
<p>可见，按照引用传递时，被传入的变量的更改会影响到原始的变量。</p>
<h2 id="将引用用于结构"><a href="#将引用用于结构" class="headerlink" title="将引用用于结构"></a>将引用用于结构</h2><p>声明一个结构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> myInt;</span><br><span class="line">    <span class="keyword">double</span> myDouble;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="将引用用于结构-1"><a href="#将引用用于结构-1" class="headerlink" title="将引用用于结构"></a>将引用用于结构</h3><p>将结构的引用作为参数传递非常简单，同时需要注意的是最好使用引用作为返回值。否则的话，函数需要先将待返回的结构体赋予一个临时变量，然后将这个临时变量返回，这是非常耗费时间和空间的。所以应该像这样使用它们：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">myStruct &amp; <span class="title">sum</span><span class="params">(myStruct &amp; target, <span class="keyword">const</span> myStruct &amp; source)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    target.myInt += source.myInt;</span><br><span class="line">    target.myDouble += source.myDouble;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用该函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myStruct target = &#123;<span class="number">1</span>,<span class="number">2.5</span>&#125;;</span><br><span class="line">myStruct source = &#123;<span class="number">2</span>,<span class="number">3.8</span>&#125;;</span><br><span class="line">myStruct result;</span><br><span class="line">result = sum(target, source);</span><br></pre></td></tr></table></figure>

<h3 id="对返回值使用const"><a href="#对返回值使用const" class="headerlink" title="对返回值使用const"></a>对返回值使用const</h3><p>如果不对返回值使用const，意味着返回值是可以被赋值的，即下边的表达式成立：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(target, source) = anotherStruct;</span><br></pre></td></tr></table></figure>
<p>未来避免这种情况发生，可以使用const限定返回值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> myStruct &amp; <span class="title">sum</span><span class="params">(myStruct &amp; target, <span class="keyword">const</span> myStruct &amp; source)</span></span>;</span><br></pre></td></tr></table></figure>
<p>从而如下的语句都不能成立：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum(target, source) = anotherStruct;</span><br><span class="line">sum(sum(target, source), source);</span><br></pre></td></tr></table></figure>
<p>因为无法将一个有const限定的变量传递给一个没有const限定的变量，但是可以将返回值赋给其他结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = sum(target, source);</span><br></pre></td></tr></table></figure>

<h2 id="何时使用引用参数"><a href="#何时使用引用参数" class="headerlink" title="何时使用引用参数"></a>何时使用引用参数</h2><p>使用引用参数的主要原因有两个：</p>
<ul>
<li>程序员能够修改调用函数中的数据对象</li>
<li>通过传递引用而不是整个数据对象，可以提高程序的运行速度</li>
</ul>
<p>当数据对象较大时（如结构和类对象），第二个原因最重要。这些也是使用指针参数的原因。这是有道理的，因为引用参数实际上是基于指针的代码的另一个接口。那么，什么时候应使用引用、什么时候应使用指针呢？什么时候应按值传递呢？下面是一些<strong>参考原则</strong>：</p>
<ul>
<li>对于使用传递的值而不作修改的函数<ul>
<li>如果数据对象很小，如内置数据类型或小型结构，则按值传递</li>
<li>如果数据对象是数组，则使用指针，因为这是唯一的选择，并将指针声明为指向const的指针</li>
<li>如果数据对象是较大的结构，则使用const指针或const引用，以提高程序的效率。这样可以节省复制结构所需的时间和空间。</li>
<li>如果数据对象是类对象，则使用const引用。传递类对象参数的标准方式是按引用传递</li>
</ul>
</li>
<li>对于修改调用函数中数据的函数<ul>
<li>如果数据对象是内置数据类型，则使用指针</li>
<li>如果数据对象是数组，则只能使用指针</li>
<li>如果数据对象是结构，则使用引用或指针</li>
<li>如果数据对象是类对象，则使用引用</li>
</ul>
</li>
</ul>
<h1 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h1><p>默认参数显然就是在调用函数时，如果没有主动传入参数，可以直接使用默认的参数。</p>
<p>默认参数的写法只需在函数原型中的参数后跟上默认值即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myFunction</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>, <span class="keyword">double</span> = <span class="number">1.0</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>默认参数的原则如下：</p>
<ul>
<li><p>在参数列表中，带有默认参数的参数必须放到所有参数的右边，即从某个参数开始，后边的如果是带有默认参数的就都是带有默认参数的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myFunction</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">double</span> n = <span class="number">1.0</span>, <span class="keyword">char</span> c = <span class="string">'c'</span>)</span></span>; <span class="comment">// 这是可行的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myFunction</span><span class="params">(<span class="keyword">int</span> m, doubel n = <span class="number">1.0</span>, <span class="keyword">char</span> c)</span></span>; <span class="comment">// 这是不行的</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>调用函数时，可以不传入有默认值的参数，但是所有参数赋值必须从左到右，不能跳过某个参数值，比如上边的第一个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = myFunction(<span class="number">1</span>); <span class="comment">// 传一个参数，1，1.0，'c'</span></span><br><span class="line"><span class="keyword">int</span> result = myFunction(<span class="number">1</span>, <span class="number">2.0</span>); <span class="comment">// 传两个参数，1，2.0，'c'</span></span><br><span class="line"><span class="keyword">int</span> result = myFunction(<span class="number">1</span>, <span class="number">2.0</span>, <span class="string">'h'</span>); <span class="comment">// 传三个参数，1，2.0，'h'</span></span><br><span class="line"><span class="keyword">int</span> result = myFunction(<span class="number">1</span>, <span class="string">'h'</span>); <span class="comment">// 不允许</span></span><br><span class="line"><span class="keyword">int</span> result = myFunction(<span class="number">1</span>,  , <span class="string">'h'</span>); <span class="comment">// 不允许</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><p>函数重载提供的功能是，定义同名、同返回值，但是参数列表不同的函数，这样在调用时，编译器根据传入参数的类型自行选择使用哪一种函数。</p>
<p>加入我们定义了如下的三个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">int</span> i)</span></span>; <span class="comment">// #1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">double</span> d)</span></span>; <span class="comment">// #2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="built_in">string</span> s)</span></span>; <span class="comment">// #3</span></span><br></pre></td></tr></table></figure>

<p>在调用时会根据参数选择使用哪一种：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myPrint(<span class="number">1</span>); <span class="comment">// #1</span></span><br><span class="line">myPrint(<span class="number">2.5</span>); <span class="comment">// #2</span></span><br><span class="line">myPrint(<span class="string">"hello world!"</span>); <span class="comment">// #3</span></span><br></pre></td></tr></table></figure>

<h2 id="重载的一些原则"><a href="#重载的一些原则" class="headerlink" title="重载的一些原则"></a>重载的一些原则</h2><p>引用变量是无法作为两种重载函数的，比如有两个函数原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> &amp; x)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这样，在调用函数时出入参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> result = square(x);</span><br></pre></td></tr></table></figure>

<p>根本无法确定是使用哪种函数模型，所以在函数重载中，编译器将类型本身和类型的引用看成是一种参数。</p>
<p>在匹配函数时，并不区分const和非const的变量，如以下的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">char</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> c)</span></span>;</span><br></pre></td></tr></table></figure>

<p>广义上来讲这也是一种重载，但是由于const函数可以处理const变量和非const变量，而非const的函数只能处理非const变量，所以其实并不是严格意义上的重载函数</p>
<h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><p>函数模板的作用是允许我们使用泛型定义函数，然后根据具体的数据类型替换泛型。通过将类型作为参数传递给模板，可以是编译器生成该类的函数。</p>
<p>比如要交换两个变量的值，这时候我们写好了一个交换两个int值的函数，又需要一个交换两个double值的函数，我们需要将第一个函数重复一遍，然后再将其中的int替换成double，是非常复杂的。尤其是当一些算法可以应用于很多数据类型时，我们无法对每一种数据类型都写一套算法函数，这就时函数模板解决的问题。 </p>
<h2 id="模板函数的定义与使用"><a href="#模板函数的定义与使用" class="headerlink" title="模板函数的定义与使用"></a>模板函数的定义与使用</h2><p>我们可以先定义一个模板，然后用具体的数据类型替换，像下边这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T &amp;a, T &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T temp;</span><br><span class="line">	temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要建立一个模板，必须先使用<code>template</code>语法来定义一个模板变量T，这里也可以用旧的声明方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;;</span></span><br></pre></td></tr></table></figure>

<p>很多代码库都使用<code>class</code>开发的，这样的上下文中，两个关键词完全相同，如果不考虑向后兼容并且不介意输入长单词的话，使用<code>typename</code>而不使用<code>class</code> </p>
<p>调用模板函数时，和其他函数类似，编译器会根据我们传入的函数类型自行生成一个对应的函数，这个函数我们是看不到的，但是编译器会直接在背后生成并为我们使用好，例如调用下边的语句时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line">swap(i, j);</span><br></pre></td></tr></table></figure>

<p>这是，编译器会自动生成一个函数：使用int代替所有的T，从而完成相关的逻辑，这个函数我们看不到，但是没问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模板函数的重载"><a href="#模板函数的重载" class="headerlink" title="模板函数的重载"></a>模板函数的重载</h2><p>模板函数也是可以重载的，虽然泛型使我们合并解决了很多问题，但是有些数据类型是无法合并的。比如交换变量值的函数，我们可以将上述逻辑同时用于int、double、char、string等，但是却无法用于数组，因为数组需要将每个元素交换，于是可以使用函数模板的重载：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T &amp;a, T &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T []a, T[]b, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i] = b[i];</span><br><span class="line">        b[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以用同名函数swap交换任意数据类型和数组类型了。</p>
<h2 id="函数模板的局限性"><a href="#函数模板的局限性" class="headerlink" title="函数模板的局限性"></a>函数模板的局限性</h2><p>定义模板函数要考虑好这个函数应用的数据类型的范围，有些操作对于数据类型是很有局限性的，比如 a&gt;b 这种操作，只能用于 int、double 等，string和char显然无法使用 </p>
<h2 id="显式具体化"><a href="#显式具体化" class="headerlink" title="显式具体化"></a>显式具体化</h2><p>假如定义了一个结构:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> myInt;</span><br><span class="line">    <span class="keyword">double</span> myDouble;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时我们同样可以通过上面的swap函数交换两个struct的值，因为结构体是可以直接被赋给另一个结构体的。但是如果我们只想交换两个结构体的myInt变量，而不想交换myDouble变量呢，就无法使用上述模板函数了，但是由于这种情况下我们传入的参数还是和上述模板函数相同的（两个待交换的T），所以重载无法达到这个愿望。这就用到了显式具体化（explicit specialization）。</p>
<p>显示具体化是我们可以提供一个具体化的函数定义，其中包含这个特殊的处理情况下的代码，当编译器找到了与函数调用匹配的具体化定义时，就不再使用模板，而是用该具体化的定义：</p>
<ul>
<li>对于给定的函数名，可以有非模板函数、模板函数和显式具体化模板函数以及它们的重载函数四个版本</li>
<li>显式具体化的原型和定义以<code>&lt;template&gt;</code>打头，并通过名称来指出类型</li>
<li>非模板函数优先于具体化和常规模板，具体化模板优先于常规模板</li>
</ul>
<p>例如对于刚才的结构体，下面是用于交换逻辑的非模板函数、模板函数和具体化函数的原型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非模板函数 #1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(myStruct &amp;, myStruct &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板函数 #2</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T &amp;, T &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板具体化函数 #3</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">void</span> swap&lt;myStruct&gt;(myStruct &amp;, myStruct &amp;);</span><br></pre></td></tr></table></figure>

<p>在上述三个函数原型同时存在时，#1优先于#3优先于#2。在具体化函数模板中，可以省略函数名后的<code>&lt;myStruct&gt;</code>，因为参数类型已经表明了这是一个myStruct的具体化函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(myStruct &amp;, myStruct &amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="实例化与具体化"><a href="#实例化与具体化" class="headerlink" title="实例化与具体化"></a>实例化与具体化</h2><p>当我们定义了一个模板函数swap后，通过调用时传入了两个int值可以使得编译器在后台自动为我们实例化了一个int类型的函数，这个函数是编译中产生的，所以我们看不到，但是它确实是产生了，这个过程成为<strong>隐式实例化</strong>。</p>
<p>同时我们也可以进行<strong>显式实例化</strong>（explicit instantiation），即可以直接命令编译器创建特定的实例，比如一个处理int的swap函数，只需要这样声明它：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="keyword">void</span> swap&lt;<span class="keyword">int</span>&gt;(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>

<p>这是要和<strong>显示具体化</strong>（explicit specialization）区分开的，具体化是在<code>template</code>后还需要加一个<code>&lt;&gt;</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; &gt; <span class="keyword">void</span> swap&lt;<span class="keyword">int</span>&gt;(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">template</span> &lt; &gt; <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在<code>template</code>后有无<code>&lt;&gt;</code>是区分显示具体化和显示实例化的重要标志。</p>
<p>通常的，隐式实例化、显式实例化和显示具体化都被称为<strong>具体化</strong>（specialization）</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2019-08-18T03:22:11.538Z" itemprop="dateUpdated">2019-08-18 11:22:11</time>
</span><br>


        
        转载请注明出处，本文永久更新链接：<a href="/2019/08/12/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E5%9B%9B%E5%87%BD%E6%95%B0/" target="_blank" rel="external">https://blogs.littlegenius.xin/2019/08/12/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E5%9B%9B%E5%87%BD%E6%95%B0/</a>
        
    </div>
    
    <footer>
        <a href="https://blogs.littlegenius.xin">
            <img src="/img/avatar.jpeg" alt="MA Haozhe">
            MA Haozhe
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://blogs.littlegenius.xin/2019/08/12/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E5%9B%9B%E5%87%BD%E6%95%B0/&title=《【C++温故知新】（四）函数》 — 小天才的杂货铺&pic=https://blogs.littlegenius.xin/img/avatar.jpeg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://blogs.littlegenius.xin/2019/08/12/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E5%9B%9B%E5%87%BD%E6%95%B0/&title=《【C++温故知新】（四）函数》 — 小天才的杂货铺&source=仰望星空，脚踏实地" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://blogs.littlegenius.xin/2019/08/12/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E5%9B%9B%E5%87%BD%E6%95%B0/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《【C++温故知新】（四）函数》 — 小天才的杂货铺&url=https://blogs.littlegenius.xin/2019/08/12/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E5%9B%9B%E5%87%BD%E6%95%B0/&via=https://blogs.littlegenius.xin" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://blogs.littlegenius.xin/2019/08/12/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E5%9B%9B%E5%87%BD%E6%95%B0/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2019/08/18/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E4%BA%94%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">【C++温故知新】（五）多文件架构与名称空间</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/08/08/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%BA%8C%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">【数据结构】（二）栈与队列</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'false' == 'true',
            verify: 'false' == 'true',
            appId: "UazTKjXspk5Wqs8bdqcysAcV-gzGzoHsz",
            appKey: "Mp3bAKe3Phzr2OKV4XSNcQza",
            avatar: "mm",
            placeholder: "请多多指教！",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "20"
        })
    </script>
    <!-- Valine Comments end -->







</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢支持！
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.jpg" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="bottom">
        <p><span>MA Haozhe &copy; 2019</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a> Server <a href="https://pages.github.com/" target="_blank">GitHub Pages</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://blogs.littlegenius.xin/2019/08/12/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E5%9B%9B%E5%87%BD%E6%95%B0/&title=《【C++温故知新】（四）函数》 — 小天才的杂货铺&pic=https://blogs.littlegenius.xin/img/avatar.jpeg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://blogs.littlegenius.xin/2019/08/12/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E5%9B%9B%E5%87%BD%E6%95%B0/&title=《【C++温故知新】（四）函数》 — 小天才的杂货铺&source=仰望星空，脚踏实地" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://blogs.littlegenius.xin/2019/08/12/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E5%9B%9B%E5%87%BD%E6%95%B0/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《【C++温故知新】（四）函数》 — 小天才的杂货铺&url=https://blogs.littlegenius.xin/2019/08/12/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E5%9B%9B%E5%87%BD%E6%95%B0/&via=https://blogs.littlegenius.xin" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://blogs.littlegenius.xin/2019/08/12/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E5%9B%9B%E5%87%BD%E6%95%B0/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASYAAAEmCAAAAADqr2IGAAAEf0lEQVR42u3aS27jMBAFwNz/0jMHCGy/1y0BplJaBbEtUcVF//jzE1//fl2vvvP7+68+fXXn99f7JyZrfrX+Cy5MmDBhwvSVTMmykuW+Z0qwNgQ5R75JmDBhwoTpSUzJ7ZKImfzn/d2S+2zSl5YSEyZMmDD9NaZNgZoXyXkK0qJgwoQJEyZMeZmah/akTfw+tG9az5vyGBMmTJgwPYOpvd2m0M1Hj5vxZLJJt/TCMWHChAnTlzHlgfl5f198YcKECROmL2PaHA+dpQWzg0FtsG+f9eFXmDBhwoTpWKb2UE47RJw1WPPNmNG374sJEyZMmM5lypuqyfhz/2L5U9qtSt7oJSgmTJgwYTqc6Y6Gb/7p+4A9G68mJXQxrMWECRMmTMcy5Q3TvM2aBPW2cL0PvXgKJkyYMGE6nGlWBidkLcd9q0o24EP2hAkTJkyYjmJqX7sNokkTtm3a5nPa25u8mDBhwoTp65nywjUZFublbj683ATyNin5sBmYMGHChOlApjbw78vg9nBPmzrMhpoffoUJEyZMmI5luqNhWhyFKceWyWu3Q9k23cGECRMmTCcyJYG5TRfyhu8s4dikC/n71vkLJkyYMGH6eqZN+PwJrpyp6FKP0pRhLxwTJkyYMB3FtFn0jOyO++cl7rBgxoQJEyZMhzPlr3TtsZ48JCeF9wyoOJyKCRMmTJgewbRvueaB9tqGb/6d9igPJkyYMGE6l6l94RnoLeVojDh71u5LmDBhwoTpu5jy4yz3jRvbZ20o84NHmDBhwoTpdKY8oM4Q88A8G2q2R2bbRvPLqS8mTJgwYTqEKXnhfHCY3GGWfMwOGO2fhQkTJkyYTmfKG6b7ozCzJmy759c2lKOqHRMmTJgwfTHT7Gdt2zRJIzbEM7j8OBEmTJgwYTqXqW3yFi3R8ijPrE082566MMaECRMmTMcytWGyPe4T9ZjjjZklE8kd6uwJEyZMmDAdwtSG3uQBm2L12oQjSUeijcGECRMmTMcytU3bPLi26cWsfbxfW7FOTJgwYcJ0IFO+3Nmnm6M5s3Qkn9YW9JgwYcKE6RFMs8FeW7LO+GYJQbudHzImTJgwYcJ0LNMsALdHfN5TzlKEpE28PzaECRMmTJiexJSHyVlZOwveSeu5/TRvJWPChAkTpnOZ2iIzb63mrMk25PfPN68diGLChAkTphOZ2pvm/5+xtsX27M719mDChAkTpkcwzYaXbat3Q9C2m9v1v7wPJkyYMGF6BNM+GP/E1+z7baqRbFK0NkyYMGHCdCxTC5QPKdu/ZyF8U7qvLkyYMGHCdAjTLNC2I8ZZktEWuvlv23tiwoQJE6ZzmWYx8T1Tnjq0ZepsDW2CMivmMWHChAnTNzO1DdMkcN5xjGZ2n1lCgAkTJkyYnsfUBtFNctAeoLnqqFDeDsaECRMmTJiuGhluDuVcW+t/2H5MmDBhwvTHmJJF3DfgnA0gZ8UwJkyYMGF6BtOsMZp8c9aQvWrAuVk/JkyYMGF6BlNeFl7beJ21kmet4ba0Hl6YMGHChOm7mP4Dldov4De67roAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '为什么不看我！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!你回来啦!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
