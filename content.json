{"meta":{"title":"小天才的杂货铺","subtitle":null,"description":"仰望星空，脚踏实地","author":"MA Haozhe","url":"https://blogs.littlegenius.xin","root":"/"},"pages":[{"title":"","date":"2019-12-25T08:59:20.613Z","updated":"2019-01-11T08:21:48.000Z","comments":false,"path":"categories/index.html","permalink":"https://blogs.littlegenius.xin/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-12-25T08:59:20.607Z","updated":"2019-01-11T08:21:26.000Z","comments":false,"path":"tags/index.html","permalink":"https://blogs.littlegenius.xin/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"【机器学习】（七）概率图模型","slug":"【ML】7概率图模型","date":"2020-01-13T12:49:09.000Z","updated":"2020-01-13T13:15:38.346Z","comments":true,"path":"2020/01/13/【ML】7概率图模型/","link":"","permalink":"https://blogs.littlegenius.xin/2020/01/13/%E3%80%90ML%E3%80%917%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"概率模型与概率图模型概率模型概率模型（probabilistic model）提供了一种描述框架，将学习任务归结于计算变量的概率分布。在概率模型中，利用已知变量推测未知变量的分布称为推断（inference），其核心是如何基于可观测变量推测出未知变量的条件分布。假定所关心的变量集合为Y，可观测变量集合为O，其他变量的集合为R。 生成式（generative）模型考虑联合分布P(Y,R,O) 判别式（discriminative）模型考虑条件分布P(Y,R|O) 给定一组观测变量值，推断就是要由P(Y,R,O)或P(Y,R|O)得到条件概率分布P(Y|O) 概率图模型概率图模型（probabilistic graphical model）是一类用图来表达变量相关关系的概率模型。它以图为表示工具，最常见的是用一个结点表示一个或一组随机变量，结点之间的边表示变量间的概率相关关系，即变量关系图。 根据边的性质不同，概率图模型可大致分为两类 贝叶斯网（Bayesian network）：使用有向无环图表示变量间的依赖关系 马尔可夫网（Markovnetwork）：使用无向图表示变量间的相关关系，又称为无向图模型 隐马尔可夫模型隐马尔可夫模型（Hidden Markov Model，HMM）是结构最简单的动态贝叶斯网（dynamic Bayesian network），主要用于时序数据建模。 隐马尔可夫模型中的变量可以分为两组： 状态变量：状态变量yi表示第i时刻的系统状态，通常假定状态变量是隐藏的、不可被观测的，因此也称隐变量（hidden variable）。隐马尔可夫模型中，系统的状态通常在多个状态之间互相转化，因此一般认为状态变量的取值是有限的离散值。 观测变量：观测变量xi表示第i时刻的观测值。它可以是离散型也可以是连续型。 隐马尔可夫模型各变量的依赖关系如下图。在任一时刻，观测变量的取值仅依赖于状态变量，即 xt 仅由 yt 确定；任一时刻的状态变量仅依赖于其上一时刻的状态变量，即 yt 仅依赖于 y(t-1)。这就是马尔可夫链（Markov chain），即：系统下一时刻的状态仅由当前状态决定，不依赖于以往的任何状态。 基于马尔可夫链，所有变量的联合概率分布为： 为确定一个隐马尔可夫模型，需要以下三组参数： 状态转移概率：模型在各个状态间转换的概率，通常记为矩阵A=[aij]N×N，其中 表示在任意时刻t，若状态为si，则在下一时刻状态为sj的概率 输出观测概率：模型根据当前状态获得各个观测值的概率，通常记为矩阵B=[bij]N×M，其中 表示在任意时刻t，若状态为si，则观测值oj被获取的概率 初始状态概率：模型在初始时刻各状态出现的概率，通常记为π=(π1, π2, …, πN)，其中 表示模型的初始状态为si的概率 从而，隐马尔可夫模型通常使用 λ=[A, B, π] 来表示。 马尔可夫随机场马尔可夫随机场（Markov Random Field，MRF）是典型的马尔可夫网，这是一种无向图模型。图中每个结点表示一个或一组变量，结点之间的边表示两个变量之间的依赖关系。马尔可夫随机场有一组势函数（potential functions），亦称因子（factor），这是定义在变量子集上的非负实函数，主要用于定义概率分布函数。 如下图即一个简单的马尔可夫随机场： 马尔可夫随机场计算联合分布在一个马尔可夫随机场中定义如下概念： 团（clique）：对于图中结点的一个子集，若其中任意两个结点之间都有边连接，则称该子集为一个团 极大团（maximal clique）：若某个团加入另外任何一个结点都不能再够成团，则称该团为极大团，即极大团就是不能被其他团所包含的团 马尔可夫随机场中，所有变量的联合概率可以通过团来定义，每个因子仅与一个团相关。若所有的团构成集合C，与团Q相关的变量集合记为xQ，则联合概率定义为： 其中ψQ为与团Q对应的势函数，用于对团Q中的变量关系进行建模 称为规范化因子，一般很难计算，所以往往不需要Z的精确值 为了减少团的数量同时保证满足每个因子仅与一个团相关这个条件，通常使用极大团Q*来计算，使用极大团定义的联合概率为： 马尔可夫随机场中的条件独立性定义如下概念： 若马尔可夫随机场中，结点集A中的结点到B中的结点都必须经过结点集C中的结点，则称结点集A和B被结点集C分离，结点集C称为分离集（separating set），如图所示： 全局马尔可夫性（global Markov property）：给定两个变量子集的分离集，则这两个变量子集条件独立，如上图中，xA和xB在给定xC的条件下独立，记为： 局部马尔可夫性（local Markov property）：给定某变量的邻接变量，则该变量条件独立于其他变量。例如，令V为图的结点集，n(v)为结点v在图上的邻接结点，n*(v)=n(v)U{v}，有： 成对马尔可夫性（pairwise Markov property）：给定所有其他变量，两个非邻接变量条件独立。例如，令图的结点集和边集分别为V和E，对图中的两个结点u和v，若⟨n,v⟩∉E，则： 势函数势函数定量地刻画变量集xQ中变量之间的相关关系，是非负函数，且在所偏好的变量取值上有较大的函数值，势函数常用指数函数定义： HQ(xQ)是一个定义在变量xQ上的实值函数，常见形式为： 条件随机场条件随机场（Conditional Random Field，CRF）是一种判别式无向图模型，对条件分布进行建模。隐马尔可夫模型和马尔可夫随机场为生成式模型，直接对联合分布进行建模。 条件随机场试图对多个变量在给定观测值后的条件概率进行建模。具体来说，若令x={x1, x2, …, xn}为观测序列，y={y1, y2, …, yn} 为与之相应的标记序列，则条件随机场的目标是构建条件概率模型P(y|x)。 令G=&lt;V,E&gt;表示结点与标记变量y中元素一一对应的无向图，yv表示与结点v对应的标记变量，n(v)表示结点v的邻接结点，若图G的每个变量yv都满足马尔可夫性，即： 则G=&lt;V,E&gt;构成一个条件随机场 理论上来说，图G可具有任意结构，只要能表示标记变量之间的条件独立性关系即可。但在现实应用中，尤其是对标记序列建模时，最常用的仍是如下图所示的链式结构，即链式条件随机场（chain-structured CRF）： 条件随机场中，通过选用指数势函数并引入特征函数（feature function），条件概率被定义为： 其中tj是定义在观测序列的两个相邻标记位置上的转移特征函数（transition feature function），用于刻画相邻标记变量之间的相关关系以及观测序列对它们的影响，sk是定义在观测序列的标记位置i上的状态特征函数（status feature function），用于刻画观测序列对标记变量的影响，λj和μk为参数，Z为规范化因子。 条件随机场和马尔可夫随机场均使用团上的势函数定义概率，两者在形式上没有显著区别 条件随机场处理的是条件概率，而马尔可夫随机场处理的是联合概率 全文参考：周志华 著 《机器学习》","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://blogs.littlegenius.xin/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"机器学习","slug":"机器学习","permalink":"https://blogs.littlegenius.xin/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"强化学习（一）强化学习的基本概念、e贪心算法、Softmax算法","slug":"RLNotes-1","date":"2020-01-12T09:41:18.000Z","updated":"2020-01-12T15:12:09.161Z","comments":true,"path":"2020/01/12/RLNotes-1/","link":"","permalink":"https://blogs.littlegenius.xin/2020/01/12/RLNotes-1/","excerpt":"","text":"强化学习（reinforcement learning，RL）是机器学习的一个领域，主要通过在环境（environment）中采取动作（action），来最大化某些指标，例如累计奖赏（cumulative reward）的一种学习方法。强化学习、有监督学习（supervised learning）与无监督学习（unsupervised learning）三者共同构成了机器学习的三个重要方面 Reinforcement learning (RL) is an area of machine learning concerned with how software agents ought to take actions in an environment in order to maximize some notion of cumulative reward. Reinforcement learning is one of three basic machine learning paradigms, alongside supervised learning and unsupervised learning. (WikiPedia) 任务与奖赏一个简单的强化学习模型如图所示 强化学习任务通常用马尔可夫决策过程（Markov Decision Process，MDP）来描述：机器处于环境E中，状态空间为X，其中每个状态x∈X是机器感知到的环境的描述，机器能采取的动作构成了动作空间A，若某个动作a∈A作用在当前状态x上，则潜在的转移函数P将使得环境从当前状态按某种概率转移到另一个状态，同时，环境会根据潜在的奖赏函数R反馈给机器一个奖赏。综合起来，强化学习任务对应了四元组E=&lt;X,A,P,R&gt;，其中P:X×A×X→R指定了状态转移概率，R:X×A×X→R（或者R:X×X→R）指定了奖赏。 如下图所示是一个在培育农作物的过程中，浇水与否（两个动作：浇水与不浇水）与农作物的状态（健康、缺水、溢水、凋亡）的马尔可夫决策过程： 在强化学习中，机器要做的即通过在环境中不断尝试而学得一个策略（policy）π，根据这个策略，在状态x下得到要执行的动作或者以多少概率执行动作空间中的任意动作。 在强化学习中，并没有监督学习中的有标记样本，动作是否正确以及接下来要做哪些动作，需要机器通过反思之前的动作与累积奖赏进行学习。因此，强化学习在某种意义上可看作具有延迟标记信息的监督学习问题。 探索与利用强化学习的任务的最终奖赏是多部动作之后才能观察到的，所以对于每次的动作选择，可以分成两种情况： 探索（exploration）：若只想获得每个动作的期望奖赏是多少，则采用“仅探索”（exploration-only）策略，即将所有的尝试机会都均匀的分到每个可以执行的动作中去，从而根据最后每个动作多次尝试得到的奖赏来计算每个动作的期望奖赏。“探索”可以很好地估计每个动作的奖赏期望，但是却失去了很多选择最优动作的机会。 利用（exploitation）：若只想通过执行动作得到最大的奖赏，则采用“仅利用”（exploitation-only）策略，即根据到目前为止已知的经验中得到平均奖赏最大的动作（若有多个这样的动作就随机选取一个），将所有的机会都用在这个动作上从而得到奖赏。“利用”没有很好地估计各个动作所带来的奖赏，执着于重复已知的奖赏最大的动作，从而可能经常选不到最优的动作。 事实上,“探索”和“利用”两者是矛盾的，因为尝试次数有限，加强了一方则会自然削弱另一方，这就是强化学习所面临的探索-利用窘境（Exploration-Exploitation dilemma），所以必须在探索与利用之间达成较好的折中。 ϵ-贪心算法ϵ-贪心算法基于一个概率来对探索和利用进行折中：每次尝试时以ϵ的概率进行探索，以1-ϵ的概率进行利用。 令Q(k)表示n次动作所得到的平均奖赏，每次得到的奖赏为v1, v2, v2, …, vn，则平均奖赏为： 使用增量式计算平均奖赏的方式即每次通过单次奖赏与前边所有次的平均奖赏来计算本次动作后的平均奖赏： 在增量计算下，每次动作仅需记录两个值：已尝试次数n-1和最近平均奖赏Qn-1即可。 ϵ-贪心算法描述如下： 若每个动作奖赏的不确定性较大，如概率分布较宽时，则需更多的探索，此时需要较大的ϵ值 若每个动作奖赏的不确定性较小，如概率分布较集中时，则少量的尝试就能很好地近似真实奖赏，此时需要的ϵ较小 通常令ϵ取一个较小的常数，如0.1或0.01 若尝试次数非常大，则在一段时间后，奖赏都能很好地近似出来，不再需要探索，这种情形下可让ϵ随着尝试次数的增加而逐渐减小，例如 ϵ=1∕√t Softmax算法Softmax算法基于当前已知的动作的平均奖赏来对探索和利用进行折中。若个动作的平均奖赏相当，则选取各摇臂的概率也相当；若某些动作的平均奖赏明显高于其他动作，则它们被选取的概率也明显更高。 Softmax算法中动作概率的分配是基于Boltzmann分布： 其中，Q(i)记录当前动作完成后的平均奖赏，τ&gt;0称为“温度”，τ越小则平均奖赏高的动作被选取的概率越高，τ趋近于0时Softmax算法趋于仅利用，τ趋于无穷大时Softmax算法趋于仅探索，算法描述如下： 以上两种算法的好坏很难对比，也和其所取的参数有关，比如下图是一个在 2-摇臂赌博机上的性能比较： 全文参考：周志华 著 《机器学习》","categories":[{"name":"强化学习","slug":"强化学习","permalink":"https://blogs.littlegenius.xin/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"强化学习","slug":"强化学习","permalink":"https://blogs.littlegenius.xin/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"},{"name":"机器学习","slug":"机器学习","permalink":"https://blogs.littlegenius.xin/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"【机器学习】（六）支持向量机","slug":"【ML】6支持向量机","date":"2020-01-04T08:02:04.000Z","updated":"2020-01-04T08:12:13.610Z","comments":true,"path":"2020/01/04/【ML】6支持向量机/","link":"","permalink":"https://blogs.littlegenius.xin/2020/01/04/%E3%80%90ML%E3%80%916%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/","excerpt":"","text":"支持向量机基本模型支持向量机的基本思想是，在如下的样本集中： 基于训练集D在样本空间中找到一个划分超平面，将不同类别的样本分开 划分超平面可以表示成如下的线性方程： 其中w为法向量，b为位移项，空间内任意一点到以上超平面的距离为： 则有 距离超平面最近的几个训练样本点使得上式的等号成立，它们被称为支持向量（support vector），两个异类支持向量到超平面的距离之和为： 称之为间隔（margin） 支持向量机的目的即找到最大间隔（maximum margin）的划分超平面，即解如下的不等式约束的凸优化问题： 等价于： 上述模型即支持向量机（Support Vector Machine，SVM）的基本模型 SMO算法对偶问题求解支持向量机的基本模型是一个凸二次规划（convex quadratic programming）问题，可以使用拉格朗日乘子得到其对偶问题（dual problem）从而求解 对于式子： 对每一条约束增加拉格朗日乘子，得到该问题的拉格朗日函数： 从而得到对偶问题为： 上述过程的KKT（Karush-Kuhn-Tucker）方程为： 可以求解支持向量机的模型 支持向量机有一个重要性质：训练完成后，大部分的训练样本都不需保留，最终模型仅与支持向量有关 SMO算法为了求解该对偶问题，SMO（Sequential Minimal Optimization）算法是一个很高效的算法，其基本思路是，先固定 ai 之外的所有参数，然后求 ai 上的极值。由于存在约束 Σaiyi=0 ，若固定 ai 之外的其他变量，则 ai 可由其他变量导出。于是，SMO每次选择两个变量 ai 和 aj ，并固定其他参数。在参数初始化后，SMO不断执行如下两个步骤直至收敛： 选取一对需更新的变量 ai 和 aj 固定 ai 和 aj 以外的参数，求解对偶问题获得更新后的 ai 和 aj 支持向量机的超平面中的偏移量 b 的求算方式为： 软间隔与正则化软间隔支持向量机并不是每一组训练集在特种空间内都是线性可分的，为了缓解该问题，在有些时候可以允许支持向量机在一些样本上出错，使用软间隔（soft margin）的方式： 软间隔指允许某些样本不满足如下的约束条件： 但在最大化间隔的同时也使得不满足约束的样本应该尽可能的少，于是优化目标可以写为： 其中，C&gt;0，为常数，C为无穷大时，上式要求所有样本均满足约束条件，C取有限值时，上式允许一些样本不满足约束条件。 l0/1是“0/1损失函数”： 一些替代损失（surrogate loss）如下： 图像如下： 引入松弛变量（slack variables）可以改写式子成为： 解以上的二次规划问题，依然使用对偶函数法，得到其拉格朗日函数为： 对偶问题为： KKT方程为： 优化目标的一般形式优化目标的一般形式为：第一项用来描述划分超平面的间隔大小，另一项用来表述训练集上的误差： 第一项称为结构风险（structural risk），用于描述模型的某些性质 第二项称为经验风险（empirical risk），用于描述模型与训练数据的契合程度 C用于对二者进行折中 支持向量回归考虑回归问题，给定样本 希望得到一个回归模型： 使得y和f(x)尽可能接近，w和b是待定参数 支持向量回归（Support Vector Rrgression，SVR）假设能容忍f(x)和y之间有一个偏差，当f(x)和y之间的差别大于该偏差的时候才计算损失，相当于以f(x)为中心构建了一个宽度为两倍偏差的间隔带，若训练样本落入此间隔带则认为模型预测正确 SVR问题可以表示为： 其中的l为不敏感损失函数（insensitive loss function） 引入松弛变量后可以重写为： 依然可以使用对偶问题求解 全文参考：周志华 著 《机器学习》","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://blogs.littlegenius.xin/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"机器学习","slug":"机器学习","permalink":"https://blogs.littlegenius.xin/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"【机器学习】（五）神经网络","slug":"【ML】5神经网络","date":"2020-01-02T11:17:32.000Z","updated":"2020-01-02T12:07:40.162Z","comments":true,"path":"2020/01/02/【ML】5神经网络/","link":"","permalink":"https://blogs.littlegenius.xin/2020/01/02/%E3%80%90ML%E3%80%915%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/","excerpt":"","text":"神经元模型神经网络（neural networks）定义为：神经网络是由具有适应性的简单单元组成的广泛并行互连的网络，它的组织能够模拟生物神经系统对真实世界物体所作出的交互反应。 神经网络中最基本的成分是神经元（neuron）模型，其中最典型的是“M-P神经元模型”，其由多个输入信号，神经元模型通过将输入信号在加权求和，然后与该神经元阈值比较，通过激活函数（activation function）处理后产生结果输出。 理想的激活函数为阶跃函数，但是为避免其不连续不光滑的性质，常用Sigmoid函数代替作为激活函数，由于其将输入值挤压到了(0,1)的输出范围，因此也称挤压函数（squashing function） 把许多个这样的神经元按一定的层次结构连接起来,就得到了神经网络 感知机与多层网络感知机（Perceptron）由两层神经元组成，输入层接收外界输入信号后传递给输出层，输岀层是M-P神经元，亦称阈值逻辑单元（threshold logic unit） 感知机能够很简单的实现逻辑与、或、非运算 通过训练集可以对感知机进行训练，训练的过程即对阈值参数、权重参数进行调整的过程，其中η称学习率（learning rate） 感知机只拥有单层功能神经元（functional neuron），只能解决线性可分（linearly separable）问题，感知机在处理线性可分问题的过程中一定会收敛（converge），对于非线性可分问题则会发生振荡（fluctuation）： 要解决非线性可分问题，需要考虑多层功能神经元，输出层与输入层之间的层神经元，称隐层或隐含层（hidden layer），隐含层和输出层神经元都是拥有激活函数的功能神经元。比如使用两层功能神经元解决异或问题： 多层前馈神经网络（multi-layer feedforward neural networks）多层前馈神经网络（multi-layer feedforward neural networks）由输入层、输入层和隐层组成，其中输入层神经元接收外界输入，隐层与输出层神经元对信号进行加工，最终结果由输出层神经元输出。每层神经元与下层神经元全互连，神经元之间不存在同层连接，也不存在跨层连接。 多层前馈神经网络的训练过程即调整各个神经元结构中的阈值与神经元之间的连接权（connection weight）的过程 误差逆传播算法误差逆传播（error BackPropagation，BP）算法是一种多层网络的训练过程的调整参数的算法，一般的神经网络大多是使用BP算法训练的，因此也称BP网络 上图中的网络有(d+l+1)q+l个参数需确定：输入层到隐层的d×q个权值、隐层到输出层的q×l个权值、q个隐层神经元的阈值、l个输出层神经元的阈值。 标准BP算法标准BP算法每次仅针对一个训练样例更新连接权和阈值，其更新规则是基于单个的均方误差推导而得。 对于训练样例(xk,yk)，设神经网络的输出为 则该网络在样例(xk,yk)上的均方误差为 BP是一个迭代学习算法，在迭代的每一轮中采用广义的感知机学习规则对参数进行更新估计，任意参数v的更新估计式为： 链式求导法则BP算法基于梯度下降（gradient descent）策略，以目标的负梯度方向对参数进行调整。因此对于任意参数v，均方误差Ek均可以对其求偏导从而得到梯度，当v与输出层有多个层次间隔时，需要使用链式求导法则求得梯度。 积累误差逆传播算法累积误差逆传播（accumulated error backpropagation）算法是基于累积误差最小化的更新规则。 标准BP算法每次更新只针对单个样例，参数更新得非常频繁，对不同样例进行更新的效果可能出现“抵消”现象。为了达到同样的累积误差极小点，标准BP算法往往需进行更多次数的迭代。 累积BP算法直接针对累积误差最小化，在读取整个训练集D一遍后才对参数进行更新，其参数更新的频率低得多。 在很多任务中，累积误差下降到一定程度之后，进步下降会非常缓慢，标准BP往往会更快获得较好的解，尤其是在训练集D非常大时更明显。 BP神经网络的过拟合问题可以使用两种策略缓解BP网络的过拟合问题： 早停（early stopping）：将数据分成训练集和验证集，训练集用来计算梯度、更新连接权和阙值，验证集用来估计误差，若训练集误差降低但验证集误差升高，则停止训练，同时返回具有最小验证集误差的连接权和阈值 正则化（regularization）：在误差目标函数中增加一个用于描述网络复杂度的部分 局部极小与全局最小当在寻找函数的全局最小值时，由于算法问题被困在了局部极小值处，无法跳出局部极小的情况称为“参数寻优陷入了局部极小”，为了跳出局部极小，可以有以下一些解决方案： 以多组不同参数值初始化多个神经网络，按标准方法训练后，取其中误差最小的解作为最终参数。 使用模拟退火（simulated annealing）技术，模拟退火在每一步都以一定的概率接受比当前解更差的结果，从而有助于跳出局部极小。 使用随机梯度下降。随机梯度下降法在计算梯度时加入了随机因素。即便陷入局部极小点，计算出的梯度仍可能不为零，有机会跳出局部极小继续搜索。 全文参考：周志华 著 《机器学习》","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://blogs.littlegenius.xin/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"机器学习","slug":"机器学习","permalink":"https://blogs.littlegenius.xin/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"【机器学习】（四）决策树","slug":"【ML】4决策树","date":"2019-12-30T13:36:20.000Z","updated":"2019-12-30T13:43:54.889Z","comments":true,"path":"2019/12/30/【ML】4决策树/","link":"","permalink":"https://blogs.littlegenius.xin/2019/12/30/%E3%80%90ML%E3%80%914%E5%86%B3%E7%AD%96%E6%A0%91/","excerpt":"","text":"基本流程决策树（decision tree）是基于树结构进行决策的，是一种符合人类面临决策问题时的思考方式。采用了分而治之（divide-and-conquer）的策略。 决策树建立的基本流程 决策树的构建是一个递归的 过程，决策树生成算法中有三种情形会导致递归： 当前结点包含的样本全属于同一类别，无需划分 当前属性集为空，或是所有样本在所有属性上取值相同，无法划分 当前结点包含的样本集合为空，不能划分 划分选择一般而言，随着划分过程不断进行，希望决策树的分支结点所包含的样本尽可能属于同一类别，即结点的“纯度”（purity）越来越高。有一些用来衡量和选择划分方式的基准与方法。 信息增益信息熵（information entropy）是度量样本集合纯度最常用的一种指标。 假定当前样本集合D中第k类样本所占的比例为pk(k=1,2,…, |y|)，则D的信息熵定义为： Ent(D)的值越小，D的纯度越高 假设离散属性a有V个可能的取值{a1, a2, a3, …, aV}，若使用a来对样本集D进行划分，则会产生V个分支节点。可以计算用属性a对样本集D进行划分所获得的信息增益（information gain）为： 一般而言，信息增益越大，则意味着使用属性a来进行划分所获得的纯度提升越大，因此，如果选择信息增益进行决策树划分属性的选择，则选择属性满足： 信息增益准则对可取值数目较多的属性有所偏好 增益率为了减少信息增益准则对可取值数目较多的属性有所偏好而带来的不利影响，可以使用增益率（gain ratio）来选择最优化分属性。增益率定义为： 其中 成为属性a的固有值（intrinsic value）。属性a的可能取值数目越多，IV(a)的值通常也会越大。 基于增益率的属性划分采用一个启发式判定：先从候选划分属性中找出信息增益高于平均水平的属性，再从中选择增益率最高的属性 信息增益率准则对可取值数目较少的属性有所偏好 基尼指数CART**决策树（Classfication and Regression Tree）使用基尼指数（Gini index）选择划分属性。数据集D的纯度可以使用基尼值**来衡量： Gini(D)反映了从数据集D中随机抽取两个样本，其类别标记不一致的概率，因此Gini(D)越小，数据集D的纯度越高。 属性a的基尼指数定义： 属性划分时选择： 剪枝处理剪枝（pruning）是决策树学习算法对付“过拟合”的主要手段。 预剪枝（prepruning）：在决策树生成过程中，对每个结点在划分前先进行估计，若当前结点的划分不能带来决策树泛化性能提升，则停止划分并将当前结点标记为叶结点。 后剪枝（postpruning）：先从训练集生成一棵完整的决策树，然后自底向上地对非叶结点进行考察，若将该结点对应的子树替换为叶结点能带来决策树泛化性能提升，则将该子树替换为叶结点。 两种剪枝处理的优缺点比较： 预剪枝显著减少了决策树的训练时间开销和测试时间开销；后剪枝的训练时间开销比未剪枝和预剪枝都大得多 预剪枝基于贪心算法本质禁止一些分支展开，给预剪枝决策树带来了欠拟合的风险；后剪枝决策树通常比预剪枝决策树保留了更多的分支，且其欠拟合风险很小，泛化性能往往优于预剪枝 连续与缺失值连续值处理由于连续属性的可取值数目不在有限，所以需要进行连续属性的离散化技术。 连续值处理的最常用方式：二分法（bi-partition） 将连续属性值使用一个划分点t进行划分，划分成Dt+和Dt-两个子集，对于相邻的两个属性值ai和ai+1，t可以去其中间值，对于连续属性a，可以考察包含n-1个元素的候选划分点集合： 然后像离散属性值一样考察这些划分点，选取最优的划分点进行样本集合的划分，例如Gain公式可以修改成： 计算后选择使得Gain(D, a, t)最大化的划分点 缺失值处理当样本数据中有些样本在某些属性下出现数据缺失的情况是，需要有两个问题进行解决： 如何在属性值缺失的情况下进行划分属性选择？ 给定划分属性，若样本在该属性上的值缺失，如何对样本进行划分？ 给定训练集D和属性a，令D’a表示D中在属性a上没有缺失值的样本子集。对于问题第一点，仅可根据D’a来判断属性a的优劣。 假定我们为每个样本x赋予一个权重wx，并定义： 从而可以将信息增益推广为： 其中 对于问题的第二点，若样本x在划分属性a上的取值已知，则将x划入与其取值对应的子结点，且样本权值在子结点中保持为wx，若样本x在划分属性a上的取值未知，则将x同时划入所有子结点，且样本权值在与属性值av对应的子结点中调整为 rv×wx，即让同一个样本以不同的概率划入到不同的子结点中去。 多变量决策树当把每个属性视为坐标空间中的一个坐标轴，则d个属性描述的样本就对应了d维空间中的一个数据点，对样本分类则意味着在这个坐标空间中寻找不同类样本之间的分类边界。决策树所形成的分类边界有一个明显的特点：轴平行（axis-parallel），即它的分类边界由若干个与坐标轴平行的分段组成： 若使用斜线划分边界，则可以视为多变量决策树（multivariate decision tree），实现“斜划分”甚至更复杂的划分，即每个非叶节点变为属性的线性组合，形如 的一个线性分类器，学习的过程也是确定wi的过程 全文参考：周志华 著 《机器学习》","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://blogs.littlegenius.xin/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"机器学习","slug":"机器学习","permalink":"https://blogs.littlegenius.xin/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"【机器学习】（三）线性模型","slug":"【ML】3线性模型","date":"2019-12-26T12:09:17.000Z","updated":"2019-12-26T12:28:39.966Z","comments":true,"path":"2019/12/26/【ML】3线性模型/","link":"","permalink":"https://blogs.littlegenius.xin/2019/12/26/%E3%80%90ML%E3%80%913%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"基本形式给定由d个属性描述的示例x=(x1; x2; …; xd)，其中xi是x在第i个属性上的取值，线性模型（linear model）试图学得一个通过属性的线性组合来进行预测的函数，即 写成向量形式即 确定w与b后模型即随之确定 非线性模型（nonlinear model）可在线性模型基础上通过引入层级结构或高维映射得到 线性模型具有很好的解释性（comprehensibility） 线性回归线性回归（linear regression）目的即确定一个w和b，是的f(x)与y的均方误差最小化。 均方误差对应欧几里得距离即欧氏距离（Euclidean distance） 基于均方误差最小化进行模型求解的方法称最小二乘法（least square method） 最小二乘法即试图找到一条直线，使所有样本到直线上的欧氏距离之和最小 w和b最优解的闭式（closed-form）解为： 多元线性回归更一般的情形是对于d个属性描述的变量，进行多元线性回归（multivariate linear regression） 为便于讨论，令w’=(w;b)，数据集D表示为一个m×(d+1)大小的矩阵X，器每一行对应一个示例，每行前d个元素对应于示例的d个属性值，最后一个元素恒置为1，即 标记向量为y，则有 令 并将其对w’求导得到： 令其为0可以得到w’的最优解的闭式解 若XTX为满秩矩阵（full-rank matrix）或正定矩阵（positive definite matrix）时，则求得 线性回归模型为 若XTX不是满秩矩阵（往往不是），则会得到多个可行解，由归纳偏好选择哪一组解为输出，常见的做法为引入正则化（regularization）项 广义线性模型广义线性模型（generalized linear model）即当f与x不是标准的线性关系时，可以选取一个恰当的单调可微函数g，令 得到广义线性模型，g称为联系函数（link function） 例如当g(·)=ln(·)时可以得到对数线性回归（log-linear regression） 对数几率回归对于二分类任务，可以通过将输出标记y归到0或1，从而使用线性回归的方法，即将预测值转换成0/1值，可以使用单位阶跃函数（unit-step function） 但是由于其不连续，可以使用单位阶跃函数的替代函数（surrogate function）并希望其单调可微，从而可以选取对数几率函数（logistic function），一种Sigmoid函数（即形似S的函数） 它可以将z值转换成一个0/1值，从而 将y视为样本x作为正例的可能性，则1-y是其反例可能性，两者的比值成为几率（odds），反映了x作为正例的相对可能性，对其取对数即对数几率（log odds，或logit） 确定w与b通过极大似然法（maximum likelihood method）估计w和b，给定数据集(xi,yi)，对率回归模型最大化对数似然（log-likelihood） 上式最大化等价于最小化下式 该式是关于β的高阶可导连续凸函数，根据凸优化理论可以使用梯度下降法、牛顿法等求其最优解得到： 线性判别分析线性判别分析（Linear Discriminant Analysis，LDA）是一种经典的线性学习方法，适用于二分类问题。 LDA的思想为：给定训练样例集，设法将样例投影到一条直线上，使得同类样例的投影点尽可能接近、异类样例的投影点尽可能远离；在对新样本进行分类时，将其投影到同样的这条直线上，再根据投影点的位置来确定新样本的类别。 类内散度矩阵（within-class scatter matrix）用于表示每一个类内的分散程度，希望其越小越好 类间三度矩阵（between-class scatter matrix）用于表示类与类之间的分散程度，希望其越大越好 LDA欲最大化的目标即Sb和Sw的广义瑞利商（generalized Rayleigh quotient） 求算方式：由于不失一般性（J式中分子和分母都是关于w的二次项，因此J的解与w的长度无关，只与其方向有关），可以设分母为1，等价于等式条件约束下的凸优化问题： 使用拉格朗日乘子可以求解其对偶问题，从而求解该优化问题，考虑到数值解的稳定性，一般会将Sw进行奇异值分解 LDA可从贝叶斯决策理论的角度来阐释，并可证明，当两类数据同先验、满足高斯分布且协方差相等时，LDA可达到最优分类 LDA可以推广到多分类任务中，需要定义全局散度矩阵 LDA也常被视为一种经典的监督降维技术 多分类学习多分类学习的基本思路是拆解法，即将多分类任务拆为若干个二分类任务求解。先对问题进行拆分，然后为拆出的每个二分类任务训练一个分类器；在测试时，对这些分类器的预测结果进行集成以获得最终的多分类结果。 经典的拆分策略有 一对一（One vs. One，OvO) 一对其余（One vs. Rest，OvR) 多对多（Many vs. Many，MvM） 一对一 与 一对其余假设有N个类别。 OvO将这N个类别两两配对，从而产生N(N-1)/2个二分类任务。在测试阶段，新样本将同时提交给所有分类器，于是将得到N(N-1)/2个分类结果，最终结果可通过投票产生：即把被预测得最多的类别作为最终分类结果。 OvR每次将一个类的样例作为正例、所有其他类的样例作为反例来训练N个分类器。在测试时若仅有一个分类器预测为正类，则对应的类别标记作为最终分类结果。若有多个分类器预测为正类，则通常考虑各分类器的预测置信度,选择置信度最大的类别标记作为分类结果。 OvR只需训练N个分类器，而OvO需训练N(N-1)/2个分类器。因此，OvO的存储开销和测试时间开销通常比OvR更大 在训练时，OvR的每个分类器均使用全部训练样例，而OvO的每个分类器仅用到两个类的样例，因此，在类别很多时，OvO的训练时间开销通常比OvR更小 多对多MvM是每次将若干个类作为正类，若干个其他类作为反类（OvO和OvR是MvM的特例）。MvM的正、反类构造可以使用最常用的纠错输出码（Error Correcting Output Codes，ECOC)技术。 ECOC是将编码的思想引入类别拆分，并尽可能在解码过程中具有容错性。ECOC工作过程主要分为两步 编码：对N个类别做M次划分，每次划分将一部分类别划为正类，一部分划为反类，从而形成一个二分类训练集；这样一共产生M个训练集，可训练出M个分类器 解码：M个分类器分别对测试样本进行预测，这些预测标记组成一个编码。将这个预测编码与每个类别各自的编码进行比较，返回其中距离最小的类别作为最终预测结果 常用的编码方式 二元码，每个类别分别指定为正类和反类 三元码，每个类别可以指定为正类、反类或者停用类 纠错输出码具有一定的容错能力 类别不平衡问题类别不平衡（class-imbalance）指分类任务中不同类别的训练样例数目差别很大的情况。一般的应对方式是再缩放（rescaling） 直接对训练集里的多的一类样例进行欠采样（undersampling），即去除一些多的一类样例，使得正、反例数目接近，然后再进行学习 直接对训练集里的少的一类样例进行过采样（oversampling），即增加一些少的一类样例，使得正、反例数目接近，然后再进行学习 直接基于原始训练集进行学习，但在用训练好的分类器进行预测时，将样例数量比例嵌入决策过程，称为阙值移动（threshold-moving） 注意！ 欠采样法的时间开销通常远小于过采样法，因为前者丢弃了很多样例，使得分类器训练集远小于初始训练集，而过采样法增加了很多样例，其训练集大于初始训练集 过采样法不能简单地对初始样例进行重复采样，否则会招致严重的过拟合；过采样法的代表性算法SMOTE是通过对训练集里的一类样例进行插值来产生额外的样例 欠采样法若随机丢弃样例，可能丢失一些重要信息；欠采样法的代表性算法Easy Ensemble则是利用集成学习机制，将少的一类样例划分为若干个集合供不同学习器使用，这样对每个学习器来看都进行了欠采样，但在全局来看却不会丢失重要信息 全文参考：周志华 著 《机器学习》","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://blogs.littlegenius.xin/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"机器学习","slug":"机器学习","permalink":"https://blogs.littlegenius.xin/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"【机器学习】（二）模型估计与选择","slug":"【ML】2模型评估与选择","date":"2019-12-25T13:35:26.000Z","updated":"2019-12-25T14:18:30.799Z","comments":true,"path":"2019/12/25/【ML】2模型评估与选择/","link":"","permalink":"https://blogs.littlegenius.xin/2019/12/25/%E3%80%90ML%E3%80%912%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/","excerpt":"","text":"误差与过拟合误差假设m个样本中有a个样本分类错误 错误率（error rate）：分类错误的样本数占样本总数的比例，E=a/m 精度（accuracy）：分类正确的样本数占样本总数的比例，1-a/m 精度=1-错误率 误差（error）：学习器的实际预测输出与样本的真实输出之间的差异 学习器在训练集上的误差称为训练误差（training error）/经验误差（empirical error） 学习器在新样本上的误差称为泛化误差（generalization error） 机器学习的目标是得到泛化误差小的学习器，但是实际能做的是努力使经验误差最小化 过拟合与欠拟合当学习器把训练样本学得太好的时候，很可能已经把训练样本自身的一些特点当作了所有潜在样本都会具有的一般性质，这样就会导致泛化性能下降。这种现象在机器学习中称为过拟合（overfitting）。与过拟合相对的是欠拟合（underfitting），这是指对训练样本的一般性质尚未学好。 过拟合是机器学习中的关键障碍 评估方法通常，通过实验测试来对学习器的泛化误差进行评估。为此，需使用一个测试集（testing set）来测试学习器对新样本的判别能力，然后以测试集上的测试误差（testing error）作为泛化误差的近似。 通常我们假设测试样本也是从样本真实分布中独立同分布采样而得 测试集应该尽可能与训练集互斥 验证集（validation set）指用于评估模型的不包含在训练样本与测试样本的其他真实数据 评估方法即通过适当的处理，从包含m个样例的数据集D中产生出训练集S和测试集T 留出法（hold-out）留出法（hold-out）直接将数据集D划分为两个互斥的集合，其中一个集合作为训练集S，另一个作为测试集T，即 D=SUT，S∩T=。在S上训练出模型后，用T来评估其测试误差，作为对泛化误差的估计。 划分过程中需要采取均匀的分层取样（stratified sampling） 一般单次留出法往往不可靠，需要反复多次进行留出法产生不同的训练集与测试集，对评估结果取均值 常见的分法是训练集占总数据集的2/3~4/5 交叉验证法（cross validation）交叉验证法（cross validation）先将数据集D划分为k个大小相似的互斥子集，即 D=D1 U D2 U … U Dn，Di ∩ Dj = (i≠j)。每个子集都尽可能保持数据分布的一致性，即通过分层采样得到。每次用 k-1 个子集的并集作为训练集，余下的那个子集作为测试集。这样就可获得 k 组训练测试集，从而可进行 k 次训练和测试，最终返回的是这 k 个测试结果的均值。 通常把交叉验证法称为k**折交叉验证**（k-fold cross validation）。k最常用的取值是10，此时称为10折交叉验证 k折交叉验证通常也要随机使用不同的划分重复p次，最终会得到p×k次结果并取均值 留一法（Leave-One-Out，LOO）假定数据集D中包含m个样本，当k=m，则得到了交叉验证法的一个特例：留一法（Leave-One-Out，LOO） 在绝大多数情况下，留一法中被实际评估的模型与期望评估的用D训练出的模型很相似。因此，留一法的评估结果往往被认为比较准确 缺点：在数据集比较大时运算量无法接受 自助法（bootstrapping）自助法（bootstrapping）直接以自助采样法（bootstrap sampling）为基础。 给定包含m个样本的数据集D，我们对它进行采样产生数据集D’。每次随机从D中挑选一个样本，将其拷贝放入D′，然后再将该样本放回初始数据集D中，使得该样本在下次采样时仍有可能被到。这个过程重复执行m次后，我们就得到了包含m个样本的数据集D’，即自助采样的结果。 D中有一部分样本会在D’中多次出现，而另一部分样本不出现。可以做一个简单的估计，样本在m次采样中始终不被采到的概率是(1-1/m)^m，取极限得到 即通过自助采样，初始数据集D中约有36.8%的样本未出现在采样数据集D中。于是可将D’用作训练集，D\\D’用作测试集。这样，实际评估的模型与期望评估的模型都使用m个训练样本，而我们仍有数据总量约1/3的、没在训练集中出现的样本用于测试这样的测试结果，亦称包外估计（out-of-bag-estimate） 自助法在数据集较小、难以有效划分训练/测试集时很有用 在初始数据量足够时，留出法和交叉验证法更常用一些 调参（parameter tuning） 在进行模型评估与选择时，除了要对适用学习算法进行选择，还需对算法参数进行设定，这就是通常所说的参数调节/调参（parameter tuning） 实际操作中一般会对每个参数选定一个范围或者步长 在研究对比不同算法的泛化性能时，用测试集上的判别效果来估计模型在实际使用时的泛化能力，而把训练数据另外划分为训练集和验证集，基于验证集上的性能来进行模型选择和调参 性能度量性能度量（performance measure）即模型泛化能力的评价标准 给定样例集 D={(x1,y1), (x2,y2), …, (xm,ym)}，其中的 yi 是 xi 的真实标记，评估学习器 f 的性能，即比较 f(xi) 与 yi 均方误差均方误差（mean squared error）：回归任务最常用 对于数据分布D和概率密度函数p(·)，均方误差为： 错误率与精度错误率与精度适用于分类任务 错误率（error rate） 对于数据分布D和概率密度函数p(·)，误差为： 精度（accuracy） 对于数据分布D和概率密度函数p(·)，精度为： 查准率、查全率与F1查准率（precision）又称精确度，二分类（0，1分类）中，代表预测为1的所有结果中，预测正确的比例。 查全率（recall）又称召回率，二分类（0，1分类）中，代表真实情况为1的所有样本中，预测结果同样为1的比例 对于二分类问题，可以将真实情况与预测情况组合为如下四种：真正例（true positive）、假正例（false positive）、真反例（true negative）、假反例（false negative）四种情形，令TP、FP、TN、FN分别表示其对应的样例数，则显然有TP+FP+TN+FN=样例总数。分类结果的混淆矩阵（confusion matrix）如下 查准率P与查全率R分别定义为： 查准率和查全率是一对矛盾的度量。一般来说，查准率高时，查全率往往偏低；查全率高时，查准率往往偏低。 PR曲线与PR图在很多情形下，可根据学习器的预测结果对样例进行排序，排在前面的是学习器认为最可能是正例的样本，排在最后的则是学习器认为最不可能是正例的样本。（或者理解为，对分类结果是否更加被认为是正例给定一个概率，0-1，按照该概率从高到低排序，确定一个阈值（threshold）来控制正例与反例的划分）。按此顺序逐个把样本作为正例进行预测，则每次可以计算出当前的查全率、查准率。以查准率为纵轴、查全率为横轴作图，就得到了査准率-查全率曲线，简称PR曲线，该曲线的图称为PR图 如果有曲线完全包住了另一条曲线，如A包住了C，则A比C优秀 如果两条曲线有交叉，如A和B 比较各自曲线下的包裹面积，面积大的优于面积小的 使用平衡点比较：平衡点（Break-Event Point，BEP）为查准率=查全率时对应的取值，该值大的优于小的。如A优于B 由于平衡的BEP过于简化，更常用Fβ度量 F1度量： 其实F1是基于查准率与查全率的调和平均（harmonic mean）定义的： Fβ度量：当对查准率和查全率的重视程度不同时可以调节β的值体现这一差异： 其实Fβ是基于查准率与查全率的加权调和平均（harmonic mean）定义的： 与算术平均和几何平均相比，调和平均更重视较小值 其中β&gt;0度量了查全率对查准率的相对重要性。β=1时退化为标准的F1，β&gt;1时查全率有更大影响，β&lt;1时查准率有更大影响 多个二分类混淆矩阵下的查准率、查全率与F1当对一个二分类问题多次重复训练得到多个二分类混淆矩阵，或者当对多分类任务下，两两类别组合都对应一个二分零混淆矩阵等情况时，需要在n个二分类混淆矩阵上计算查准率、查全率与F1 先在各混淆矩阵上分别计算出查准率和查全率，再计算平均值，得到宏查准率（macro-P）、宏查全率（macro-R），以及相应的宏F1（macro-F1） 先将各混淆矩阵的对应元素进行平均，得到TP、FP、TN、FN的平均值，再基于这些平均值计算出微查准率（micro-P）、微査全率（micro-R）和微F1（micro-F1） ROC与AUC当采用阈值（threshold）对分类概率进行排序的时候，阈值可以看成是按照预测概率从大到小排列的样本数据的一个截断点（cut point），截断点前是正例，后是反例。 ROC（受试者工作特性（Receiver Operating Characteristic））曲线，和PR曲线意义相似，横纵坐标表示不同，ROC横轴为假正例率（False Positive Rate，FPR），纵轴是真正例率（True Positive Rate，TPR） ROC图中，对角线对应于随机猜想模型，而点（0,1）对应将所有正例排在所有反例之前的理想模型 现实任务中，根据学习器预测结果对样例进行排序，先把分类阈值设为最大，即把所有样例均预测为反例，此时真正例率和假正例率均为0，在坐标(0,0)处标记一个点；然后，将分类阈值依次设为每个样例的预测值，分别计算真正例率和假正例率，然后画点 若一条ROC曲线能够完全包裹另一条ROC曲线，则前者优于后者 AUC（Area Under ROC Curve）即ROC曲线下包裹的面积，面积大的一般为优 图b中有限样例绘制的ROC曲线计算AUC即： 给定m+个正例，m-个反例时，排序损失（rank loss）定义为： 即考虑每一对正、反例，若正例的预测值小于反例，则记一个罚分，若相等，则记0.5个罚分。lrank对应的是ROC曲线之上的面积，因此有： 代价敏感错误率与代价曲线非均等代价（unequal cost），权衡不同类型错误所造成的不同损失 代价矩阵（cost matrix）比较所有分类的两两比较中，相对的损失大小，costij表示i对j类造成的损失大小。一般costii=0，costij&gt;costji表示i对j损失更大 非均等代价下希望得到最小化的总体代价（total cost），例如m个样例的D集中，D+和D-分别表示正例集和反例集，则代价敏感（cost-sensitive）错误率为： 代价曲线（cost curve）可以反应学习器的期望总体代价。 代价曲线图的横轴时取值为[0,1]的正例概率代价，其中p是样例为正例的概率 纵轴是取值为[0,1]的归一化代价，其中FPR为假正例率，FNR=1-TPR是假反利率 代价曲线的绘制：ROC曲线上每一点对应了代价平面上的一条线段，设ROC曲线上点的坐标为(TPR,FPR)，则可相应计算出FNR，然后在代价平面上绘制条从(0,FPR)到(1,FNR)的线段，线段下的面积即表示了该条件下的期望总体代价；将ROC曲线上的每个点转化为代价平面上的一条线段，然后取所有线段的下界，围成的面积即为在所有条件下学习器的期望总体代价 比较检验比较检验即确定多个学习器之间的关系，孰强孰弱。 假设检验统计假设检（hypothesis test）为进行学习器性能比较提供了重要依据。基于假设检验结果可推断出，若在测试集上观察到学习器A比B好，则A的泛化性能是否在统计意义上优于B，以及这个结论的把握有多大。如果二者接近的可能性比较大，则可以根据测试错误率推出泛化错误率（即检验“测试错误率和泛化错误率相等”此假设在多大的置信区域内是成立的） 常用的假设检验方法 二项检验（binomial test）：对于验证假设“泛化错误率&lt;=给定错误率（一般是测试错误率）”此假设能否被拒绝 t检验（t-test）：对于多次留出法得到的测试错误率做估计 交叉验证t检验 对于k折交叉验证法得到的测试错误率使用成对t检验（paired t-tests） 由于进行有效的假设检验的重要前提是测试错误率均为泛化错误率的独立采样。然而，通常情况下由于样本有限，在使用交叉验证等实验估计方法时不同轮次的训练集会有一定程度的重叠。为缓解这一问题，可采用 5×2交叉验证 法 McNemar 检验McNemar检验用于对二分类问题，使用留出法估计学习器的测试错误率的情况。 二分类问题下的留出法可获得两学习器分类结果的差别，即两者都正确、都错误、一个正确另一个错误的样本数，得到一个列联表（contingency table） 若假设“两个学习器的性能相同”，则应有 e01=e10，从而 |e01-e10| 应服从正态分布，且均值为1，方差为 e10+e01。从而变量 服从自由度为1的卡方分布，即标准正态分布变量的平方，给定显著度α可以做假设检验 Friedman 检验 与 Nemenyi 后续检验交叉验证t检验和McNemar检验都是在一个数据集上比较两个算法的性能。当在一组数据集上对多个算法进行比较时，一种做法是在每个数据集上分别列出两两比较的结果，在两两比较时可使用以上方法；另一种方法是使用基于算法排序的 Friedman 检验。 Friedman 检验可以判断“所有算法的性能相同”此假设是否可以被拒绝，如果不可以，则需要进行后续检验（post-hoc test）进一步区分算法，常用Nemenyi后续检验。 Friedman检验图可以直观地展示检验结果，其纵轴是各个算法，横轴为平均序值。对每个算法，用一个圆点显示其平均序值，以圆点为中心的横线段表示临界值域的大小。若两个算法的横线段有交叠，则说明这两个算法没有显著差别，否则即说明有显著差别。 偏差与方差偏差-方差分解（bias-variance decomposition）试图对学习算法的期望泛化错误率进行拆解，是解释学习算法泛化性能的重要工具。 对测试样本x，令yD为x在数据集中的标记，y为x的真是标记，f(x;D)为训练集D上学得模型f在x上的预测输出，在回归任务中 学习算法的期望预测为： 使用样本数相同的不同训练集产生的方差为： 噪声为： 期望输出与真实标记的差别称为偏差（bias）： 在假定噪声期望为零的情况下，有： 即泛化误差可分解为偏差、方差与噪声之和 推导过程： 偏差度量了学习算法的期望预测与与选择真实结果的偏离程度，即刻画了学习算法本身的拟合能力；方差度量了同样大小的训练集的变动所导致的学习性能的变化，即刻画了数据扰动所造成的影响；噪声表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界，即刻画了学习问题本身的难度。 偏差-方差分解说明，泛化性能是由学习算法的能力、数据的充分性以及学习任务本身的难度所共同决定的。 一般来说，偏差与方差是有冲突的，称之为偏差-方差窘境（bias-variance dilemma） 全文参考：周志华 著 《机器学习》","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://blogs.littlegenius.xin/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"机器学习","slug":"机器学习","permalink":"https://blogs.littlegenius.xin/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"【机器学习】（一）机器学习基础","slug":"【ML】1机器学习基础","date":"2019-12-25T09:22:24.000Z","updated":"2019-12-25T09:31:24.596Z","comments":true,"path":"2019/12/25/【ML】1机器学习基础/","link":"","permalink":"https://blogs.littlegenius.xin/2019/12/25/%E3%80%90ML%E3%80%911%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/","excerpt":"","text":"基本概念机器学习（Machine Learning）机器学习研究的内容是关于在计算机上从数据/经验（data/experience）中产生模型（model）的算法，即学习算法（learning algorithm）。 Mitchell于1997年给出的定义：假设用P来评估计算机程序在某任务类T上的性能，若一个程序通过利用经验E在T中任务上获得了性能改善，则我们就说关于T和P，该程序对E进行了学习。 基本术语 数据集（data set）：数据的集合，数据是若干条属性与其取值，记录关于对一个事件或对象的描述 示例（instance）/样本（sample）：数据集中的每一条数据 属性（attribute）/特征（feature）：反映事件或对象在某方面的表现或性质的事项 属性值（attribute value）：属性上的取值 属性空间（attribute space）/样本空间（sample space）/输入空间（input space） 特征向量（feature vector）：属性空间中任何一点所对应的向量 标记（lable）：表示示例结果的信息 样例（example）：带有标记的信息示例 标记空间（lable space）/输出空间（output space）：所有的标签的集合 测试样本（testing sample）：用于对学习模型进行测试的样本数据 一般地，令 D={x1, x2, …, xm} 表示包含 m 个示例的数据集，每个示例由 d 个属性描述，则每个示例 xi=(xi1, xi2, …, xid) 是 d 维样本空间 X 中的一个向量，xi∈X，其中 xij 是 xi 在第 j 个属性上的取值，d 称为样本 xi 的维数(dimensionality)。用(xi,yi)表示第i个样例及其标签yi，yi∈Y。 泛化（generalization）：将学习得到的模型应用于新的数据集（测试集）的能力成为泛化能力 通常假设样本空间中全体样本服从一个未知分布（distribution）D，我们获得的每个样本都是独立地从这个分布上采样获得的，即独立同分布（independent and identically distributed，简称iid）。一般而言，训练样本越多，我们得到的关于D的信息越多，这样就越有可能通过学习获得具有强泛化能力的模型。 机器学习的分类基于学习任务 分类（classification）：预测值是离散的 二分类（binary classification）：预测值只有两个类别，通常将其中一个成为正类（positive class），另一个成为反类/负类（negative class） 多分类（mutil-class classification）：预测值是多个离散的类别 回归（regression）：预测值是连续值，其标记空间为实数集 聚类（clustering）：将训练集中的数据分成若干个簇，通常情况下这种学习的数据集是无标签的 基于训练数据是否拥有标签 监督学习（supervised learning）：训练数据有标签，比如分类和回归 无监督学习（unsupervised learning）：训练数据无标签，比如聚类 假设空间我们把学习过程看作一个在所有假设（hypothesis）组成的空间（假设空间（hypothesis space））中进行搜索的过程，搜索目标是找到与训练集匹配（fit）的假设。假设的表示一旦确定，假设空间及其规模大小就确定了。 现实问题中我们常面临很大的假设空间，但学习过程是基于有限样本训练集进行的，因此，可能有多个假设与训练集一致，即存在着一个与训练集一致的假设集合，称之为版本空间（version space） 归纳偏好机器学习算法在学习过程中对某种类型假设的偏好，称为归纳偏好（inductive bias），简称为偏好。 任何一个有效的机器学习算法必有其归纳偏好。归纳偏好可看作学习算法自身在一个可能很庞大的假设空间中对假设进行选择的启发式或价值观。 奥卡姆剃刀原则（Occam’s razor）奥卡姆剃刀原则称“若有多个假设与观察一致，则选最简单的那个”。比如我们通过训练得到有两条可以描述训练样本的曲线，平滑的A曲线可能意味着更加简单。 没有免费的午餐定理（No Free Lunch Theorem，NFL）没有免费的午餐定理指机器学习的模型总误差与学习算法无关，即学习算法的期望性能相同 但是显然NFL定理是基于一个前提的：所有问题出现的机会相同、或所有问题同等重要。但实际情形并不是这样。 NFL的意义在于让我们更加清楚的认识到，脱离具体问题空泛地比较学习算法的好坏毫无意义 学习算法自身的归纳偏好与问题是否相配，往往会起到决定性的作用 NFL 定理的简单证明过程 全文参考：周志华 著 《机器学习》","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://blogs.littlegenius.xin/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"机器学习","slug":"机器学习","permalink":"https://blogs.littlegenius.xin/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"【数据结构】（六）不相交集类","slug":"【数据结构】六不相交集类","date":"2019-08-29T04:14:30.000Z","updated":"2019-08-29T05:12:25.643Z","comments":true,"path":"2019/08/29/【数据结构】六不相交集类/","link":"","permalink":"https://blogs.littlegenius.xin/2019/08/29/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%85%AD%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86%E7%B1%BB/","excerpt":"","text":"等价关系在离散数学（Discrete Mathematics）中提到过等价关系（equivalence relation）,等价关系是对于任意一对元素 (a,b)，存在一个关系R满足以下三个属性： 自反性：对于所有的元素a，a R a 对称性：a R b == b R a 传递性：若 a R b 且 b R c 则 a R c 比如空间中的相互平行的线就满足等价关系，线与自身平行、两条平行线相互平行，如果a平行于b，b平行于c，a也就平行于c，所以平行关系是等价关系。 一个集合S上的元素之间存在的等价关系是对集合S的一个划分，相互等价的元素可以划分到一个子集中，而没有等价关系的两个元素肯定不会被分到同一个子集中，所以按照等价关系划分可以将S划分为多个子集，每个子集中的元素都相互等价，这些子集是不相交的，而且他们的并正好是集合S。具有这种特性的集合可以视为一个不相交集类（The Disjoint Sets Class） 不相交集类的适合用于查找，有两个重要的操作：find和union： find：查找操作，find(x)是返回x所在的子集的名字 union：合并操作，如果我们发现两个元素a和b相互等价，但是他们没有在同一个子集中，那么很显然，a所在的子集和b所在的子集中的所有元素都相互等价，我们可以将其合并成一个新的子集 基本实现如果不要求find操作返回任意特定的名字，而是要求当且仅当两个元素属于相同的子集时，则作用在这两个元素上的find操作能返回相同的明自。那么我就需要对集合S进行划分，并且每一个子集都有唯一的名字。 一种简单的实现方式时是哟个森林，森林中的树就是一个子集，节点就是元素，同一棵树上的所有节点就都属于这个子集，显然可以将子集的名字存储到树的根节点中。这种方式很简单，使用数组就可以实现。比如我们有一个8元素的集合，他们分别是0 1 2 3 4 5 6 7，最初始的时候就是每个节点都单独成树，根节点中存储-1来代表这个时根节点，然后使用union方法来合并集合。像下边这样（union(a,b)默认将b挂到a上）： 初始的一个森林 一个不相交集类的基本实现 进行union(4,5)操作： 一个不相交集类的基本实现 进行union(6,7)操作： 一个不相交集类的基本实现 进行union(4,6)操作： 一个不相交集类的基本实现 最终的存储这个不相交集类的数组如下： 一个不相交集类的基本实现 从union操作改进按大小求并（union-by-size）这个思想是打破随意将一个集合接到另一个集合上的做法，而是根据大小将树合并，即永远将小的集合挂到大的集合上，这种实现方式很简单，并且使得森林中树的结构都不会特别复杂，避免了最坏情况的发生，存储时，将树的根节点的内容存储为此时树的大小的负数，比如继续上边的不相交集类，进行union(3,4)操作： 依旧按照原来的union方式合并： 依照一般的union方式合并 按照小树并大树的方式进行union合并： 按照大小合并 按照大小合并后的存储数组： 按照大小合并的存储数组 按高度求并（union-by-height）根据高度将树合并，即永远将矮的集合挂到高的集合上，存储时，将树的根节点的内容存储为此时树的高度的负数，比如继续上边的不相交集类，进行按照高度的union(3,4)操作会得到： 按照高度合并 存储数据的数组内容： 按照高度合并的存储数组 从find操作改进在对union进行改进后可以对find进行改进，find改进的一种典型方式是路径压缩（Pass Compression）。即在每一次find后，将find的数据到根节点的沿途的每个节点都挂到根节点上，从而对路径进行压缩，而下次查找同一个元素或者其同子集下的元素就会非常省时间。 例如一个不相交集类如下： 一个不相交集类 在这个不太好的结构上进行find(14)后进行路径压缩可以得到： 对这个不相交集类进行路径压缩 这样就使得整棵树的高度、一些数据的路径深度（12、13、14、15）都得到了降低。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://blogs.littlegenius.xin/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"C","permalink":"https://blogs.littlegenius.xin/tags/C/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blogs.littlegenius.xin/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"【C++温故知新】（九）文件的输入与输出","slug":"【C-温故知新】九文件的输入与输出","date":"2019-08-28T14:47:10.000Z","updated":"2019-08-28T15:19:38.344Z","comments":true,"path":"2019/08/28/【C-温故知新】九文件的输入与输出/","link":"","permalink":"https://blogs.littlegenius.xin/2019/08/28/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E4%B9%9D%E6%96%87%E4%BB%B6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/","excerpt":"","text":"文件的输入与输出也是基于流（stream）的，和cout、cin的操作类似。 文件的写入基本条件 必须包含头文件 fstream 头文件 fstream 定义了一个用于处理输出的 ofstream 类 需要声明一个或多个 ofstream 变量（对象），并命名 必须指明名称空间 std 需要将 ofstream 对象与文件关联起来。方法之一是使用 open() 方法 使用完文件后，应使用方法 close() 将其关闭 可结合使用 ofstream 对象和运算符 &lt;&lt; 来输出各种类型的数据 一个文件写入的实例1234567891011121314#include&lt;fstream&gt;using namespace std; int main()&#123; string myString = \"hello world!\"; ofstream ourFile; outFile.open(\"myFile.txt\"); outFile &lt;&lt; myString; outFile.close(); return 0;&#125; 文件的读取基本条件 必须包含头文件 fstream 头文件 fstream 定义了一个用于处理输入的 ifstream 类 需要声明一个或多个 ifstream 变量（对象），并命名 需要将 ifstream 对象与文件关联起来。方法之一是使用 open() 方法 读取完文件后，应使用方法 close() 将其关闭 可结合使用 ifstream 对象和运算符 &gt;&gt; 来读取各种类型的数据 可以使用 ifstream 对象和 get() 方法来读取一个字符，使用 ifstream 对象和 getline() 来读取一行字符 可以结合使用 ifstream 和 cof()、fai() 等方法来判断输入是否成功 ifstream 对象本身被用作测试条件时，如果最后一个读取操作成功，它将被转换为布尔值 true，否则被转换为 false 一个文件读取的实例123456789101112131415161718192021222324252627#include&lt;fstream&gt;#include&lt;iostream&gt;using namespace std; int main()&#123; string fileName = \"myFile.txt\"; ifstream inFile; inFile.open(fileName); if (!inFile.is_open()) cout &lt;&lt; \"Can't open the file: \" &lt;&lt; fileName; string readText; inFile &gt;&gt; readText; if (inFile.eof()) cout &lt;&lt; \"End of file reached.\\n\"; else if (inFile.fail()) cout &lt;&lt; \"Input terminated by data mismatch.\\n\"; else cout &lt;&lt; \"Input terminated for other reasons.\\n\"; inFile.close(); return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://blogs.littlegenius.xin/categories/C/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"C","permalink":"https://blogs.littlegenius.xin/tags/C/"}]},{"title":"【C++温故知新】（八）异常处理","slug":"【C-温故知新】八异常处理","date":"2019-08-28T14:46:56.000Z","updated":"2019-08-28T14:53:16.689Z","comments":true,"path":"2019/08/28/【C-温故知新】八异常处理/","link":"","permalink":"https://blogs.littlegenius.xin/2019/08/28/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E5%85%AB%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","excerpt":"","text":"异常的抛出与捕获异常是程序在执行期间产生的问题，比如尝试除以零的操作。异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：try、catch、throw。 throw：当问题出现时，程序抛出一个异常 catch：在想要处理问题的地方，通过异常处理程序捕获异常 try：try块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。 使用throw可以在一些特定的时候令程序抛出异常，比如当遇到除数是0的时候： 12if(division == 0) throw \"division by zero condition!\"; 一个try……catch的写法通常是这这样的： 123456789101112try&#123; // protected codes&#125;catch( ExceptionName e1 )&#123; // catch block&#125;catch( ExceptionName e2 )&#123; // catch block&#125; 如果要捕获所有的异常，则需要在catch的括号中使用省略号： 12345678try&#123; // protected codes&#125;catch( … )&#123; // catch block&#125; 定义新的异常可以通过继承和重载exception类来定义新的异常，比如像下边这样： 123456789101112131415161718192021struct MyException : public exception&#123; const char * what() const throw() &#123; return \"New Exception\"; &#125;&#125;; try&#123; throw MyException();&#125;catch ( MyException&amp; e)&#123; cout &lt;&lt; \"MyException caught\" &lt;&lt; endl; cout &lt;&lt; e.what() &lt;&lt; endl;&#125;catch (exception&amp; e)&#123; // other exceptions&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://blogs.littlegenius.xin/categories/C/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"C","permalink":"https://blogs.littlegenius.xin/tags/C/"}]},{"title":"【C++温故知新】（七）类的继承","slug":"【C-温故知新】七类的继承","date":"2019-08-28T14:39:06.000Z","updated":"2019-08-28T14:54:17.937Z","comments":true,"path":"2019/08/28/【C-温故知新】七类的继承/","link":"","permalink":"https://blogs.littlegenius.xin/2019/08/28/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E4%B8%83%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/","excerpt":"","text":"类继承的语法类的继承允许通过继承的方式生成新类，继承自的类为基类，继承自基类的类成为派生类，类的继承写法如下： 1234class derivedClass : public/protect/private baseClass&#123;// statements&#125; 其中基类前有一个访问限定符，不写的时候默认为private，但是我们主要使用public，又称作公有继承，三个不同的访问限定词的区别在于： 公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问 保护继承（protecte）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员 私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员 例如我们定义一个基类再定义一个派生类： 1234567891011121314151617181920212223242526272829303132333435363738394041class baseClass&#123;private: baseInt; baseDouble;public: baseClass(const int pInt = 1, cosnt double pDouble = 2.5); int function(double d);&#125; baseClass :: baseClass(const int pInt = 1, cosnt double pDouble = 2.5)&#123; baseInt = pInt; baseDouble = pDouble;&#125; baseClass :: function(double d)&#123; cout &lt;&lt; d; return 1;&#125; class derivedClass : public baseClass&#123;private: derivedChar;public: derivedClass(const int pInt, const double pDouble, const char pChar); void anotherFunction();&#125; derivedClass :: derivedClass(const int pInt, const double pDouble, const char pChar) : baseClass(pInt,pDouble)&#123; derivedChar = pChar;&#125; void derivedClass :: anotherFunction()&#123; cout &lt;&lt; \"I am the derived class.\";&#125; 从这个例子中，我们可以看到，基类有两个私有变量，baseInt和baseDouble，两个方法，一个构造函数用于给两个私有变量赋值，一个用于充数。派生类继承自基类，于是派生类derivedClass就拥有了基类的两个公有方法，但是它不能访问基类的两个私有变量。派生类又定义了自己的一个新私有变量，同时有自己的构造函数和一个用于充数的函数。可见继承的作用在于方便地进行代码的重用以及组织管理项目设计。 基类和派生类的关系类的继承是“is-a”的关系，或者说是“is-a-kind-of”，即派生类对象也是一个基类对象。 派生类是可以调用基类的protected和public修饰的成员变量和方法的，而派生类也可以定义自己的变量和方法。 同时，派生类还可以重载基类的方法，即声明一个和基类中相同名称的成员变量，但是在派生类中对其进行重新的定义。如果基类和派生类同时拥有同名同变量参数同返回值但是定义不同的函数，在使用基类对象调用该函数时，调用的是基类的函数，在使用派生类的对象调用该函数时，调用的是派生类的定义。 基类指针可以在不进行显式类型转换的情况下指向派生类对象；基类引用可以在不进行显式类型转换的情况下引用派生类对象。C++要求的引用和指针类型与赋给的类型匹配的规则对继承来说例外。然而，这种例外只是单向的，不可以将基类对象和地址赋给派生类引用和指针。基类指针或引用只能用于调用基类方法。 多态公有继承多态即一个派生类继承自一个基类后，希望可以定义一个和基类中相同名称、参数列表、返回值的函数，但这个函数的定义却与基类中的不同，即一种派生类对基类方法的重载。 首先，派生类可以重载基类的方法，如果派生类使用基类相同的函数和函数定义，那么就不需要再在派生类中声明该函数，即共有的函数需要放在基类中。如果派生类想对基类的函数进行新的定义，则需要在派生类中对其再次进行声明并定义，定义时也需要表明定义的是那个类的函数。如 baseClass::function() 和 derivedClass::function() 这样。 虚方法（virtual method），需要使用关键词 virtual 修饰基类中的函数，如下面这样： 1virtual void function(int i); 它的作用如下：当基类和派生类都有定义过某个相同方法后，我们需要确定调用的是哪个类下的方法，特别是当方法是通过引用或指针而不是对象调用的。 如果没有使用关键字 virtual ，程序将根据引用类型或指针类型选择方法 如果使用了关键字 virtual ，程序将根据引用或指针指向的对象的类型来选择方法 如果有派生类重载了基类的方法，一般需要将基类的析构函数设置成virtual的以保证释放派生类对象时能够按照正确的顺序调用析构函数 123456789101112131415// 不使用virtualBaseClass baseClass();DerivedClass derivedClass();BaseClass &amp; reference1 = baseClass; // 指向baseClass的类型是BaseClass的引用变量BaseClass &amp; reference2 = derivedClass; // 指向derivedClass的但是类型是BaseClass的引用变量reference1.function(); // 会根据引用的类型即BaseClass调用BaseClass下的function方法reference2.function(); // 会根据引用的类型即BaseClass调用BaseClass下的function方法 // 使用virtualBaseClass baseClass();DerivedClass derivedClass();BaseClass &amp; reference1 = baseClass; // 指向baseClass的类型是BaseClass的引用变量BaseClass &amp; reference2 = derivedClass; // 指向derivedClass的但是类型是BaseClass的引用变量reference1.function(); // 会根据引用指向的类型即BaseClass调用BaseClass下的function方法reference2.function(); // 会根据引用指向的类型即DerivedClass调用BaseClass下的function方法 抽象基类抽象基类（abstract base class，ABC）是一种特殊的基类，从概念上讲，将所有派生类的公用的方法进行抽象汇总声明（定义）到的一个类中，这种设计下的类可以视作一个抽象基类。但是真正的抽象基类应该是至少包含了一个纯虚函数（pure virtual function）的类，这种类不能声明对应的对象，只能作为基类。 纯虚函数是一种只在抽象基类中给出原型，但是部给出定义的函数，更像是一个接口，由所有的派生类对纯虚函数根据自己类的需求来实现其定义。纯虚函数的写法是在虚函数后面以 =0 结尾 1virtual double pureVirtualFunction(int i) const = 0; 应用这种方式，可以将所有派生类共有但是却又各自有着不同实现的方法抽象到一个基类中，提供其原型但是不对其进行定义（也只有纯虚函数C++允许不给出定义），然后使得各个派生类自己给出其定义。 私有继承私有继承即继承的基类使用private修饰符修饰的继承，如果没有访问限定符的修饰，默认也是私有继承，私有继承是一种“has-a”的关系。 12class DerivedClass : private BaseClass&#123; &#125;class DerivedClass : BaseClass&#123; &#125; 私有继承使得基类的公有成员、保护成员都被成为派生类的私有成员，这就使得基类的那些方法都不能再被派生类的实例化对象使用，而只能被派生类的成员函数在类内部使用。即派生类部继承基类的接口。 这里比较了三种继承之间的区别： 特征 公有继承 保护继承 私有继承 公有成员变成 派生类的公有成员 派生类的保护成员 派生类的私有成员 保护成员变成 派生类的保护成员 派生类的保护成员 派生类的私有成员 私有成员变成 只能通过基类接口访问 只能通过基类接口访问 只能通过基类接口访问 能否隐式向上转换 能 只能在派生类中 不能 多重继承多重继承（Multiple Inheritance）也是“is-a”的关系，它允许一个类继承自多个类，只需要将继承的类使用逗号隔开即可，像下面这样： 12class DerivedClass : public BaseClass1, public BaseClass2 &#123;……&#125;class DerivedClass : public BaseClass1, BaseClass2 &#123;……&#125; // BaseClass2 is a private base 多重继承中每一个被继承的基类都需要设置访问限定符，根据需要可以使用不同的访问限定符，不写默认为private 例如设置一个基类Worker表示工人，然后工人可以是歌手也可以是服务员，我们使用两个类继承自这个基类，Singer和Waiter，最后，我们可以定义一个既是歌手有时服务员的类，所以它同时继承自Singer和Waiter，他们的关系就像下边这样： 1234class Worker &#123;……&#125;class Singer : public Worker &#123;……&#125;class Waiter : public Worker &#123;……&#125;class SingingWaiter : public Singer, public Waiter &#123;……&#125; 一个多重继承 虚基类首先多重继承导致了一个问题就是，当一个SingingWaiter的实例继承自Singer和Waiter时，也就间接地两次继承了Worker，也就是说一个SingingWaiter的实例结构应该是如下这样的： 在不使用虚基类的时候 这样引发的问题就是，当我们把派生类对象的地址赋给一个基类的指针时就无法区分是赋给哪个基类，导致二义性： 12SingingWaiter sw；Worker * psw = &amp;sw; 因为sw中包含两个Worker对象，从而有两给地址可以选择，于是正确的写法应该是： 12Worker * psw1 = (Waiter *) &amp;sw;Worker * psw2 = (Singer *) &amp;sw; 所以虚基类（Virtual Base Classes）将解决这个问题。虚基类使得从多个类派生出的对象只继承一个基类对象，需要在类继承的声明中使用virtual关键词，virtual和public的次序无所谓： 123class Singer : virtual public Worker &#123;……&#125;class Waiter : public virtual Worker &#123;……&#125;class SingingWaiter : public Singer, public Waiter &#123;……&#125; 现在，SingingWaiter对象就只包含Worker对象的一个副本，从本质上说是，继承的Singer和Waiter共享一个Worker对象，而不是各自引入一个Worker对象的副本，从而可以使用多态。 在使用虚基类的时候","categories":[{"name":"C++","slug":"C","permalink":"https://blogs.littlegenius.xin/categories/C/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"C","permalink":"https://blogs.littlegenius.xin/tags/C/"}]},{"title":"【C++温故知新】（六）类和对象","slug":"【C-温故知新】六类和对象","date":"2019-08-27T08:41:15.000Z","updated":"2019-08-28T14:39:52.941Z","comments":true,"path":"2019/08/27/【C-温故知新】六类和对象/","link":"","permalink":"https://blogs.littlegenius.xin/2019/08/27/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E5%85%AD%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"类与接口类是一种将抽象转换为用户定义类型的C++工具，它将数据表示和操作数据的方法组合成一个整洁的包。接口提供给我们从外部访问类与类内的成员和方法的一个途径。 一般对一个类的典型的实现策略是：将接口（类的定义）放在头文件中，将其实现（类方法的代码）放在源代码文件中 类的声明框架12345678class ClassName&#123;private:// some private variables and functions public:// some public variables and functions&#125;; 访问控制访问限定符有三个：private、public、protected，它们规定了修饰的变量和方法能够被访问的范围，在没有声明时，默认是private的。 这里先对三个访问限定词做一个比较全面的介绍： private : 类（基类）自身的成员函数 类（基类）友元的成员函数 public : 基类自身的成员函数 基类友元的成员函数 基类所产生派生类的成员函数 基类所产生的派生类的友元函数 其他的全局函数 protected : 基类的成员函数 基类的友元函数 基类派生类的成员函数 例如一个类： 一个类的结构 类的成员函数的实现类的成员函数和一般的函数实现基本相同，还要增添如下两点： 需要使用 :: 符号（作用域解析运算符）来标识这个函数是属于哪一个类的，因为不同的类可以有相同名称的函数 类的方法可以访问类内的 private 的组件 1int ClassName::myFunction(double a); 类的成员函数也可以是内联的，只要加上关键词 inline 即可 类的成员函数可以在类内定义时同时完成逻辑，也可以在类的外部定义 类的使用类的实例化和一般的数据类型相同，调用类实例下的某个成员函数或者变量使用 . 点。 12ClassName myClassInstance;myClassInstance.aFunction(); 类的构造函数和析构函数构造函数类的构造函数需要和类同名，是在类实例化的时候调用的，在实例化一个类的时候，虽然我们没有显示地声明，但是还是调用了构造函数，而C++对每一个类都有默认的构造函数，就是不接受任何参数，什么都不做，也无返回值。我们可以定义自己的构造函数并且调用它。 例如一个类MyClass的定义如下： 123456789class MyClass&#123;private: int myInt; double myDouble;public: MyClass(int mi, double md) &#123; myInt = mi; myDouble = md;&#125;; MyClass() &#123; myInt = 1; myDouble = 0.2;&#125;;&#125; 这里我们使用了一个包含两个参数的构造函数，它的作用是对两个private的成员变量赋值。 构造函数不能像其他成员函数一样使用对象（类的实例）来用点调用，因为构造函数是在实例化类的时候就调用的，比如如下的调用方式： 123MyClass myClass = MyClass(1, 0.2);MyClass myClass(1, 0.2);MyClass * myClassPoint = new MyClass(1, 0.2); 如果是使用的默认构造函数或者构造函数没有参数的话，可以直接声明对象而不显示地调用构造函数，比如我们的类中还有一个重载的没有参数的构造函数，它可以这样被调用： 1234MyClass myClass; // 隐式调用MyClass myClass = MyClass(); // 显示调用MyClass * myClass = new MyClass(); // 隐式调用MyClass myClassFunction(); // 这是一个返回值是MyClass的函数 析构函数用构造函数创建对象后，程序负责跟踪该对象，直到其过期为止，对象过期时，程序将自动调用一个特殊的成员函数，即析构函数。 析构函数用于完成清理工作，所以非常有用，例如如果构造函数用new分配了内存，则可以在析构函数中用delete释放内存。 默认的析构函数是什么都不做的。我们以可以显示地定义自己析构函数，析构函数是一个~符号加上类名来定义的，析构函数何时调用是取决于编译器的。 12345678910class MyClass&#123;private: int myInt; double myDouble;public: MyClass(int mi, double md) &#123; myInt = mi; myDouble = md;&#125;; MyClass() &#123; myInt = 1; myDouble = 0.2;&#125;; ~MyClass() &#123; cout &lt;&lt; \"bye!\"; &#125;;&#125; const成员函数const成员函数是指，保证该成员函数不会改变调用的对象，声明和定义const成员函数需要将const限定符加在成员函数的后边： 12345void show() const;void MyClass::show() const&#123; // function body&#125; 以这种方式声明和定义的类函数即const成员函数，应该尽可能地将成员函数修饰为const，只要该类的方法不修改调用对象。 this指针this指针在类的成员函数中，用来作为指向调用类对象自身的指针，即它指向自己的类的地址。我们上面的构造函数中的 myInt = mi; 这一语句，其实这里的 myInt 就是 this-&gt;myInt 的简写，因为在类中，可以直接用成员变量简单地替换 this-&gt; 成员变量。 this指针在只操作自身类内成员的时候不会有特别多的作用，因为都可以省略它，但是一旦我们的成员函数涉及到两个及以上的类的对象时，this就发挥了很大的作用。例如我们有一个compare函数，用于比较两个MyClass类的实例的哪一个的myInt值更大，那么我们必然需要另一个MyClass的实例作为参数，然后让它的myInt和自己的myInt比较，然后返回myInt较大的那个MyClass的引用，所以可以这样声明这个函数： 1const MyClass &amp; MyClass::compare(const MyClass &amp; myClass) const; 函数定义中涉及到三个const： 第一个const：表明返回值是一个MyClass，显然不能被改变，所以可以时const的 第二个const：传入的MyClass实例只是用于比较的，不需要改变，所以使用const 第三个const：由于成员函数不改变调用类对象，所以是const的成员函数 比较myInt的函数可以使用this来这样实现： 1234567const MyClass &amp; MyClass::compare(const MyClass &amp; myClass) const&#123; if(myClass.myInt &gt; this-&gt;myInt) return myClass; else return *this;&#125; 很显然，上边的 this-&gt;myInt 可以使用 myInt 直接简写，而返回自己调用类对象的时候，就只能用 this 来称呼了，而且需要注意的是，返回的是一个MyClass的引用，从而需要使用*this而不是直接返回this，因为this是指针 对象数组类和其他数据结构一样，都可以创建数组，对象的数组即可以存储多个类对象，只需要像下边这样声明它们： 123MyClass myClasses[3];myClasses[0].show();myClasses[1].compare(myClasses[2]); 运算符重载运算符重载即将C++中的运算符重载扩展到用户自定义的类型，例如，+这个运算符，只能用于整形、浮点型、字符串等基本的数据结构相加，但是我们可以通过用户的定义，将其用于两个类的对象相加，两个数组相加等等，编译器会根据操作数和目的数的类型决定使用哪种定义。 运算符重载的写法运算符重载的格式为： 1operator op (arguments); 比如： 123operator +( ); // 重载+运算符operator *( ); // 重载*运算符operator [ ]( ); // 重载[]运算符 一个运算符重载的例子假设我们有一个时间类Time，由两个私有成员变量 hours、minutes 来代表小时和分钟，我们来实现Time类对象的相加逻辑。 123456789101112131415161718192021222324252627282930class Time&#123;private: int hours; int minutes;public: Time; Time(int h, int m=0); Time operator + (const Time &amp; t) const;&#125;; Time::Time()&#123; hours = minutes = 0;&#125; Time::Time(int h, int m)&#123; hours = h; minutes = m;&#125; Time Time::operator + (const Time &amp; t) const&#123; Time sum; sum.minutes = minutes + t.minutes; sum.hours = hours + t.hours + sum.minutes / 60; sum.minutes %= 60; return sum;&#125; 使用这个重载的+运算符可以将两个Time的对象像其他一般数据类型一样进行相加： 123Time time1;Time time2;Time total = time1 + time2; 运算符重载的限制多数C++运算符都可以用这样的方式重载。重载的运算符（有些例外情况）不必是成员函数，但必须至少有一个操作数是用户定义的类型。C++运算符重载的限制如下： 重载后的运算符必须至少有一个操作数是用户定义的类型，这将防止用户为标准类型重载运算符因此，例如不能将减法运算符重载为计算两个 double 值的和，而不是它们的差。 使用运算符时不能违反运算符原来的句法规则。例如，不能将求模运算符（%）重载成使用一个操作数的运算 不能修改运算符的优先级。例如，如果将加号运算符重载成将两个类相加，则新的运算符与原来的加号具有相同的优先级 不能创建新运算符。例如，不能定义 operator **() 函数来表示求幂 不能重载下面的运算符 sizeof ：sizeof 运算符 . ：成员运算符 * ：成员指针运算符 :: ：作用域解析运算符 ? : ：条件运算符 typeid：一个RTTI运算符 const_cast：强制类型转换运算符 dynamic_cast：强制类型转换运算符 reinterpret_cast：强制类型转换运算符 static_cast：强制类型转换运算符 大多数运算符都可以通过成员函数或者非成员函数进行重载，但是如下的运算符只能通过成员函数进行重载： =：赋值运算符 ( )：函数调用运算符 [ ]：下标运算符 -&gt;：通过指针访问类成员运算符 可以重载的运算符 + - * / % ^ &amp; ` ` ~= ! = &gt; += -= *= /= %= ^= &amp;= ` =` &lt;&lt; &gt;&gt; &lt;&lt;= == != &lt;= &gt;= &amp;&amp; ` ` ++ -- , () [] new delete new[] delete[] 友元函数类的友元函数是非成员函数，其访问权限与成员函数相同。 一个友元函数的例子回到上面的Time类，我们重载运算符：将运算符重载成一个double值乘以一个Time类： 12345678Time Time::operator * (const double d) const&#123; Time result; long totalMinutes = hours * d * 60 + minutes * d; result.hours = totalMinutes / 60; result.minutes = totalMinutes % 60; return result;&#125; 显然调用上述*的重载需要这样： 123Time A();Time B(1, 20);A = B * 2.5; 相当于调用了这样的运算符重载的成员函数： 1A = B.operator*(2.5); 但是，问题来了，如果使用 A = 2.5 * B 就无法成功，这似乎违背了乘法的分配律，这一点虽然并不有违于C++的语法，但是貌似并不用户友好，我们需要告诉使用的人只能用第一种方式而不能用第二种方式。解决这个问题有两个方法： 使用一个非成员函数来定义反写的情况：1234Time operator * (double d, const Time &amp; t)&#123; return t * m;&#125; 这种方式不失为是一种非常好的方法，而且如果有所修改，只需要修改类内的运算符重载即可。 使用友元函数和上述的思想类似，我们可以定义一个非成员函数，然后这样的重载运算符，从而定义一个double乘以一个Time类对象的操作： 1Time operator * (double d, const Time &amp; t); 但是问题在于类外的非成员函数无法访问类的私有变量。所以友元函数的作用在于可以访问类的私有成员，但是他是一个非成员函数。 创建友元函数创建友元函数的第一步是将其原型放在类声明中，并在原型声明前加上关键字 friend： 1friend Time operator*(double m, const Time t); 该原型意味着下面两点： 虽然 operator*() 函数是在类声明中声明的，但它不是成员函数，因此不能使用成员运算符来调用 虽然 operator*() 函数不是成员函数，但它与成员函数的访问权限相同 第二步是编写函数定义。因为它不是成员函数，所以不要使用 Time:: 限定符。另外，不能在定义中使用关键字 friend： 12345678Time operator * (double d, const Time &amp; t)&#123; Time result; long totalMinutes = hours * d * 60 + minutes * d; result.hours = totalMinutes / 60; result.minutes = totalMinutes % 60; return result;&#125; 上述定义后即可使用如下的语句来使用乘法： 1A = 2.5 * B; 相当于调用友元函数： 1A = operator*(2.5, B); 成员函数和非成员函数的选择对于一般的运算符重载，比如+和-这种不会出现乘法那种左右交换的问题的，有两种解决方式： 12Time operator + (const Time &amp; t) const;friend Time operator + (const Time &amp; t1, const Time &amp; t2); 第一种方式是通过this隐式地传递一个参数，另一个使用函数参数显示地传递；第二种方式是两个参数都显示地通过参数传递。在调用 T1 = T2 + T3 时，会分别编译成如下的形式： 12T1 = T2.operator+(T3);T1 = operator+(T2, T3); 但是，两种方式不能同时定义，只能选择其中一个，否则会引发二义性的编译错误，基于乘法的例子，显然使用友元函数比较通用。 类的自动转换和强制类型转换强制类型转换C++允许一些强制类型转换，比如强制将double值转换成int值，把double的2.5转换成int会成为2从而丢失0.5。但是如果用户希望进行强制转换只需要使用如下的方式： 12targetType valueName = (targetType) value;targetType valueName = targetType (value); 使用构造函数进行类的自动转换假设我们有一个类 123456789101112131415161718192021222324252627class MyClass&#123;private: int myInt; double myDouble;public: MyClass(double d); MyClass(int i, double d); MyClass(); ~MyClass();&#125; MyClass::MyClass(double d)&#123; myDouble = d; myInt = 0;&#125; MyClass::MyClass(int i, double d)&#123; myDouble = d; myInt = i;&#125; MyClass::MyClass()&#123;&#125; 然后我们尝试将一个double值赋给一个MyClass类对象： 12MyClass myClass;myClass = 2.5; 这是可以的，首先创建了一个MyClass的对象，然后使用2.5将其初始化，实际上是使用了第一个构造函数 MyClass(double)，这是一个隐式转换的过程，不需要进行强制转换。 只有接受一个参数的构造函数才能作为转换函数，如果像第二个构造函数那样有两个参数，不能用来转换类型，但是如果第二个参数有默认参数，就可以： 1MyClass(int i, double d = 1.5); 这个可以将一个int值隐式地转换成MyClass类型。 如果不希望编辑器进行这种隐式转换，可以使用explicit关键词修饰构造函数，这样就无法使用该构造函数进行类型转换： 1explicit MyClass(double d); 这样会关闭隐式转换，但依然允许显示转换，即使用显式地强制转换： 123MyClass myClass;myClass = MyClass(2.5);myClass = (MyClass)2.5; 转换函数上边提到了隐式或者显式地将基本数据类型的数据转换成类对象，接下来的问题是如何将一个类对象转换成其他的基本数据类型，这一点可以通过转换函数来实现。转换函数是用户定义的强制类型转换，需要这样定义： 1operator dateType()； 需要注意的是： 转换函数必须是类方法 转换函数不能指定返回类型 转换函数不能有参数 比如我们将MyClass转换为一个double类型的变量，需要这样一个成员函数： 123456operator double(); MyClass::operator double()&#123; return myDoble;&#125; 然后就可以这样使用类型转换了： 123MyClass myClass(1, 2.5);double myDouble = (double) myClass;double myDouble = double (myClass); 复制构造函数复制构造函数接受其所属类的对象作为参数。例如，MyClass类的复制构造函数的原型如下： 1MyClass(const MyClass &amp;); 在下述情况下，将使用复制构造函数： 将新对象初始化为一个同类对象 按值将对象传递给函数 函数按值返回对象 编译器生成临时对象 如果程序没有使用（显式或隐式）复制构造函数，编译器将提供原型，但不提供函数定义；否则，程序将定义一个执行成员初始化的复制构造函数。也就是说，新对象的每个成员都被初始化为原始对象相应成员的值。如果成员为类对象,则初始化该成员时，将使用相应类的复制构造函数。","categories":[{"name":"C++","slug":"C","permalink":"https://blogs.littlegenius.xin/categories/C/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"C","permalink":"https://blogs.littlegenius.xin/tags/C/"}]},{"title":"【算法】（一）排序算法","slug":"【算法】一排序","date":"2019-08-24T15:45:32.000Z","updated":"2019-08-24T15:50:37.777Z","comments":true,"path":"2019/08/24/【算法】一排序/","link":"","permalink":"https://blogs.littlegenius.xin/2019/08/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%B8%80%E6%8E%92%E5%BA%8F/","excerpt":"","text":"排序算法的分类 比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 算法复杂度 算法的复杂度 相关概念 稳定：如果a原本在b前面，而a=b，排序之后 a 仍然在 b 的前面。 不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。 时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。 空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 排序算法插入排序插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5。 冒泡排序冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 比较相邻的元素。如果第一个比第二个大，就交换它们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 重复步骤1~3，直到排序完成。 选择排序选择排序（Selection-sort）是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 初始状态：无序区为R[1..n]，有序区为空； 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区； n-1趟结束，数组有序化了。 希尔排序1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1； 按增量序列个数k，对序列进行k 趟排序； 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 缩小增量间隔的方法 grap=[grap/2] 快速排序快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 从数列中挑出一个元素，称为 “基准”（pivot）； 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 归并排序归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 把长度为n的输入序列分成两个长度为n/2的子序列； 对这两个子序列分别采用归并排序； 将两个排序好的子序列合并成一个最终的排序序列。 堆排序堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区； 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]； 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。 计数排序计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 找出待排序的数组中最大和最小的元素； 统计数组中每个值为i的元素出现的次数，存入数组C的第i项； 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）； 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。 桶排序桶排序（Bucket sort）是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。 设置一个定量的数组当作空桶； 遍历输入数据，并且把数据一个一个放到对应的桶里去； 对每个不是空的桶进行排序； 从不是空的桶里把排好序的数据拼接起来。 基数排序基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。 取得数组中的最大数，并取得位数 arr为原始数组，从最低位开始取每个位组成radix数组 对radix进行计数排序（利用计数排序适用于小范围数的特点） 参考：https://www.cnblogs.com/onepixel/articles/7674659.html","categories":[{"name":"算法","slug":"算法","permalink":"https://blogs.littlegenius.xin/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"算法","slug":"算法","permalink":"https://blogs.littlegenius.xin/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【数据结构】（五）堆","slug":"【数据结构】五堆","date":"2019-08-24T07:03:50.000Z","updated":"2019-08-24T07:19:43.874Z","comments":true,"path":"2019/08/24/【数据结构】五堆/","link":"","permalink":"https://blogs.littlegenius.xin/2019/08/24/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%BA%94%E5%A0%86/","excerpt":"","text":"堆（Heap）堆（Heap）又称为优先队列（priority queue），在队列的基础上，堆允许所有队列中的元素不一定按照先进先出（FIFO）的规则进行，而是使得每个元素有一定的优先级，优先级高的先出队列。 这类数据结构属于计算机科学中最雅致的一种 优先队列至少存在两个重要的操作： insert：插入，使得数据入队列，是一种有约束的enqueue操作 deleteMin：删除最小项，找出、返回并删除优先队列中最小的元素，也就是最大优先级的元素，是一种有约束的dequeue操作 优先队列 堆的简单实现有几种简单而明显的方法实现优先队列。 简单链表：在表头以O(1)执行插入操作，遍历该链表以O(N)删除最小元 始终有序的链表：插入代价以O(N)进行，删除操作以O(1)进行 二叉查找树：对插入和删除两种操作的平均运行时间都是O(log)。尽管插入是随机的，而删除则不是，但是并不影响这个结论，反复除去左子树中的结点（最小值）损害了树的平衡，使得右子树加重。在最坏情形下，即将左子树删空的情形下，右子树拥有的元素最多也就是它应具有的两倍，这只是在其期望的深度上加了一个小常数 ALV树：可能有些过分，因为它支持大量并不需要的操作 二叉堆二叉堆（binary heap）是一种对于优先队列的实现，可以简称为堆 结构性质堆是一棵完全二叉树（complete binary tree），即所有节点都必须有左右两个子节点，除了最后一排元素从左向右填入，直到没有元素为止。 很显然，一棵高为h的完全二叉树有 2^h 到 2^(h+1)-1 个节点，即其高度为 logN 向下取整。 二叉堆 完全二叉树的好处在于其规律性，可以使用一个数组而不需要链表来表示 二叉堆的数组表示 对于数组中任一位置 i 上的元素，其左儿子在位置 2i 上，右儿子在左儿子后的单元 (2i+1) 上，它的父亲则在位置 i/2 向下取整上。 因此，不仅不需要链，而且遍历该树所需要的操作也极简单，在大部分计算机上都可能运行得非常快。唯一问题是最大的堆的大小需要事先估计。 堆序性质使操作可以快速执行的性质是堆序性质（heap-order property）：对于每一个节点X，X的父节点中的键小于等于X中的键，除没有父节点根节点外。 二叉堆 基本操作insert插入将待插入的元素首先放置在最后一个位置上，以保证他是一个完全二叉树，然后将该元素与其父节点（i/2向下取整）比较，如果比其父节点小，就将两者互换，互换后再和新的父节点比较，这种方式称为上滤（percolate up），得到一个小顶堆（min heap），如果比较的时候是较大的值向上走，就会得到一个大顶堆（max heap） 比如向一个小顶堆中插入元素14的操作： 小顶堆的插入 deleteMin删除找出、返回并删除最小元非常简单，最小元就是根节点处的元素，将其返回并删除。接下来是处理这个B。首先拿下最后一个元素X，如果元素X比B的两个子节点都小，可以直接将X插入到B的位置，如果X比B的两个子节点中的任意一个大，就不能插入，此时找到两个子节点中较小的那个放到B处，B转而移至这个子结点处。重复如上的步骤直到X可以插入B处为止。这个操作成为下滤（percolate down） 比如从一个小顶堆中删除根节点 从小顶堆中删除 从小顶堆中删除 从小顶堆中删除 decreaseKeydecreaseKey(p, A) 操作减小在位置p处的元素的值，减少量为A，可以理解为调高了某个元素的优先级。操作破坏了堆的性质，从而需要上滤操作进行堆的调整。 increaseKeyincreaseKey(p, A) 操作增加在位置p处的元素的值，增加量为A，可以理解为降低了某个元素的优先级。操作破坏了堆的性质，从而需要下滤操作进行堆的调整。 removeremove(p) 操作删除在堆中位置p处的节点，这种操作可以通过连续执行 decreaseKey(p, ∞) 和 deleteMin() 完成，可以理解马上删除某个一般优先级的元素 buildHeap即将一个原始集合构建成二叉堆，这个构造过程即进行N次连续的insert操作完成 定理：包含 2^(h+1)-1 个节点且高度为h的理想二叉树（perfect binary tree）的节点的高度和为 2^(h+1)-1-(h+1) d堆d堆（d-Heaps）是二叉堆的简单推广，它与二叉堆很像，但是每个节点都有d个子节点，所以二叉堆是d为2的d堆。d堆是完全d叉树。比如下边的一个3堆。 一个3堆 d堆比二叉堆浅很多，其insert的运行时间改进到 O(logdN) 。但是deleteMin操作比较费时，因为要在d个子节点中找到最小的一个，需要进行d-1次比较。d堆无法进行find操作，而且将两个堆合二为一是很困难的事情，这个附加操作为merge合并。 注意！在寻找节点的父节点、子节点的时候，乘法和除法都有因子d。如果d是一个2的幂，则可以通过使用二进制的移位操作计算，这在计算机中是非常省时间的。但是如果d不是一个2的幂，则使用一般的乘除法计算，时间开销会急剧增加。有证据显示，实践中，堆可以胜过二叉堆 左式堆这些高级的数据结构很难使用一个数据结构来实现，所以一般都要用到链式数据结构，这种结构可能会使得其操作变慢。 左式堆的定义零路径长（null path length）npl(X)：定义为从一个X节点到其不具有两个子节点的子节点的最短路径长，即具有0个或者1个子节点的节点npl=0，npl(null)=-1，任意节点的零路径长都比其各个子节点中零路径长最小值多1。 左式堆（leftist heap）是指对于任意一个节点X，其左子节点的零路径长都大于等于其右子节点的零路径长。很显然，左式堆趋向于加深左路径。比如下边的两个堆，只有左边的是左式堆，堆的节点标示的是该节点的零路径长。 左式堆 左式堆的实现中，需要有四个值：数据、左指针、右指针和零路径长。 1234567struct LeftistHeap&#123; Object data; LeftistHeap* leftChild; LeftishHeap* rightChild; int npl;&#125; 定理：在右路径上有r个节点的左式堆必然至少有 2^r-1 个节点 左式堆的合并merge是左式堆的基本操作，insert插入可以看成是一个单节点的堆与一个大堆的merge，deleteMin删除最小值操作可以看成是首先返回、删除根节点，然后将根节点的左右子树进行merge。所以merge是左式堆的基本操作。 假设现在有两个非空的左式堆H1和H2，merge操作递归地进行如下的步骤： 将H1和H2中根节点较的堆（比如是H2）与根节点较小的堆（比如是H1）的右子堆进行merge 让新的merge的堆成为根节点较小的堆（H1）的右字堆 如果在根结点处出现左右子堆不符合左式堆的条件的情况，互换左右子堆的位置并更新npl的值 例如如下的两个堆： 合并两个左式堆 将H2与H1的右子树（8–17–26）进行merge操作，此时（8–17–26）和H2的merge操作中又需要（8–17–26）和H2的右子堆（7–37–18）进行merge操作……如此递归得到如下的堆： 合并两个左式堆 然后根据递归的最外层（回到H1和H2的merge的第二步），将上边合并的堆成为H1的右子堆 合并两个左式堆 此时根节点（3）处出现了左右子堆不符合左式堆的情况，互换左右子堆并更新零路径长的值 合并两个左式堆 斜堆斜堆（skew heap）是左式堆的自调节形式，实现起来极其简单。斜堆和左式堆的关系类似于伸展树和AVL树之间的关系。斜堆是具有堆序的二叉树，但是不存在对树的结构的现限制。不同于左式堆，关于任意结点的零路径长的任何信息都不保留。斜堆的右路径在任何时刻都可以任意长，因此，所有操作的最坏情形运行时间均为O(N)。然而，正如伸展树一样，可以证明对任意M次连续操作，总的最坏情形运行时间是 O(MlogN)。因此，斜堆每次操作的摊还开销（amortized cost）为O(logN) 斜堆的合并斜堆的基本操作也是merge合并，和左式堆的合并相同，但是不需要对不满足左右子堆的左式堆条件的节点进行左右子堆的交换。斜堆的交换是无条件的，除右路径上所有节点的最大者不交换它的左右儿子外，都要进行这种交换。 比如将上述的H1和H2进行merge合并操作 合并两个斜堆 首先进行第一步，除了交换左右子树的操作与左式堆不同，其他的操作都相同 合并两个斜堆 将合并的堆作为H1的右子堆并交换左右子堆，得到合并后的斜堆 合并两个斜堆 二项队列二项队列（binomial queue）支持merge、insert和deleteMin三种操作，并且每次操作的最坏情形运行时间为O(logN)，插入操作平均花费常数时间。 二项队列的结构二项队列不是一棵堆序的树，而是堆序的树的集合，成为森林（forest）。堆序树中的每一棵都是有约束的二项树（binomial tree）。二项树是每一个高度上至多存在一棵二项树。高度为0的二项树是一棵单节点树，高度为k的二项树Bk通过将一棵二项树Bk-1附接到另一棵二项树Bk-1的根上而构成的。如下图的二项树B0、B1、B2、B3和B4。 二项树 可以看到二项树Bk由一个带有儿子B0，B1，……，Bk-1的根组成。高度为k的二项树恰好有2^k个节点，而在深度d处的节点数为二项系数Cdk。 我们可以使用二项树的集合唯一地表示任意大小的优先队列。以大小为13的队列为例，13的二进制表示为1101，从而我们可以使用二项树森林B3、B2、B0表示，即二进制表示的数中，第k位为1表示Bk树出现，第k位为0表示Bk树不出现。比如上述的堆H1和堆H2可以表示为如下的两个二项队列： H1和H2的二项队列表示 二项队列的合并二项队列额merge合并操作非常简单，以上边的二项队列H1、H2为例。需要将其合并成一个大小为13的队列，即B3、B2、B0。 首先H2中有一个B0，H1中没有，所以H2中的B0可以直接作为新的队列的B0的树 其次H1和H2中两个B1的树可以合并成一个新的B2的树，只需要将其中根节点较小的堆挂到根节点较大的堆的根节点上。这样就得到了三棵B2堆，将其中根节点最大的堆直接放到新队列中成为它的B2堆。 最后将两个B2堆合并成一个新队列中的B3堆。 二项队列的合并 二项队列的deleteMin很简单，只需要比较队列中所有二项堆的根节点，返回和删除最小的值即可，时间复杂度为O(logN)，然后进行一次merge操作，也可以使用一个单独的空间每次记录最小值，这样就可以以O(1)的时间返回。 二项队列的实现森林中树的实现采用“左子右兄弟”的表示方法，然后二项队列可以使用一个数组来记录森林中每个树的根节点。 例如上边的合成的二项队列可以表示成如下的样子： 二项堆列的实现 标准库中的优先队列STL中，二叉堆是通过priority_queue模板类实现的，在头文件queue中，STL实现一个大顶堆而不是小顶堆，其关键的成员函数如下： void push( const object &amp; x ); const Object &amp; top( ) const; void pop( ); bool empty( ); void clear( );","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://blogs.littlegenius.xin/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"C","permalink":"https://blogs.littlegenius.xin/tags/C/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blogs.littlegenius.xin/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"【数据结构】（四）散列","slug":"【数据结构】四散列","date":"2019-08-19T15:22:06.000Z","updated":"2019-08-19T15:30:28.470Z","comments":true,"path":"2019/08/19/【数据结构】四散列/","link":"","permalink":"https://blogs.littlegenius.xin/2019/08/19/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%9B%9B%E6%95%A3%E5%88%97/","excerpt":"","text":"哈希（hashing）又称散列，是实现散列表的技术。散列是一种用于以常数平均时间执行插入、删除和查找的技术，因此涉及到元素间排序信息的操作不会得到支持，如树的findMin、findMax以及按照顺序打印列表这些操作散列是不支持的。 散列的基本思想散列是一个固定大小的数组，存储的是键值对（Key–Value），键一般是好操作的数据，值一般存储比较大的实际意义强的数据，键的存在是便于使用键进行数据的查找。 散列的基本思想是使用一个对应关系（映射关系），这里称之为散列函数（hashing function），将哈希表的存储位置（0到TableSize-1）与键做一个对应，理想情况下是得到一个一一映射。但是这是不可能的，从而还需要确定一个方案来解决当两个键都被对应到同一个存储位置上时的情况，这个过程叫做解决冲突（collision） 散列函数 如果键时整数，一般使用 Key mod TableSize 作为对应的索引。通常，为了使哈希的分布均匀，通常采取素数大小的哈希表，当输入的键是随机整数的时候，散列函数不仅运算简单而且键的分配也很均匀 如果键时字符串 一种策略是将字符串中字符的ASCLL码值求和，然后使用整数策略，这种方式不够均匀 一种策略是取字符串的前几位的ASCLL码值求和，然后使用整数策略，这种方式不够均匀 一种较好的策略是递归地求 h = k0+37 k1+37^2 k2 作为键，或者对一些选取的字符（而不是整个字符串）采用如上的策略 解决冲突的方法无论如何设计散列函数，都能保证对于任何一个键都可以找到唯一的存储索引而不发生冲突，所以解决冲突是哈希实现的关键 分离链接法分离链接法（separate chaining）将散列到同一个值的所有元素保存到一个链表中 分离链接法 这种方式的缺点是使用了一些链表，所以给新单元分配地址需要较多的时间开销。 探测散列表一般为了减少使用链表带来的较大的时间开销，通常避免使用链表，而将所有的数据都放入表内，所以这种方式需要散列表要比较大才行。一般要求装填的数据和总数据含量之比小于0.5，这样的表成为探测散列表（probing hash tables）。 探测散列表的散列函数为 h(x)=(hash(x)+f(i)) mod TableSize 且 f(0)=0，说白了就是如果应该在的位置冲突了，就按照一定的规律去找下一个空位置，以此类推。根据寻找下一个空位置的方式不同可以分为如下的几种探测方式。 线性探测（Linear Probing）f(i)=i，当一个位置出现冲突时，顺序查找下一个位置，直到找到一个空位置为止 线性探测 平方探测（Quadratic Probing）f(i)=i^2，即冲突函数为二次函数的探测方法 二次探测 关于二次探测，这里有一个定理：如果表的大小是素数，那么当表至少有一半是空的时候，总能够插入一个新的元素 双散列（Double Hashing）双散列（Double Hashing）也是一种解决冲突的方式，对于双散列，一种流行的方式是选择 f(i)=i*hash’(x), hash’(x)=R-(x mod R), 其中R通常选取一个素数。 双散列 再散列（Rehashing）再散列（Rehashing）的思想是当一个散列表将要被耗尽时，建立一个新的比原来的表大约两倍的表并且使用新的散列函数，将原表中的数据通过新的散列函数安排到新表中。例如下边的例子： 首先有一个大小为7的散列表： 再散列例子 向这个表中插入数据23，得到了如下的表，由于此时数据已占用超过70%，从而创建一个新的大小为17的散列表。新的表的选取，是按照原来的散列表的二倍的后边第一个素数来规定。 再散列例子 将原来哈希表中的五个数据根据 key mod 17 再重新计算位置，添加到新的散列中去 再散列例子","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://blogs.littlegenius.xin/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"C","permalink":"https://blogs.littlegenius.xin/tags/C/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blogs.littlegenius.xin/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"【数据结构】（三）树","slug":"【数据结构】三树","date":"2019-08-18T16:16:53.000Z","updated":"2019-08-19T15:30:22.596Z","comments":true,"path":"2019/08/19/【数据结构】三树/","link":"","permalink":"https://blogs.littlegenius.xin/2019/08/19/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%B8%89%E6%A0%91/","excerpt":"","text":"树树的实现实现树时，对于每一个节点，除了存储该节点的数据以外，还需要存储一些外链。 一个典型的存储方式是：左孩子右兄弟法，即对于每一个节点，存储节点的数据、指向其孩子中最左边的孩子的指针、指向其紧邻的右侧的兄弟节点的指针。 123456struct TreeNode&#123; Object element; TreeNode * firstChild; TreeNode * nextSiling;&#125;; 如下边的这棵树通过这种方式表现的结果是这样的： 采用“左子右兄弟”表示树 二叉树二叉树（binary tree）是一棵每个节点都不能有多于两个儿子的树 二叉树的特点 二叉树第i层上至多有 2i-1 个节点 深度为k的二叉树至多有 2k-1 个节点 对于一棵非空二叉树，如果其叶子节点数为n0，度为2的节点数为n2，则n0=n2+1 具有n个节点的完全二叉树的深度为 [log2n]+1 (向下取整数) 如果对于n个节点的完全二叉树，第 i&gt;0 的节点，其父节点为 [(i-1)/2] (向下取整) 二叉树的一个性质是平均二叉树的深度要比结点个数N小得多，这个性质有时很重要。分析表明，这个平均深度为O(√N)，而对于特殊类型的二叉树，即二叉查找树( binary search tree)，其深度的平均值是O(logN)。当然极端的树的深度也可以大到N-1。 二叉树的实现由于二叉树的每个节点最多有两个儿子，所以可以直接连接到它们。 123456struct BinaryNode&#123; Object element; BinaryNode * left; BinaryNode * red;&#125;; 二叉查找树二叉查找树（Binary Search Trees）是二叉树，它的特点是：对于任何一个节点X，其左子树中的所有节点的值都小于该节点X，其右子树中的所有节点的值都大于该节点X。如下图中的左边就是一棵二叉查找是，而右侧不是： 二叉查找树 重要的方法与其实现 isEmpty：是否为空树，这一点很重要，一般在进行树的相关操作时都会先确定是否是一个空树，只要指向根节点的指针为NULL，就表示是一个空树 contains：是否包含某项，在确定树非空后，查找是否包含某个项，将目标项与根节点进行比较开始，如果比该节点大，就从右子树查找，如果比该节点小，就从左子树查找，如果出现相等的则表示包含该项，如果一直不相等且无子树可以继续查找，则不包含此项 findMin：找到最小值，一直找左子树，直到找到没有左子树的左子树最左边的节点就是最小值 findMax：找到最大值，一直找右子树，直到找到没有右子树的右子树最右边的节点就是最大值 insert：插入某个值，从根节点开始比较，如果目标值比该节点大就插入其右子树，否则插入左子树，如果出现相等的情况说明有该元素不需要再插入，直到插入某个空节点为止 remove：删除节点 删除叶子节点：直接删除 删除有一个子节点的节点：将该子节点挂到被删除的节点的父节点上，取代删除节点的位置 删除只有一个子节点的子节点 删除有两个子节点的节点：找到该节点右子树中的最小值或者左子树中的最大值，将其替换要删除的元素，然后递归地删除用来替换的最大/小值，为什么是递归地删除呢？因为被拿出来替换被删除值的那个最大/小值也会有子树，所以删除它的时候还要执行删除remove操作。但是最多只进行一次单子节点的删除工作，因为无论是右子树中的最小值还是左子树中的最大值，最多只有一个子树 删除有两个子节点的子节 平均情况分析 操作 平均时间复杂度 isEmpty O(1) contains O(logN) findMin/findMax O(logN) insert O(logN) remove O(1) AVL树AVL（Adelson-Velskii and Landis）树是带有平衡条件（balance condition）的二叉查找树，这个平衡条件很容易保持并且保证了树的深度为O(logN)。 AVL树要求每个节点的左子树和右子树的高度差最多为1。 AVL树 AVL树除了插入操作外，其他所有的操作都可以最多以O(logN)的时间执行 AVL树的插入AVL树的插入比较复杂的点在于插入的值可能会破坏树原本的平衡，所以在插入值后需要进行旋转（rotation） 旋转的情况可以根据插入后的树的情况分为如下四种： 示意图来源：https://blog.csdn.net/gabriel1026/article/details/6311339 插入后的情况 描述 旋转方式 LL-左子树左高 在左子树根节点的左子树上插入节点而破坏平衡 右旋转 RR-右子树右高 在右子树根节点的右子树上插入节点而破坏平衡 左旋转 LR-左子树右高 在左子树根节点的右子树上插入节点而破坏平衡 先左旋后右旋 RL-右子树左高 在右子树根节点的左子树上插入节点而破坏平衡 先右旋后左旋 LL-左子树左高的情况 LL-左子树左高 RR-右子树右高的情况 RR-右子树右高 LR-左子树右高的情况 LR-左子树右高 RL-右子树左高的情况 RL-右子树左高 伸展树伸展树与摊还时间伸展树（splay tree）保证从空树开始任意连续M此对树的操作最多花费O(MlogN)的时间，即这M次连续的操作中即使有些操作耗时长，但是也有一些耗时短的操作，使得这M个连续的操作花费的总时间最坏为O(MlogN)。 摊还（amortized）：一般说来，当M次操作的序列总的最坏情形运行时间为O(M f(N))时,我们就说它的摊还(amortized)运行时间为O(f(N))。因此，一棵伸展树每次操作的摊还代价是O(logN)。经过一系列的操作，有的操作可能花费时间多一些，有的可能要少一些，不存在不好的输入队列。 如果任意特定操作可以有最坏时间界O(N)，而我们仍然要求一个O(logN)的摊还时间界，那么很清楚，只要有一个结点被访问，它就必须被移动。否则，一旦我们发现一个深层的结点，就有可能不断地对它进行访问。如果这个结点不改变位置，而每次访问又花费O(N)，那么M次访问将花费O(MN)的时间。这个思想和数据库中将经常访问到的数据前移以及操作系统中将经常访问的数据放入cache高速缓存等思想相同。（在许多应用中，当一个结点被访问时，它就很可能不久再被访问。研究表明，这种情况的发生比人们预料的要频繁得多。） 伸展（splaying）伸展树的基本思想是将访问到的一个较深的节点通过旋转的方式将其旋转到根节点的位置，但是为了保证旋转过程中不让一些较浅的节点也被沦落到较深的位置，这里的伸展采用一定的策略： 首先，一个要被旋转到树根处的深节点X，如果X的父节点就是根节点，那么只要旋转X和树根即可 如果X的父节点不是根节点，将其父节点命名为P，同时X一定有祖父节点G，X、P、G三个节点存在两种排列关系： “之字形”（zig-zag）：这种情况下执行一次AVL树同理的双旋转 “之字形”（zig-zag） “一字形”（zig-zig）：这种情况下直接将树左右对调（类似于跷跷板） “一字形”（zig-zig） 一个例子如下图，想把 K1 节点调至树根处 一个伸展树的例子 首先由K1、K2、K3构成了一个“之字形”结构，使用双旋转方式得到如下的第一次调整 一个伸展树的例子 然后由K1、K4、K5构成了一个“一字形”结构，采用跷跷板的方式做第二次调整 一个伸展树的例子 树的遍历树的遍历分为三种 先根遍历：每棵树按照 根-左子树-右子树 顺序遍历 中根遍历：每棵树按照 左子树-根-右子树 顺序遍历 后根遍历：每棵树按照 左子树-右子树-根 顺序遍历 B树B树的思想很简单，如果我们使用二叉树，树的平均深度为logN，如果我们是一个M叉树（每个节点最多有M个子树），则树的平均深度为logMN，显然这样会使得树的深度降低。 M阶B树的规范 数据项存储在树叶上 非叶结点存储直到 M-1 个键，以指示搜索的方向；键 i 代表子树 i+1 中的最小的键 树的根或者是一片树叶，或者其儿子数在2和M之间 除根外，所有非树叶结点的儿子数在 [M/2]（向上取整）和M之间 所有的树叶都在相同的深度上并有 [L/2]（向上取整）和L之间个数据项 一个5阶B树的例子一个5阶的B树，所有的非叶子节点的儿子都在3和5之间，从而有2到4个键，根可能只有两个的儿子，L=5，因此每个树叶有3到5个数据项，要求节点一半满，保证B树不致退化成简单的二叉树 一个5阶B树的例子 向B树中插入 57 数据项：按照键索引到插入数据的位置，插入数据项 一个5阶B树的例子 再插入 55 数据项，导致该叶子节点数据超出5，所以需要分裂其父节点成为两个叶子 一个5阶B树的例子 再插入 40 数据项，引起树叶被分裂成两片然后又造成父结点的分裂 一个5阶B树的例子 从B树中删除 99 数据项导致叶子节点的数据少于3从而合并叶子，而父节点也少于3从而再一次合并 一个5阶B树的例子 标准库（SLT）中的set和mapsetset是一个排序后的容器，不允许重复。set特有的操作是高效的插入、删除和执行基本查找。set也允许使用iterator来遍历。 set的方法 与vector和list相同的方法 iterator begin()：返回容器开始的迭代器 iterator end()：返回容器结尾处的迭代器 int size() const：返回容器内的元素个数 bool empty()：如果容器没有元素，返回 true，否则返回 false 特有的插入操作，set使用insert进行插入操作，由于非重复性，导致插入有可能会失败，insert操作返回一个iterator指明插入新项的位置或者失败时已有的项的位置.。pair是一个类模板，并且提供两个成员 first 和 second 用来访问返回值的两项成员 pair&lt;iterator, bool&gt; insert( const Object &amp; x); ：插入Object x pair&lt;iterator, bool&gt; insert( iterator hint, const Object &amp; x);：在指定索引hint处插入Object x，比单参数的插入快得多，通常为O(1) erase删除操作 int erase( const Object &amp; x); ：删除x，如果找到的话，返回删除元素的个数，显然只能返回0或者1 iterator erase( iterator itr);：删除有iterator指定的位置的对象 iterator erase( iterator start, iterator end);：删除由两个iterator指定的位置对象中间包含的所有元素，包含前不包含后 find查找操作 iterator find( const Object &amp; x) const;：查找x返回其位置 mapmap用来存储排序后的由键和值组成的项的集合，键必须唯一，但是多个键可以同时对应一个值，即值不需要唯一，键保持逻辑排序后的顺序 map的方法map的方法和set很像，但是其返回值是一个键-值对： pair&lt;KeyType, ValueType&gt;，map支持 begin、end、size、enmty、insert、find、erase、find insert操作必须提供 pair&lt;KeyType, ValueType&gt; 对象 find仅需要一个键，但是返回值的iterator还是指向一个 pair&lt;KeyType, ValueType&gt; 对象，并可以用 first 访问返回的键，使用 second 访问返回的值 map还重载了数组索引的操作符 []： 1ValueType &amp; operator[] ( const KeyType &amp; key ); 如果map中存在key就返回只想相应值的引用，如果不存在key就在map中插入一个默认的值，然后返回指向这个插入的默认值的引用","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://blogs.littlegenius.xin/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"C","permalink":"https://blogs.littlegenius.xin/tags/C/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blogs.littlegenius.xin/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"【C++温故知新】（五）多文件架构与名称空间","slug":"【C-温故知新】五内存模型与名称空间","date":"2019-08-18T03:21:51.000Z","updated":"2019-08-18T03:27:18.194Z","comments":true,"path":"2019/08/18/【C-温故知新】五内存模型与名称空间/","link":"","permalink":"https://blogs.littlegenius.xin/2019/08/18/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E4%BA%94%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4/","excerpt":"","text":"头文件与源文件一般我们将大量公用的代码段存放在头文件中，然后使用其他源文件引用这个头文件，从而使得很多代码段不需要在每个源文件中都书写一遍。一种推荐的策略是这样的，将整个项目/程序包分为三个部分： 头文件（.h）：包含结构体等数据类型的声明，类的框架、函数原型等等抽象而公用的部分 源代码文件（.cpp）：负责头文件中的抽象部分的具体化，如函数的主体、类的实现等 源代码文件（.cpp）：负责调用头文件中的函数以及实例化类模型等从而完成项目逻辑 头文件中不要包含函数的定义或者变量的声明，头文件中一般只包含如下的部分： 函数原型 使用 #define 或 const 定义的符号常量 结构声明 类声明 模板声明 内联函数 头文件通常的书写架构如下，例如我们创建了一个命名为 headFile.h 的头文件： 123456#ifndef HEADFILE_H_#define HEADFILE_H_ // the head file #endif 对头文件与源代码文件编译时是单独编译的，编译器会创建每个源代码文件的目标代码文件，生成 .o 后缀的文件，然后使用连接器将两个部分连接起来，将库代码和启动代码合并，生成一个 .out 后缀的文件，进而生成 .exe 后缀的可执行文件。 多文件编译的过程 名称空间名称空间可以理解为为了区分不同的库类不同的厂商的代码中所包含的同命名的变量、函数等来问题的。例如我的程序包含了两个厂家开发的库，但这两个库中都有一个名为 List 的类，为了区分使用哪个厂家的类，就需要这两个厂家将自己的 List 类封装在自己的名称空间中，从而方便区分。 名称空间的创建我们自己也可以创建名称空间，例如我们声明一个int类型的变量myInt，将其放在我们定义的一个名称空间MHZ中，可以这样写： 1234namespace MHZ&#123;int myInt;&#125; 名称空间的使用如果我想在我的程序中调用名称空间MHZ中的myInt变量，需要使用该名称空间，有以下的一些方式： 12345678910111213141516// 编译使用整个名称空间// 这种方式最不安全// 因为会将整个名称空间的内容全部编译使用// 很容易出现不同名称空间重名的问题using MHZ;cout &lt;&lt; myInt; // 指定编译使用名称空间中的某个变量/函数等// 这种方式相对安全// 使用哪个因素就声明那个因素using MHZ::myInt;cout &lt;&lt; myInt; // 在调用的时候指明名称空间// 这种方式虽然繁琐，但是最不容易出错cout &lt;&lt; MHZ::myInt;","categories":[{"name":"C++","slug":"C","permalink":"https://blogs.littlegenius.xin/categories/C/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"C","permalink":"https://blogs.littlegenius.xin/tags/C/"}]},{"title":"【C++温故知新】（四）函数","slug":"【C-温故知新】四函数","date":"2019-08-12T04:44:00.000Z","updated":"2019-08-18T03:22:11.538Z","comments":true,"path":"2019/08/12/【C-温故知新】四函数/","link":"","permalink":"https://blogs.littlegenius.xin/2019/08/12/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E5%9B%9B%E5%87%BD%E6%95%B0/","excerpt":"","text":"函数基础函数的定义12345typeName functionName(parameterList)&#123;statement;return value;&#125; 函数有多个参数，使用逗号间隔。 函数在执行完第一个 return 语句后结束，如果返回值是void，可以直接使用 return; 或者不写返回语句。 函数原型函数原型描述了函数到编译器的接口，需要写在main函数前边，通常放在头文件引用后。函数原型需要说明函数的返回类型、函数名、函数的参数类型，不需要写变量名，以分号结尾。 函数与一些数据类型数组函数是使用指针来处理数组的。已知C++中将数组名解释为该数组中第一个元素的地址，即 arrayName = &amp;arrayName[0]，在函数中，当将数组作为函数的参数传递时，实际上传递的是数组的第一个元素的地址，即在调用函数时，传入的参数是数组名。 以数组为参数的函数声明： 1int arrayFunction(int arr [], int size); 调用该函数时，只将数组的名字作为参数传入（即传入的是指向数组首元素的指针）即可： 12int myArray[5]=&#123;1,2,3,4,5&#125;;int result = arrayFunction(myArray,5); 所以实际上传入的类型应该是一个int的指针，也就是说函数其实是这样的： 1int arrayFunction(int * arr, int size); 将数组作为参数出入函数 可以看到，我们使用 int arr [] 替换了 int *arr 。既然这两个函数头都是正确的，那么就证明了一个问题：在C++中，当(且仅当）用于函数头或函数原型中，int* arr 和 int arr[] 的含义才是相同的，它们都表示arr是一个int指针。然而，数组表示法（int ar[]）提醒用户，arr不仅指向int，还指向int数组的第一个int值。但是！在其他的上下文中，int*ar 和 int arr[] 的含义并不相同。 数组名与指针对应是一件好事。将数组地址作为参数可以节省复制整个数组所需的时间和内存。如果数组很大，则使用拷贝的系统开销将非常大，程序不仅需要更多的计算机内存，还需要花费时间来复制大块的数据。但是另一方面，使用原始数据增加了破坏数据的风险，所以要尽可能的使用const限定词来保护数组。 使用const来保护数组由于数组名与指针对应，所以数组是按照引用传递的，不是按值传递，因此保护传入的数组不被函数修改破坏非常重要，因此如果函数内部没有修改传入的数组的理由（例如便利打印数组），则最好用const来限定参数，从而起到保护数组的作用。 通常分为如下两种声明方法： void functionModify(int arr[], int size); void functionNoChange(const int arr[], int size); 使用数组区间的函数传统的传递数组到函数中的方式为：传递一个数组名称作为指向第一个元素的指针，再传递一个整数告知函数数组的大小。 还有一种方式是通过传递两个指针来告知函数要处理的元素区间（range），一个指针标识数组的开头，另一个指针标识数组的结尾。例如下边这样： 1234567891011int sumArray(const int * begin, const int * end)&#123;const int * pt;int sum=0;for(pt=begin;pt!=end;pt++)sum+=*pt;return sum&#125; int arrayName[arraySize]=&#123;0,1,2,3,4&#125;;int sum = sumArray(arrayName,arrayName+arraySize); 指针、数组与函数的参数传递我们知道，函数对于传递数组作为参数，根据函数是否有权限改变数组的值，通常有两种声明方式： 12void functionModify(int arr[], int size); // 1号函数void functionNoChange(const int arr[], int size); // 2号函数 此时，如果我们有两个数组： 12cosnt int array1 = &#123;1,2,3&#125;; // 1号数组int array2 = &#123;4,5,6&#125;; // 2号数组 很明显，一个是常量数组，一个是变量数组。两种数组对于两个函数的关系是这样的： 禁止将常量数组的地址赋给非常量指针，即：1号数组不能传递给2号函数，只能传递给1号函数 可以将非常量数组赋给常量或非常量指针，即：2号数组可以被传递给1和2号函数 因此，在设计函数时，要尽可能地使用const，因为将指针参数声明为指向常量数据的指针可以： 避免由于无意间修改数据而导致的编程错误 使用const使得函数能够处理const和非const实参，否则将只能接受非const数据 所以，如果条件允许，则应将指针形参声明为指向const的指针 二维数组编写以二维数组作为参数的方法如下：首先，数组名称被视为其地址，而且数组名可以认为是指向第一层元素的指针（第一层的元素是数组（第二层））。 例如下边的这个数组： 1int data[3][4] = &#123; &#123;1,2,3,4&#125;, &#123;5,6,7,8&#125;, &#123;9,10,11,12&#125;&#125;; 可以这样声明一个函数： 1int sum (int (*arr)[4], int size); 或者这样声明： 1int sum (int arr[][4], int size); 然后这样使用它： 1int result = sum(data,3); 可以看到，传入的参数是数组名，即表示大数组data中第一个元素的引用，而这个元素又是一个4维的数组，所以其实传入的第一个参数是一个指向由4个int组成的数组的指针。而且，第一种声明方式中，必须将 *arr 用括号括起来，否则 int *arr[4] 将表示的是一个由4个指向int的指针组成的数组，然而函数的参数不可能是数组。以上两种声明方式都表明 arr 是指针而不是数组，只是在声明时需要表明它是一个由4个int组成的数组罢了，这也就意味着已经将数组的列数传入函数，所以只需要单独传入一个行数作为参数即可。 在函数中，可以直接将 arr 看成数组名，然后像这样使用它： 1result+=arr[i][j]; 显然，这里存在如下的一个关系： 1arr[i][j] == *(*(arr+i)+j) 实际上，是这样推演过来的： 12345arr // 指向第一行的由4个int组成的数组的指针arr+i // 指向低i行的元素的指针（这个元素是一个4元int数组）*(arr+i) // 第i行的元素，也就是第i行数组，即第i行的指向这个数组第一个元素的指针，等同于 arr[i]*(arr+i)+j // 指向第i行第j个元素的指针，等同于 arr[i]+j*(*arr+i)+j) // 第i行第j列的元素值，等同于 arr[i][j] C风格字符串C风格字符串只一系列字符，以空值结尾的字符串。 作为参数将C风格的字符串作为参数传递给函数，有三种表示字符串的方式： char数组 用引号括起来的字符串常量（字符串字面值） 被设置为字符串的地址的char指针 但其实这三种方式都是传递了一个char指针（char*），由于C风格的字符串与一般的char数组的最主要区别是，C风格字符串自带了结束字符（\\0），所以不需再传入一个数组的长度作为参数。 变量的声明与传入函数： 12345char myChar[6] = \"hello\";char * ch = \"hello\";charFunction(myChar); // myChar 是hello的第一个元素（h）的地址charFunction(ch); // ch是指向char（h）的一个指针charFunction(\"hello\"); // 直接传入字符串的地址 函数原型： 12charFunction(char * str);charFunction(char str[]); 函数中对参数的使用： 12345678charFunction(const char * str)&#123; while(*str) &#123; cout&lt;&lt;*str; str++ &#125;&#125; 作为返回值函数无法直接返回一个字符串，但是可以返回字符串的地址，比如可以这样声明一个返回值为字符串的函数： 12345678char * buildChar(char c, int n)&#123; char * pstr = new char[n+1]; pstr[n]='\\0'; while(n--&gt;0) pstr[n]=c; return pstr;&#125; 结构体传递结构的值当结构体较小时，按值传递结构比较合理，且安置传递可以将结构体看成和int、double等一样的普通单值。 12345678910111213struct myStruct&#123; int myInt; double myDouble;&#125;myStruct sum(myStruct str1, myStruct str2)&#123; myStruct result; result.myInt = str1.myInt + str2.myInt; result.myDouble = str1.myDouble + str2.myDouble; return result;&#125; 传递结构的地址当结构体较大时，传递结构体的地址更为合理，可以节省时间与空间，此时需要将参数由结构体变成指向它的指针，并且访问结构体内的元素时需要使用 -&gt; 代替点： 12345void printStruct(const myStruct * str)&#123; cout&lt;&lt;\"myInt = \"&lt;&lt;str-&gt;myInt; cout&lt;&lt;\"myDouble = \"&lt;&lt;str-&gt;myDouble;&#125; string对象由于string是对象，对象是可以赋值的，所以和结构体类似，可以直接将string的实体按值传递给函数，也可以直接从函数返回，如果需要多个string，可以使用string的数组而不需要一个char的二维数组。 12345void pringStrings(const string str[], int n)&#123; for(int i = 0; i&lt;n; ++i) cout&lt;&lt; i+1 &lt;&lt; \" : \"&lt;&lt; str[i]&lt;&lt;endl;&#125; array对象array对象也是对象，所以依然有两种传递给函数的方式：按值传递和按引用传递（传递地址）： 1234567891011121314void printArray(array&lt;int,3&gt; arr)&#123; for(int i = 0; i&lt;3; i++) &#123; cout&lt;&lt;arr[i]&lt;&lt;endl; &#125;&#125;void printArray(array&lt;int,3&gt; * arr)&#123; for(int i = 0; i&lt;3;i++) &#123; cout&lt;&lt;(*arr)[i]&lt;&lt;endl; &#125;&#125; 递归递归就是函数自己调用自己。在递归的过程中，需要设置终止条件，否则将无限循环下去，例如下边的test为false时将会断开递归。 1234567void recurs(argumentlist)&#123; statements1; if(test) recurs(arguments) statements2;&#125; 递归对于函数的调用是基于栈这种数据结构的，即后进先出，例如三次递归上边的函数，会首先有三次statements1，然后发现终止条件满足后再倒叙执行三次statements2，形成一个栈的后进先出的结果。 函数递归一般会在时间上对于程序有所缩短，但是占用内存的开销却一般较大，因为所以未完成递归的函数都需要存储在内存中，直到整个递归结束才会释放。 函数指针函数也有地址，指向函数的存储地址的数据类型为函数指针，在存储机器语言代码的内存块中，函数指针指向这个函数的内存块的开始地址。利用函数指针，我们可以使用一个函数找到另一个函数，亦或者让函数成为另一个函数的变量。那为什么不直接使用函数调用呢？因为函数调用的代码是写好的，只能调用那一个固定的函数，但是函数指针如果作为一个变量来使用的话，可以传入不同的值，即可以选择使用不同的函数。 获取函数指针函数名（不带参数）即为指向该函数的指针，若将函数作为参数传递，必须传递函数名（函数指针）： 12invoke(myFunction); // 传入的是函数指针，即函数invoke(myFunction()); // 传入的是函数的返回值 声明函数指针声明函数指针时必须指定指针指向的函数类型，即说明函数的返回类型与参数列表，和函数原型的声明方式非常类似。 12int myFunction(double); // 函数原型int (*myFunctionPoint)(double); // myFunction是函数指针 这里将 (*myFunctionPoint) 替换了 myFunction ，从而 myFunction是函数名， myFunctionPoint是函数指针 注意区分如下的两种情况： 12int (*myFunctionPoint)(double); // myFunction是函数指针int * myFunction(double); // 返回一个指向int的指针的函数 在正确的声明函数指针后，要通过赋值使得函数指针指向函数，由于上文提到函数名（不带参数）即是函数的地址，从而赋值的方式就很简单（赋值必须保证返回类型和参数列表均相同）： 1myFunctionPoint = myFunction; // 左侧为函数指针，右侧为函数的地址 使用指针调用函数已知，(*myFunctionPoint)和myFunction扮演的角色相同，所以可以使用任何一种形式来调用这个函数： 123int result = myFunction(1.2); // 使用函数名调用函数int result = (*myFunctionPoint)(5.6); // 使用函数指针调用函数int result = myFunctionPoint(3.7); // 实际上这也是一种可行的方式 函数指针数组函数指针的神奇之处在于它可以保存成数组类型。假设我们有三个返回类型和参数列表均相同但是作用却不同的函数： 123double f1(int);double f2(int);double f3(int); 我们可以使用一个指向这种函数类型的函数指针的数组来存储这三个函数的指针： 1double (*fp[3]) (int) = &#123;f1,f2,f3&#125;; 现在说明一下数组索引3的位置：fp是一个包含三个元素的数组，而要声明这样的数组，首先需要使用fp[3]，该声明的其他部分指出了数组包含的元素是什么样的。运算符[]的优先级高于*，因此fp[3]表明fp是一个包含三个指针的数组。上述声明的其他部分指出了每个指针指向的是什么：参数为int，且返回类型为double的函数。因此，fp是一个包含三个指针的数组，其中每个指针都指向这样的函数，即将int作为参数，并返回一个double。 注意，此处无法使用auto赋值，因为auto只能用于单值初始化，无法用于初始化列表。 接下来使用该数组调用函数： 12double = fp[0](1);double = (*fp[1])(2); 内联函数内联函数与其他函数的区分之处在于编译器对函数的处理方式，常规函数在编译时，函数调用就是函数调用，在调用到该函数时，运行程序会跳转到存储该函数的代码块去执行这个函数，执行结束后再跳转回来继续执行；而内联函数再编译时直接将整个函数编译到调用的地方，即用函数的内容替换函数调用。 内联函数与常规函数 这个性质就决定了，内联函数最好是简单的函数，如果函数过于复杂，不适合被声明为内联函数，因为如果复杂的函数作为了内联函数，那么编译时每一个函数调用都会复制一次整个函数放在调用的位置，是非常耗费空间的。但是对于简单的却调用次数很多的函数，适合声明为内联函数，这样其实相当于将一些多次多处重复的代码单独拎出来写了，但是编译时编译器帮你放了回去。 内联函数的声明方法：在函数生命和定义前都加上关键词 inline，而且通常由于内联函数很简单，会直接写在原型处： 1inline double square(double x) &#123; return x*x; &#125; 引用变量引用变量被定义为一个变量的别名，即引用变量和其指向的变量代表同一个值，指向同一个存储单元，并且引用变量自从赋值起就已知跟着这个变量，不会再发生改变，也就是一个变量两个名字，所以更改其中的任何一个这个变量都会发生改变。 &amp;符号可以指示变量的地址，同时它的另一个含义就是用来声明引用： 12int genius;int &amp; me = genius; 这里的&amp;不是地址运算符，而是类型标识符的一部分，就像int *是int类型的指针一样，int &amp;是指向int的引用。上述声明将me和genius等价，它们指向相同的值和内存单元，就是说me就是genius，而genius就是me。 引用和指针引用和指针貌似很相像，例如： 123int genius = 100;int &amp; me = genius;int * myself = &amp;genius; 这样，神奇的事情来了： 12me == *myself == genius&amp;me == myself == &amp;genius 引用与指针也有区别，例如必须再声明时将引用的值初始化，不能像指针一样，先声明在赋值；而且引用变量一旦赋值将不会再更改，这一点更接近于const指针： 12int &amp; me = genius;int * const myself = &amp;genius; 从而，me == *myself 将引用用作函数参数按值传递与按引用传递 按值传递：函数复制一份传入的值，然后对复制的数据进行操作，与被传入的数据无关 按引用传递：函数直接使用传入的数据，不对其进行拷贝，修改的内容会直接体现在原数据上，这一点可以轻松地使用引用变量完成，抑或通过使用指针传递变量的地址来完成 按值传递与按引用传递 例如，完成一个交换两个变量的值的函数： 按值传递 123456void swapByValue(int a, int b)&#123; int temp = a; a = b; b = temp;&#125; 按引用传递： 123456void swapByReference(int &amp; a, int &amp; b)&#123; int temp = a; a = b; b = temp;&#125; 按地址（指针）传递: 123456void swapByPoint(int * a, int * b)&#123; int temp = *a; *a = *b; *b = temp;&#125; 三种函数的调用方式： 123swapByValue(intA, intB);swapByReference(intA, intB);swapByPoint(&amp;intA, &amp;intB); 可以看出，按指针传递的声明方法和调用方法与其他两种均不同，需要在函数定义时告知传入的变量时 int* 类型，在调用时传入变量的地址 &amp;intA 才可以；按值传递和按引用传递的调用方式相同，直接将变量名传入，只有在定义函数处才可以直到两者的不同，一个是按值传递，一个指出了是按地址传递 &amp; int。 按引用传递的一个重要方面是被传入的值会被直接使用或者修改，例如： 1234567891011int squareByValue(int a)&#123; a *= a; return a;&#125;int squareByReference(int &amp; a)&#123; a *= a; return a;&#125; 调用时会出现： 123int a =2;cout &lt;&lt; squareByValue(a) &lt;&lt; \" = square of \" &lt;&lt; a; // 输出：4 = square of 2cout &lt;&lt; squareByReference(a) &lt;&lt; \" = square of \" &lt;&lt; a; // 输出：4 = square of 4 可见，按照引用传递时，被传入的变量的更改会影响到原始的变量。 将引用用于结构声明一个结构 12345struct myStruct&#123; int myInt; double myDouble;&#125; 将引用用于结构将结构的引用作为参数传递非常简单，同时需要注意的是最好使用引用作为返回值。否则的话，函数需要先将待返回的结构体赋予一个临时变量，然后将这个临时变量返回，这是非常耗费时间和空间的。所以应该像这样使用它们： 123456myStruct &amp; sum(myStruct &amp; target, const myStruct &amp; source)&#123; target.myInt += source.myInt; target.myDouble += source.myDouble; return target;&#125; 调用该函数： 1234myStruct target = &#123;1,2.5&#125;;myStruct source = &#123;2,3.8&#125;;myStruct result;result = sum(target, source); 对返回值使用const如果不对返回值使用const，意味着返回值是可以被赋值的，即下边的表达式成立： 1sum(target, source) = anotherStruct; 未来避免这种情况发生，可以使用const限定返回值： 1const myStruct &amp; sum(myStruct &amp; target, const myStruct &amp; source); 从而如下的语句都不能成立： 12sum(target, source) = anotherStruct;sum(sum(target, source), source); 因为无法将一个有const限定的变量传递给一个没有const限定的变量，但是可以将返回值赋给其他结构： 1result = sum(target, source); 何时使用引用参数使用引用参数的主要原因有两个： 程序员能够修改调用函数中的数据对象 通过传递引用而不是整个数据对象，可以提高程序的运行速度 当数据对象较大时（如结构和类对象），第二个原因最重要。这些也是使用指针参数的原因。这是有道理的，因为引用参数实际上是基于指针的代码的另一个接口。那么，什么时候应使用引用、什么时候应使用指针呢？什么时候应按值传递呢？下面是一些参考原则： 对于使用传递的值而不作修改的函数 如果数据对象很小，如内置数据类型或小型结构，则按值传递 如果数据对象是数组，则使用指针，因为这是唯一的选择，并将指针声明为指向const的指针 如果数据对象是较大的结构，则使用const指针或const引用，以提高程序的效率。这样可以节省复制结构所需的时间和空间。 如果数据对象是类对象，则使用const引用。传递类对象参数的标准方式是按引用传递 对于修改调用函数中数据的函数 如果数据对象是内置数据类型，则使用指针 如果数据对象是数组，则只能使用指针 如果数据对象是结构，则使用引用或指针 如果数据对象是类对象，则使用引用 默认参数默认参数显然就是在调用函数时，如果没有主动传入参数，可以直接使用默认的参数。 默认参数的写法只需在函数原型中的参数后跟上默认值即可： 1int myFunction(const int, double = 1.0); 默认参数的原则如下： 在参数列表中，带有默认参数的参数必须放到所有参数的右边，即从某个参数开始，后边的如果是带有默认参数的就都是带有默认参数的： 12int myFunction(int m, double n = 1.0, char c = 'c'); // 这是可行的int myFunction(int m, doubel n = 1.0, char c); // 这是不行的 调用函数时，可以不传入有默认值的参数，但是所有参数赋值必须从左到右，不能跳过某个参数值，比如上边的第一个函数： 12345int result = myFunction(1); // 传一个参数，1，1.0，'c'int result = myFunction(1, 2.0); // 传两个参数，1，2.0，'c'int result = myFunction(1, 2.0, 'h'); // 传三个参数，1，2.0，'h'int result = myFunction(1, 'h'); // 不允许int result = myFunction(1, , 'h'); // 不允许 函数重载函数重载提供的功能是，定义同名、同返回值，但是参数列表不同的函数，这样在调用时，编译器根据传入参数的类型自行选择使用哪一种函数。 加入我们定义了如下的三个函数： 123void myPrint(int i); // #1void myPrint(double d); // #2void myPrint(string s); // #3 在调用时会根据参数选择使用哪一种： 123myPrint(1); // #1myPrint(2.5); // #2myPrint(\"hello world!\"); // #3 重载的一些原则引用变量是无法作为两种重载函数的，比如有两个函数原型如下： 12double square(double x);double square(double &amp; x); 这样，在调用函数时出入参数： 1double result = square(x); 根本无法确定是使用哪种函数模型，所以在函数重载中，编译器将类型本身和类型的引用看成是一种参数。 在匹配函数时，并不区分const和非const的变量，如以下的函数： 12void function(char c);void function(const char c); 广义上来讲这也是一种重载，但是由于const函数可以处理const变量和非const变量，而非const的函数只能处理非const变量，所以其实并不是严格意义上的重载函数 函数模板函数模板的作用是允许我们使用泛型定义函数，然后根据具体的数据类型替换泛型。通过将类型作为参数传递给模板，可以是编译器生成该类的函数。 比如要交换两个变量的值，这时候我们写好了一个交换两个int值的函数，又需要一个交换两个double值的函数，我们需要将第一个函数重复一遍，然后再将其中的int替换成double，是非常复杂的。尤其是当一些算法可以应用于很多数据类型时，我们无法对每一种数据类型都写一套算法函数，这就时函数模板解决的问题。 模板函数的定义与使用我们可以先定义一个模板，然后用具体的数据类型替换，像下边这样： 12345678template&lt;typename T&gt;;void swap(T &amp;a, T &amp;b)&#123; T temp; temp = a; a = b; b = temp;&#125; 要建立一个模板，必须先使用template语法来定义一个模板变量T，这里也可以用旧的声明方式： 1template&lt;class T&gt;; 很多代码库都使用class开发的，这样的上下文中，两个关键词完全相同，如果不考虑向后兼容并且不介意输入长单词的话，使用typename而不使用class 调用模板函数时，和其他函数类似，编译器会根据我们传入的函数类型自行生成一个对应的函数，这个函数我们是看不到的，但是编译器会直接在背后生成并为我们使用好，例如调用下边的语句时： 123int i = 1;int j = 2;swap(i, j); 这是，编译器会自动生成一个函数：使用int代替所有的T，从而完成相关的逻辑，这个函数我们看不到，但是没问题 1234567void swap(int &amp;a, int &amp;b)&#123; int temp; temp = a; a = b; b = temp;&#125; 模板函数的重载模板函数也是可以重载的，虽然泛型使我们合并解决了很多问题，但是有些数据类型是无法合并的。比如交换变量值的函数，我们可以将上述逻辑同时用于int、double、char、string等，但是却无法用于数组，因为数组需要将每个元素交换，于是可以使用函数模板的重载： 123456789101112131415161718template&lt;typename T&gt;;void swap(T &amp;a, T &amp;b)&#123; T temp; temp = a; a = b; b = temp;&#125;void swap(T []a, T[]b, int n)&#123; T temp; for(int i = 0; i &lt; n; i++) &#123; temp = a[i]; a[i] = b[i]; b[i] = temp; &#125;&#125; 这样就可以用同名函数swap交换任意数据类型和数组类型了。 函数模板的局限性定义模板函数要考虑好这个函数应用的数据类型的范围，有些操作对于数据类型是很有局限性的，比如 a&gt;b 这种操作，只能用于 int、double 等，string和char显然无法使用 显式具体化假如定义了一个结构: 12345struct myStruct&#123; int myInt; double myDouble;&#125; 这时我们同样可以通过上面的swap函数交换两个struct的值，因为结构体是可以直接被赋给另一个结构体的。但是如果我们只想交换两个结构体的myInt变量，而不想交换myDouble变量呢，就无法使用上述模板函数了，但是由于这种情况下我们传入的参数还是和上述模板函数相同的（两个待交换的T），所以重载无法达到这个愿望。这就用到了显式具体化（explicit specialization）。 显示具体化是我们可以提供一个具体化的函数定义，其中包含这个特殊的处理情况下的代码，当编译器找到了与函数调用匹配的具体化定义时，就不再使用模板，而是用该具体化的定义： 对于给定的函数名，可以有非模板函数、模板函数和显式具体化模板函数以及它们的重载函数四个版本 显式具体化的原型和定义以&lt;template&gt;打头，并通过名称来指出类型 非模板函数优先于具体化和常规模板，具体化模板优先于常规模板 例如对于刚才的结构体，下面是用于交换逻辑的非模板函数、模板函数和具体化函数的原型： 123456789// 非模板函数 #1void swap(myStruct &amp;, myStruct &amp;);// 模板函数 #2template&lt;typename T&gt;void swap(T &amp;, T &amp;);// 模板具体化函数 #3template &lt;&gt; void swap&lt;myStruct&gt;(myStruct &amp;, myStruct &amp;); 在上述三个函数原型同时存在时，#1优先于#3优先于#2。在具体化函数模板中，可以省略函数名后的&lt;myStruct&gt;，因为参数类型已经表明了这是一个myStruct的具体化函数： 1template &lt;&gt; void swap(myStruct &amp;, myStruct &amp;); 实例化与具体化当我们定义了一个模板函数swap后，通过调用时传入了两个int值可以使得编译器在后台自动为我们实例化了一个int类型的函数，这个函数是编译中产生的，所以我们看不到，但是它确实是产生了，这个过程成为隐式实例化。 同时我们也可以进行显式实例化（explicit instantiation），即可以直接命令编译器创建特定的实例，比如一个处理int的swap函数，只需要这样声明它： 1template void swap&lt;int&gt;(int, int); 这是要和显示具体化（explicit specialization）区分开的，具体化是在template后还需要加一个&lt;&gt;： 12template &lt; &gt; void swap&lt;int&gt;(int, int);template &lt; &gt; void swap(int, int); 在template后有无&lt;&gt;是区分显示具体化和显示实例化的重要标志。 通常的，隐式实例化、显式实例化和显示具体化都被称为具体化（specialization）","categories":[{"name":"C++","slug":"C","permalink":"https://blogs.littlegenius.xin/categories/C/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"C","permalink":"https://blogs.littlegenius.xin/tags/C/"}]},{"title":"【数据结构】（二）栈与队列","slug":"【数据结构】二栈与队列","date":"2019-08-08T13:13:38.000Z","updated":"2019-08-08T13:20:56.000Z","comments":true,"path":"2019/08/08/【数据结构】二栈与队列/","link":"","permalink":"https://blogs.littlegenius.xin/2019/08/08/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%BA%8C%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/","excerpt":"","text":"栈（stack）栈（stack）是限制插入和删除操作只能在末尾位置上进行的表，该末尾成为栈的顶（top）。是一种后进先出的表（LIFO，Last In First Out）。 栈 栈的实现 链表实现：使用单向链表实现 数组实现：使用数组实现，是更加常用的方式。由C++中的vector中的back、push_back和pop_back可以很简单地实现一个栈。每个栈需要一个用于存储栈数据的数组（stackArray）和一个记录栈顶索引的值（topOfStack）（当空栈时索引为-1） 常用操作 push：入栈操作，将topOfStack+1，然后令stackArray[topOfStack]=newElement; pop：出栈操作，outElement=stackArray[topOfStack]，然后将topOfStack-1 top：返回栈顶元素，返回stackArray[topOfStack] 所有操作均为常数时间O(1)运行 队列（Queue）队列也是表，是一种先进先出（First In First Out，FIFO）的数据结构，入队列的一端成为队尾，出队列的一端成为队头。 队列 队列的实现队列也可以使用链表来实现，但通常使用循环数组来实现。 一个队列需要一个用于存储队列中数据的数组queueArray和两个位置front、back，用于记录队列的两端。为了判定队列是否空还是满，通常还增设一个元素currentSize来记录队列中现有的元素个数。 常用操作 enqueue：入队列 123back = (back+1)%queueArray.size();queueArray[back]=newElement;currentSize++; dequeue：出队列 123outElement = queueArray[front];fornt = (front+1)%queueArray.size();currentSize--; back：返回队尾元素，直接返回queueArray[back] front：返回队头元素，直接返回queueArray[front] 以上操作均以常数时间O(1)运行","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://blogs.littlegenius.xin/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"C","permalink":"https://blogs.littlegenius.xin/tags/C/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blogs.littlegenius.xin/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"【数据结构】（一）表与迭代器","slug":"【数据结构】一表与迭代器","date":"2019-08-08T10:18:26.000Z","updated":"2019-08-27T11:44:33.768Z","comments":true,"path":"2019/08/08/【数据结构】一表与迭代器/","link":"","permalink":"https://blogs.littlegenius.xin/2019/08/08/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%B8%80%E8%A1%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/","excerpt":"","text":"抽象数据类型（abstract data type，ADT）是带有一组操作的一些对象的集合。An abstract data type (ADT) is a set of objects together with a set of operations. 标准模板库（Standard Template Library，SLT）。实现了ADT等数据结构，这些数据结构被称为集合（collection）或者容器（container） 表（List）表的实现方式 静态表：利用数组实现 动态表：利用链表实现 表的常用操作 printList：遍历、打印整个表 makeEmpty：将整个表清空 find：在表中查找某个元素 insert：向表中插入某个元素 remove：从表中移除某个元素 findKth：查找表中的第k个元素 next：返回某个元素的下一个元素 previous：返回某个元素的上一个元素 表的两种简单形式简单链表实现 简单链表 双向链表 双向链表 表的两种重要操作链表的插入 链表的插入 链表的删除 链表的删除 时间复杂度 基本操作 静态 数组实现 动态 链表实现 printList O(n) O(n) makeEmpty O(n) O(1) find O(1) O(i) insert O(n) O(1) remove O(n) O(1) findKth O(1) O(i) next O(1) O(1) previous O(1) O(i) STL中的向量和表表AST的实现方式表ADT有两种流行的实现： vector：给出了表ADT的可增长的数组实现 优点：利于索引（常量时间） 缺点：插入新项或删除已有项代价昂贵（除非操作发生在vector的末尾）；查找效率低 list：提供了表ADT的双向链表实现 优点：如果发生变化的位置已知，插入新项和删除已有项代价很小 缺点：不容易索引；查找效率低 方法 所有STL容器都适用的方法 int size() const：返回容器内的元素个数 void clear()：删除容器中所有的元素 bool empty()：如果容器没有元素，返回 true，否则返回 false vector 和 list 同时支持的方法 void push_back(const Object &amp; x)：在表的末尾添加 x void pop_back( )：删除表的末尾的对象 const Object &amp; back( ) const：返回表的末尾的对象（也提供返回引用的修改函数） const Object &amp; front( ) const：返回表的前端的对象（也提供返回引用的修改函数） vector 单独支持的方法 Object &amp; operator [ ] (int idx)：返回 vector 中 idx 索引位置的对象，不包含边界检测（也提供返回常量引用的访问函数） Object &amp; at (int iax)：返回 vector 中 i 索引位置的对象，包含边界检测（也提供返回常量引用的访问函数） int capacity( ) const：返回 vector 的内部容量 void reserve(int new Capacity)：设定 vector 的新容量。如果已有良好的估计的话，这可以避免对 vector 进行扩展 list 单独支持的方法 void push_front(const Object &amp; x)：在list的前端添加x void pop_front()：在list的前端删除对象 迭代器在STL中，使用迭代器（内置类型 iterator）给出数据在表中的位置。通常可以使用对应的模板来声明 iterator： 1STLType&lt;dataType&gt;::iterator 获得迭代器SLT的所有容器都拥有如下的方法可以获得容器中指向的第一个和终止标志的迭代器： iterator begin()：返回指向容器的第一项的一个适当的迭代器 iterator end()：返回指向容器的终止标志（容器中最后一项的后面的位置）的一个适当的迭代器。（这里比较特殊，是指向的容器的“边界之外”） 两种方法均可以根据所指向的容器类型返回一个恰当的迭代器，所以可以使用 auto 来声明它们，当你不知道应该如何声明的时候： 1auto myIterator = STLCollection.begin(); 迭代器方法迭代器很多方法都来自于运算符的重载 =：赋值 itr++和++itr：推进迭代器itr至下一个位置，前缀和后缀两种形式都允许 *itr：返回存储在迭代器itr指定位置的对象的引用。 itr1==itr2：如果itr1和itr2都指向同一个位置就返回true，否则，返回fa1se itr1!=itr2：如果ix1和itr2都指向不同位置就返回true，否则，返回fase 从而，利用迭代器打印STL容器的方式如下： 123456for(vector&lt;int&gt;::iterator itr=v.begin(); itr != v.end(); ++itr) cout&lt;&lt;*itr&lt;&lt;endl;vector&lt;int&gt;::iterator itr=v.begin();while(itr!=v.end()) cout&lt;&lt;*itr&lt;&lt;endl; 需要迭代器的表方法一些表中常用的需要使用迭代器的容器方法： iterator insert(iterator pos, const Object &amp; x)：添加x到表中迭代器pos所指向的位置之前的位置。对1ist是常量时间操作，对vector则不是。返回值是一个指向插入项位置的迭代器 iterator erase(iterator pos)：删除迭代器所给出位置的对象。对1ist是常量时间操作，对vector不是。返回值是调用之前pos所指向元素的下一个元素的位置。这个操作使pos失效。pos不再有用，因为它所指向的容器变量已经被删除了 iterator erase(iterator start, iterator end)：删除所有的从位置start开始直到位置end(但是不包括end)的所有元素 迭代器的分类 正向迭代器：containerType::iterator itr; 常量正向迭代器（不可更改）：containerType::const_iterator itr; 反向迭代器：containerType::reverse_iterator itr; 常量反向迭代器：containerType::const_reverse_iterator itr; 迭代器的参考：http://www.cplusplus.com/reference/iterator/","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://blogs.littlegenius.xin/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"C","permalink":"https://blogs.littlegenius.xin/tags/C/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blogs.littlegenius.xin/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"【C++温故知新】（三）循环与分支","slug":"【C-温故知新】三循环与分支","date":"2019-08-05T03:28:16.000Z","updated":"2019-08-05T03:47:48.000Z","comments":true,"path":"2019/08/05/【C-温故知新】三循环与分支/","link":"","permalink":"https://blogs.littlegenius.xin/2019/08/05/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E4%B8%89%E5%BE%AA%E7%8E%AF%E4%B8%8E%E5%88%86%E6%94%AF/","excerpt":"","text":"循环for循环1234for(init; condition; increment)&#123; conditional code;&#125; foreach循环12345int myArray[5] = &#123;0,1,2,3,4&#125;;for (const int i : myArray) &#123; cout &lt;&lt; i &lt;&lt; endl;&#125; while循环1234while(condition) &#123; statement(s);&#125; do-while循环123do &#123; statement(s);&#125;while( condition ); 循环控制语句 break continue goto12goto label; label: statement; 分支if和else语句123456if(boolean_expression) &#123;&#125; else &#123; &#125; switch语句123456789101112switch(expression)&#123; case constant-expression : statement(s); break; case constant-expression : statement(s); break; default : statement(s); &#125;","categories":[{"name":"C++","slug":"C","permalink":"https://blogs.littlegenius.xin/categories/C/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"C","permalink":"https://blogs.littlegenius.xin/tags/C/"}]},{"title":"【C++温故知新】（二）指针","slug":"【C-温故知新】二指针","date":"2019-08-05T03:28:06.000Z","updated":"2019-08-06T07:54:04.000Z","comments":true,"path":"2019/08/05/【C-温故知新】二指针/","link":"","permalink":"https://blogs.littlegenius.xin/2019/08/05/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E4%BA%8C%E6%8C%87%E9%92%88/","excerpt":"","text":"指针指针是一个变量，存储的是值的地址 12&amp;Value =&gt; Address/Pointer*Pointer/Address =&gt; Value 例如： 12int myInt = 10; //Valueint *myPoint = &amp;myInt; //Pointer 上边的写法是将 myInt 的地址赋给了指针 myPoint ，前边的 * 可以和 int 一同理解为一个整体，表示一个整型的指针。 指针的声明• int *myPoint;• int * myPoint;• int* myPoint; 动态分配内存 使用new来分配内存1typeName * pointer_name = new typeName; 使用delete释放内存1delete pointer_name; 总结：使用 * 声明指针，指向某值的地址，使用 &amp;Value 获得值的地址，使用 new 会动态分配空间，使用 delete 释放动态分配的空间 指针与数组使用new创建动态数组动态数组表示在运行过程中创建。如果不使用 new 来声明数组，那么数组会在编译的时候就被分配相应的内存，不论是否有值都会占据相应的存储空间，成为静态联编（static binding），类似于使用值存储；使用 new 来声明数组，数组会在程序运行时创建，成为动态联编（dynamic binding），类似于使用链表存储。 动态数组的创建与释放12typeName * pointer_name = new typeName [num_elements];delete [] pointer_name; 动态数组的使用pointer_name 为指向数组第一个值的指针，调用数组第n个元素可以： pointer_name[n]; pointer_name+n; pointer_name[0]; 数组名与指针数组名即为指向该数组第一个元素的指针，即存在： 1arrayName = &amp;arrayName[0] 所以以下两个情况等价： 1234int myInt[3] = &#123;0,1,2&#125;;int* myPoint=myInt; &lt;==&gt; int* myPoint = &amp;myInt[0]myPoint[0] &lt;==&gt; *myPointmyPoint[2] &lt;==&gt; *(myPoint+2) 但是只有指针才可以有运算，数组名不可以有运算，例如在上边的代码中，myPoint+1 是合法的，但是 myInt+1 是不合法的 指针算术将指针加一，等于将指针增加的量指向其类型的字节数。比如一个指向double类型的指针加一，其数值其实增加8，以指到下一个地址去。 还可以将一个指针减去另一个指针，获得两个指针的差。这种运算将得到一个整数，仅当两个指针指向同一个数组(也可以指向超出结尾的一个位置)时，这种运算才有意义；这将得到两个元素的间隔。 指针和字符串在C++的 cout 以及其他多数表达式中，char数组名、char指针以及用引号引起来的字符串常量都被解释为字符串中第一个字符的地址。 由于数组名是数组中第一个元素的指针，所以在字符串数组中，如果直接打印数组名，将会一直打印所有的内容，直到出现\\0才结束，如： 12char myChar[10] = \"hello\";cout &lt;&lt; myChar; 上述代码将打印 hello 123char myChar[10] = \"hello\";char* myPointer = myChar;cout &lt;&lt; myPointer; 上述代码将打印 hello 12char myChar[10] = \"hell\\0o\";cout &lt;&lt; myChar; 上述代码将只打印 hell 指针与结构使用 new 可以创建动态结构，使用指针调用动态结构中的某一项需要使用 -&gt;，（使用结构名来调用某一项使用的是 . ） 123456789struct myStruct&#123; int myInt; double myDouble;&#125;;myStruct * myPointer = new myStruct;myPointer-&gt;myInt = 10;myPointer-&gt;myDouble = 10.2; 存储方式根据用于分配内存的方法,C++管理数据内存的方式可以分为 自动存储、静态存储和动态存储(有时也叫作自由存储空间或堆)。(C++11新增了线程存储) 自动存储：在函数内部定义的常规变量使用自动存储空间，被称为自动变量(automatic variable)，它们在所属的函数被调用时自动产生，在该函数结束时消亡。自动变量是一个局部变量，其作用域为包含它的代码块。代码块是被包含在花括号中的一段代码。自动变量通常存储在栈中，即执行代码块时，其中的变量将依次加入到栈中，而在离开代码块时，将按相反的顺序释放这些变量。 静态存储：静态存储是整个程序执行期间都存在的存储方式。使变量成为静态的方式有两种：一种是在函数外面定义它；另一种是在声明变量时使用关键字 static 定义。 动态存储：使用 new 和 delete 运算符可以提供一种比自动变量和静态变量更灵活的方法。它们管理了一个内存池，这在C++中被称为自由存储空间(free store)或堆(heap)。该内存池同用于静态变量和自动变量的内存是分开的。因此，数据的生命周期不完全受程序或函数的生存时间控制。 指针与const对于将const应用于指针，这个问题是很微妙又复杂的，因为存在两种情况： 将const作用于指针指向的值，使指针指向一个常量对象，这样可以防止使用指针来修改其指向的值，但是指针所指的位置可以随意更改，即可以更换指针指向的变量，但是那个const的变量本身是无法修改的 将const作用于指针本身，这样可以防止改变指针指向的位置，但是该位置所存储的值是可以改变的，即可以通过指针指向的变量修改该地址存储的值 指针指向常规变量12int myInt=10;const int * pt = &amp;myInt; 这里的pt是一个指向 const int（10）的指针，因此无法使用pt来修改这个值，即 *pt 的值为const，不能被修改，如 *pt+=1 是不行的。 但是在这里，myInt本身并不是const的常量，而是对于pt而言，这个值是常量，也就是说无法利用pt来修改myInt的值，但是可以直接修改myInt本身： 12*pt = 20; // 不合法的myInt = 20; // 合法的 但是这种情况下，可以将一个新的地址赋给pt，这就也很微妙，虽然pt无法改变其所指向的地址存储的值，但是可以改变其所指向的地址，比如可以将一个新的地址赋给pt： 12int anotherInt = 30;pt = &amp;anotherInt; 尽管改了新的地址，但是由于pt本身是一个指向常量的指针，所以依然无法改变新的地址存储的值（这里的30） 常规指针指向变量12int myInt=10;int* const pt = &amp;myInt; 当const的位置改变，这种情况下，表示pt指针是一个const的常规指针，它只能指向myInt而不能改变指向的地址，也就是不能再对其赋一个新的值，但是由于myInt本身是一个变量，所以可以通过myInt改变10这个值，也可以通过pt来改变这个值。 12*pt=20； // 合法的pt=&amp;anotherInt; // 不合法的 指向常规对象的常规指针12int myInt = 10;const int* const pt = &amp;myInt; 这是前两种情况的组合，此时pt只能指向myInt，并且pt不能用来修改myInt的值，即 pt 和 *pt 都是const。 常规指针指向常规变量12const int myInt=10;const int* pt = $myInt; 此时既不能使用myInt更改10这个值，也不能使用pt来修改10这个值。 一种不允许的情况12const int myInt = 10;int* pt = &amp;myInt; 这种情况是不允许的，因为如果这个赋值成立，那么const的状态就很奇怪了，myInt本身是常量，却可以使用pt指针来修改，所以这种情况是不合法的 指针、数组与函数的参数传递我们知道，函数对于传递数组作为参数，根据函数是否有权限改变数组的值，通常有两种声明方式： 12void functionModify(int arr[], int size); // 1号函数void functionNoChange(const int arr[], int size); // 2号函数 此时，如果我们有两个数组： 12cosnt int array1 = &#123;1,2,3&#125;; // 1号数组int array2 = &#123;4,5,6&#125;; // 2号数组 很明显，一个是常量数组，一个是变量数组。两种数组对于两个函数的关系是这样的： 禁止将常量数组的地址赋给非常量指针，即：1号数组不能传递给2号函数，只能传递给1号函数 可以将非常量数组赋给常量或非常量指针，即：2号数组可以被传递给1和2号函数 因此，在设计函数时，要尽可能地使用const，因为将指针参数声明为指向常量数据的指针可以： 避免由于无意间修改数据而导致的编程错误 使用const使得函数能够处理const和非const实参，否则将只能接受非const数据 所以，如果条件允许，则应将指针形参声明为指向const的指针","categories":[{"name":"C++","slug":"C","permalink":"https://blogs.littlegenius.xin/categories/C/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"C","permalink":"https://blogs.littlegenius.xin/tags/C/"}]},{"title":"【C++温故知新】（一）数据类型","slug":"【C-温故知新】一数据类型","date":"2019-08-04T09:59:56.000Z","updated":"2019-08-05T03:38:24.000Z","comments":true,"path":"2019/08/04/【C-温故知新】一数据类型/","link":"","permalink":"https://blogs.littlegenius.xin/2019/08/04/%E3%80%90C-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%E3%80%91%E4%B8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"基本的内置数据类型基本数据类型 类型 关键字 布尔型 bool 字符型 char 整型 int 浮点型 float 双浮点型 double 无类型 void 宽字符型 wchar_t 基本的数据类型可以使用如下的四种修饰符修饰： signed unsigned short long 类型别名使用typedef为某种数据类型起一个别名： 1typedef typerName newTypeName 转义序列 字符名称 C++代码 换行符 \\n 水平制表符 \\t 垂直制表符 \\v 退格 \\b 回车/返回行首 \\r 振铃 \\a 反斜杠 \\ 问号 ? 单引号 &#39; 双引号 &#39;‘ 复合数据类型数组数组的声明与初始化方式 int array[3];array[0] = 1;array[1] = 2;array[2] = 3; int array[3] = {1,2,3} int array[5] = {1,2} // 1,2,0,0,0 int array[5] = {0} // 0,0,0,0,0 int array[] = {1,2,3} // size of the array is 3 获取数组长度：sizeof array / sizeof (int) 字符串C风格的字符串使用char数组存储字符串：一种C风格的字符串表达形式，需要使用 &#39;\\0&#39; 做结尾才可以成为一个字符串 char string1[5] = {&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;}; // not a string char string1[6] = {&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;,&#39;\\0&#39;}; // a string char string2[6]=&quot;hello&quot;; // &#39;\\0&#39;可以被编辑器理解到并自行添加到末尾 char string3[] = &quot;hello&quot;; // 编辑器可以自己确定数组的大小（6） 获取一个C风格字符串的长度（不包括末尾的\\0）：strlen(string1) 字符串的输入已知：char hello[20]; cin &gt;&gt; hello：cin使用空白（空格、制表符和换行符）来确定字符串的结束位置，也就是说在cin读取到任何空白的时候都会结束输入，将剩余的部分保留在输入队列（输入流）中等待下一个输入命令来读取，（注意cin会读取掉该空白符，即空白符不再留在输入队列中），所以使用cin只能读取相应大小（比如此处的20）以内并且不含有空白符的字符串 cin.getline(hello,20)：面向行的输入，它使用回车键输入的换行符来确定输入结尾，第二个参数表示其最多读取的字符个数+1后的值，即此处最多读取19个字符，所以这种方法读取指定长度的字符后或者遇到换行符后结束读取。 cin.get()： cin.get(hello,20)：和 cin.getline(hello,20) 效果相同，唯一不同的地方是，cin.get() 会将读取到的换行符保留在输入流中，不是将其读入或者丢弃。此时如果进行下一次 cin.get() 或者是 cin.getline() 都会使得被保留的换行符结束它们，使得他们什么都读不到（除了那个被保留在输入队列队首的换行符）。 cin.get(hello,20); cin.get(); cin.get(hello,20); ：在使用完一次 cin.get(arrayName,arraySize) 后再次使用 cin.get() 将那个换行符读进来可以解决这个问题。 cin.get(hello,20).get()：上一种方法的简写 (cin &gt;&gt; something).get()：在cin后追加get()的简写 同理，cin,getline(hello,20).getline(hello,20)：连续使用 cin.getline() 读取两次的简写模式 string类使用 string 类前必须包含 string 头文件：#include&lt;string&gt; string的声明与初始化 string myString; string myString = &quot;hello world!&quot;; string mystring = {&quot;hello world!&quot;}; string myString1 = &quot;hello world!&quot;;string myString2 = myString1; string的赋值、拼接与附加 string myString1 = &quot;hello world!&quot;;string myString2 = myString1; string myString3; myString3 = myString1 + myString2; myString1 += myString2; string类输入1getline(cin,stringName) 结构体（struct）结构体的定义12345struct structType&#123; dataType dateName1; dataType dataName2;&#125;; 结构体的声明与初始化 structType structName1; structType structName1 = {data1,data2}; structType structName2 = structName1; structName1.dataName1 = data1; 在定义完结构体后直接声明一个结构体：12345678struct structType&#123; dataType dateName1; dataType dataName2;&#125;structName=&#123; data1, data2&#125;; 只声明一个结构，可以不提前定义结构体：12345struct&#123; dataType dateName1; dataType dataName2;&#125;structName; 结构体数组假设已经定义了结构体结构： 12345struct structType&#123; dataType dateName1; dataType dataName2;&#125;; 初始化一个结构体数组： 先声明再逐个初始化12structType structArrayName[2];structArrayName[0]=&#123;data1,data2&#125;; 声明的同时初始化12345structArrayName[2]=&#123; &#123;data1,data2&#125;, &#123;data1,data2&#125;&#125;; 共用体（union）共用体和结构体类似，但是不同点在于结构体可以同时存储多种数据结构，但是共用体只能在同一时间存储一种数据结构： 123456789union myUnion&#123; int myInt; double myDouble;&#125;;myUnion union1;union1.myInt = 1; // 此时union1存储的是整数1union1.myDouble = 1.1; // 此时union1存储的是双精度的浮点数1.1 枚举（enum）枚举的声明123enum colors &#123;red,blue,green,yellow&#125;; // red=0, blue=1, green=2, yellow=3colors myColor = red; // myColor = 0colors myColor = colors(2) // myColor = green = 2 即枚举变量只能付给已经定义的几个值中的一个，不能赋予其他值 枚举的值 可以在每一个枚举变量后为其赋值，如果没有赋值的话该枚举值是前一个值+112enum numbers &#123;one=1, two=2, four=4, eight=8&#125;enum numbers &#123;one=1, two=2, four=4, five, eight=8&#125; // five = 5 枚举的值实际上定义了一个范围，比如 enum numbers {one=1, two=2, four=4, eight=8} 中，如下的语句是合法的：1numbers myNumber = numbers(6); 虽然6没有被定义，但是却在定义的枚举值的范围内，是合法的。 枚举值的范围的计算方式： 计算上限：找到定义的枚举值的最大值（比如100）；找到比这个最大值大的最小的一个2的幂（比如比100大的最小的是2的7次幂128）；将这个2的幂数减一（127）即为上限 计算下限： 如果已经定义的枚举值的最小值比0大或等于0，则下限是0 如果已经定义的枚举值的最小值比0小，则和计算上限的方式类似：先找到比这个定义的最小值（比如-6）小的，最大的2的次幂（-8）；将这个次幂数加一（-7）即为下限 vector模板类使用vector模板类需要引入头文件：#include&lt;vector&gt;vector可以存储n个（n可以为变量）该类型的数据： 12vector&lt;dataType&gt; vt(dataSize); // dataSize大小的dataType数据类型的对象vector&lt;int&gt; vi; // 0大小的整型数组 优点：可以动态改变长度 缺点：效率比数组稍低 array模板类使用array模板类需要引入头文件：#include&lt;array&gt;array模板类可以存储固定长度的某种数据类型的一个数组： 123array&lt;dataType, arraySize&gt; arrayName;array&lt;int,5&gt; arrayInt; // 创建一个5个int值的数组对象array&lt;double,3&gt; arrayDouble = &#123;1.1,1.2,1.3&#125;; // 创建并初始化了一个3个double值的数组对象 有点：效率较快 缺点：只能声明固定长度的数组 二维数组1234567891011121314dataType arrayName [row] [column]=&#123; &#123;datas&#125;, &#123;datas&#125;&#125;;dataType arrayName [row] [column];for(int i = 0; i &lt; row; i++)&#123; for(int j = 0; j &lt; column; j++) &#123; arrayName[i][j]=data; &#125;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://blogs.littlegenius.xin/categories/C/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"C","permalink":"https://blogs.littlegenius.xin/tags/C/"}]},{"title":"Unity3D基础脚本编程","slug":"Unity3D基础脚本编程","date":"2019-08-03T11:35:44.000Z","updated":"2019-08-03T12:15:10.000Z","comments":true,"path":"2019/08/03/Unity3D基础脚本编程/","link":"","permalink":"https://blogs.littlegenius.xin/2019/08/03/Unity3D%E5%9F%BA%E7%A1%80%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/","excerpt":"","text":"Unity3D脚本编程笔记–基础的脚本知识从脚本开始将脚本添加给GameObject有三种方法可以将脚本添加给一个GameObject让其成为它的Component。 将创建的脚本文件直接拖动给目标GameObject 将脚本文件拖动到该GameObject的Inspector面板中 在该GameObject的Inspector面板中最下方选择Add Component然后创建一个新的脚本，直接添加给该GameObject 访问限定词 public 修饰的变量在Inspector面板中可见并且可以直接进行调整 private 修饰的变量只能在脚本程序中使用，在Inspector面板中不可见 public 修饰的变量或者方法，在其他类中使用该类的实例，可以访问该类下的这些变量与方法 private 修饰的变量只能在本类中使用和调用，不能被其实例访问 几个周期函数 Awake() 在脚本被初始化的时候调用，尽管该脚本可能已经被禁用 在整个脚本的生命周期中只调用一次 Start() 在脚本第一次要Update之前，必须是在该脚本是enable的情况下 在整个脚本的生命周期中只调用一次 Update() 在每一帧出现时调用 每次更新的时间间隔不同 一般用于： 移动非物理化物体的时候 简单的定时器 接收到输入的时候 FixedUpdate() 每次物理操作之后调用 两次更新时间间隔一致 一般用于： 调整物理物体（Rigidbody，刚体） Unity3D中的向量向量运算 二维向量 Vector2 向量的模：magnitude 向量的分量：x y 判定向量相等：Equals 向量单位化：Normalize 向量转化成字符串：ToString 完整Vector2参考：https://docs.unity3d.com/ScriptReference/Vector2.html?_ga=2.148748272.693619093.1552224779-1809290818.1551791741 三维向量 Vector3 向量的模：magnitude 计算向量的模的平方，单纯为了比较大小，比计算模速度快：sqrMagnitude 判定向量相等：Equals 向量转化成字符串：ToString 向量的内积（点乘）运算：Dot Vector3.Dot(VectorA, VectorB) 向量的外积（叉乘）运算：Cross Vector3.Cross(VectorA, VectorB) 向量的外积（叉乘） GameObject与Component获取Component 获取同GameObject下的Component ComponentType componentName = GetComponent&lt;ComponentType&gt;(); 获取其他GameObject下的Compnent 先声明一个public变量，然后将其他GameObject的相应的Component拖动到该变量处赋值 先找到该GameObject再获取Component12GameObject gameObjectName = GameObject.Find(\" \");ComponentType componentName = gameObjectName.GetComponent&lt;ComponentType&gt;(); 控制Component是否可用123// if componentName is a component got alreadycomponentName.enabled=false; //disable the componentcomponentName.enabled=true; //enable the component 获取GameObject 获取脚本所属GameObject：直接使用 gameObject 获取其他/一般的GameObject 声明一个public变量，将目标GameObject拖到该参数处为其赋值 使用Find方法 GameObject gameObjectName = GameObject.Find(&quot; &quot;); 使用FindGameObjectsWithTag或者FindWithTag获取：为GameObject添加Tag可以在Instector面板中完成 为GameObject添加Tag 12ComponentType componentName = GameObject.FindGameObjectsWithTag(\"tag\");ComponentType componentName = GameObject.FindWithTag(\"tag\"); 控制GameObject是否可用123// if gameObjectName is a GameObject got alreadygameObjectName.SetActive(false); //disable the GameObjectgameObjectName.SetActive(true); //enable the GameObject 判断GameObject是否可用// if gameObjectName is a GameObject got already 语法 作用 gameObjectName.activeSelf 判断其本身是否active，其父物体为disable，但是其本身可能还是active gameObjectName.activeInHierarchy 判断其所在分级是否active，即其父物体是否active 获取Transform 获取脚本所在GameObject的Transform：直接使用 transform 获取其他GameObject的Transform：先使用上述方法得到GameObject，然后使用 gameObjectName.transform 移动（Translate）和旋转（Rotate） Translate：Transform的方法，以一个Vector3为参数，按照Vector3所描述的方向与大小移动 Rotate：Transform的方法，以一个Vector3为参数，按照Vector3所描述的方向与大小旋转 LookAt：摄像机跟踪目标：Transform.LookAt()：以一个transform为参数，使得摄像机的transform跟随参数的transform变动，即实现跟踪 销毁（Destroy）12Destory(GameObject/Component);Destory(GameObject/Component,DelaySecond); 获取输入获取按键输入 ButtonInput：获取键钮，在 Edit -&gt; Project Settings -&gt; Input 中可以看到各种预设好的按键，读取这些键钮的名称作为GetButton的参数 123Input.GetButtonDown(\"name\"); // 键钮按下时的一帧为trueInput.GetButton(\"name\"); // 键钮按下时保持为trueInput.GetButtonUp(\"name\"); // 键钮按下然后释放后的状态下保持为true KeyInput：获取键钮123Input.GetKeyDown(KeyCode.name); // 键钮按下时的一帧为trueInput.GetKey(KeyCode.name\"); // 键钮按下时保持为trueInput.GetKeyUp(KeyCode.name\"); // 键钮按下然后释放后的状态下保持为true KeyCode完整参考：https://docs.unity3d.com/ScriptReference/KeyCode.html 获取水平/竖直轴向输入使用以下函数均可传入一个参数的两个值：“horizontal”、“vertical”来分别表示水平和竖直方向的运动 12Input.GetAxisRaw() //在参数设置的方向上返回 -1 或 1 两个值中的一个，即即止即停Input.GetAxis() //在参数设置的方向上返回一个 -1 到 1 之间的float值，即有一定的缓冲变动的效果 获取鼠标输入 OnMouseDown()：当鼠标点击GUIElement或者Collider时触发 OnMouseDrag()：当鼠标点击GUIElement或者Collider并仍然按住时触发 OnMouseEnter()：当鼠标进入GUIElement或者Collider时触发 OnMouseExit()：当鼠标离开GUIElement或者Collider时触发 OnMouseOver()：只要鼠标在GUIElement或者Collider上时的每一帧都会触发 OnMouseUp()：当鼠标被释放时触发 OnMouseUpAsButton()：当鼠标在点击了GUIElement或者Collider后并且释放时触发 DeltaTimeDeltaTime是指的每两个 Update() 函数或者 FixedUpdate() 函数调用之间的时间间隔，使用 Time.deltaTime 获得 数据类型 数据类型 类（Classes） 脚本名称和类名需要相同 详细情况与C#类一致 实例化预设体（Instantiate Prefab）使用 Instantiate 来创建某个预设体（Prefab）的复制品（Clones）：首先使用public变量来获取目标Prefab：public PrefabType prefabName Instantiate(prefabName)：从prefabName的预设体创建一个克隆体生成在坐标原点处 Instantiate(prefabName,Position,Rotation)：规定预设体的位置与角度 Type reference：reference = Instantiate(prefabName,Position,Rotation) as Type;：将预设体生成在指定位置与角度并且进行类型转换成Type类型 Instantiate完整参考：https://docs.unity3d.com/ScriptReference/Object.Instantiate.html?_ga=2.116872129.693619093.1552224779-1809290818.1551791741 数组（Arrays）在Unity的脚本中声明一个 public 类型的数组变量，不需要传入具体的大小，这样的数组可以在Inspector处直接更改数组大小，并且随着数组大小的改变还会自动为你添加每一个数组的参数值。然后使用 foreach 循环或者 for 循环可以很方便的遍历整个数组。 12345678910111213141516public GameObject[] gameObjects;void Start()&#123; Debug.Log(\"Using For\"); for(int i = 0; i &lt; gameObjects.Length; i++) &#123; Debug.Log(gameObjects[i].name); &#125; Debug.Log(\"Using Foreach\"); foreach(GameObject items in gameObjects) &#123; Debug.Log(items.name); &#125;&#125; 使用public的数组赋值 其他调用（Invoke）Invoke()函数可以在一定时间后以及每一定时间间隔内调用某个方法，要求该方法必须是 0个参数，void返回值的函数。 比如我们有一个函数 LogHello： 1234void LogHello()&#123; Debug.Log(\"Hello World!\");&#125; 使用 Invoke 来调用该方法： Invoke(&quot;LogHello&quot;, delayTime)：第一个参数为要调用的方法的名称（字符串），第二个参数为要推迟多少时间调用该方法（单位：s） InvokeRepeating(&quot;LogHello&quot;, delayTime, gapTime)：前两个参数同上，第三个参数规定在第一次调用后每隔多长时间调用一次（单位：s） CancelInvoke(&quot;LogHello&quot;)：传入要停止Invoke的方法名称（字符串） 线性插值（Linear Interplotation）线性插值是在两个给定值之间找到一个百分比的值。比如在3和5之间找到一个50%处的值，即f4 Mathf.Lerp：三个float类型参数，前两个规定起止值，最后一个规定百分比，返回一个float类型的值 float result = Mathf.Lerp (3f, 5f, 0.5f); // result = 4 Color.Lerp：返回两个颜色值的百分比处的插值结果 Vector3.Lerp：返回两个三维向量的百分比处的插值结果 123Vector3 from = new Vector3 (1f, 2f, 3f);`Vector3 to = new Vector3 (5f, 6f, 7f);Vector3 result = Vector3.Lerp (from, to, 0.75f); // result = (4, 5, 6)","categories":[{"name":"Unity3D","slug":"Unity3D","permalink":"https://blogs.littlegenius.xin/categories/Unity3D/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Unity3D","slug":"Unity3D","permalink":"https://blogs.littlegenius.xin/tags/Unity3D/"}]},{"title":"【WEB JS PHP】屏幕截图粘贴上传+文字识别+一键复制识别结果","slug":"【推送】屏幕截图一键粘贴-识别图中的文字-一键复制识别结果","date":"2019-04-23T07:22:17.000Z","updated":"2019-08-05T03:47:52.000Z","comments":true,"path":"2019/04/23/【推送】屏幕截图一键粘贴-识别图中的文字-一键复制识别结果/","link":"","permalink":"https://blogs.littlegenius.xin/2019/04/23/%E3%80%90%E6%8E%A8%E9%80%81%E3%80%91%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%E4%B8%80%E9%94%AE%E7%B2%98%E8%B4%B4-%E8%AF%86%E5%88%AB%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%96%87%E5%AD%97-%E4%B8%80%E9%94%AE%E5%A4%8D%E5%88%B6%E8%AF%86%E5%88%AB%E7%BB%93%E6%9E%9C/","excerpt":"","text":"今天为大家带来一款我自己写的小应用，由于最近在学习网课，而个人又是OneNote笔记爱好者，不做笔记就觉得课程学习不完整，但是懒就懒在实在不想打字啊，所以想到了直接截图用文字识别嘛，于是经过几个小时的鼓捣，这个小应用就诞生了！本着好东西要分享的原则，特意把代码贴出来并且非常欢迎大家使用我写的这个小工具~ 功能介绍当我们使用QQ、Tim、微信或者电脑自身的截图功能获取了截图后，不需要将图片保存成文件，只需在页面中的输入框中直接使用Ctrl+V或者右键粘贴就能得到剪贴板中的图片了。同时，我们会将你粘贴的图片上传到后台，调用百度AI的OCR（文字识别）接口，将图片中的文字识别并提取出来，将识别结果显示到页面上。最后，你可是一手动修改你认为识别不正确的地方，然后点击下边的按钮一键复制所有的识别结果，粘贴到你想要粘贴的任何部分！ 截取并识别视频中的文字 截取并识别不可复制的文字内容 截取并识别图片中的文字 基本原理与流程 使用OCR接口前，需要先请求access_token，为了避免重复请求，将其保存在session中 使用JavaScript检测粘贴事件，并使用Clipboard技术获取剪贴板中的图片的Base64编码 显然，获取到的Base64编码是可以用来在页面中显示图片的 使用AJAX技术将Base64编码传送到后台 后台获取得到图片的Base64，进行预处理，包括去掉头部信息、将AJAX传送过程中自动转换的‘+’符号从空格转换回来等 将格式化好的图片的Base64编码请求百度的OCR接口返回文字识别结果 将多个零散的是被内容拼合成一个完整的字符串并返回给前端，显示在页面上 完成一键复制功能 实例与使用本仓库中的代码省略了所有的样式，只保留了最简单的代码内容，一个比较好的可以运行的实例请参考笔者的个人项目。 也欢迎你收藏笔者的网站，随意使用，希望在一些情况下可以帮到你！ 笔者个人的项目实例 本项目申请使用了百度OCR接口中的“通用文字识别”接口，对于准确率来讲，个人使用基本满意，可以识别中英文和文字不是正向的图片（即文字方向旋转也生效），不能识别手写文字，每日识别次数上线为50000次。 如果你有任何提议或问题，欢迎使用邮件和我联系：&#109;&#104;&#x7a;&#50;&#x31;&#x38;&#48;&#53;&#55;&#50;&#53;&#x30;&#x39;&#64;&#x31;&#54;&#51;&#46;&#x63;&#x6f;&#x6d; 代码实现具体的完整的代码实现就在这里啦：https://github.com/mhz2180572509/PasteImagetoOCR","categories":[{"name":"推送","slug":"推送","permalink":"https://blogs.littlegenius.xin/categories/%E6%8E%A8%E9%80%81/"}],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://blogs.littlegenius.xin/tags/WEB/"},{"name":"文字识别","slug":"文字识别","permalink":"https://blogs.littlegenius.xin/tags/%E6%96%87%E5%AD%97%E8%AF%86%E5%88%AB/"},{"name":"项目应用","slug":"项目应用","permalink":"https://blogs.littlegenius.xin/tags/%E9%A1%B9%E7%9B%AE%E5%BA%94%E7%94%A8/"}]},{"title":"Ubuntu18.04 服务器部署与安装 Apache，PHP 7.2和MySQL","slug":"Ubuntu18.04 服务器部署与安装 Apache，PHP 7.2和MySQL","date":"2019-03-07T07:40:50.000Z","updated":"2019-03-07T13:10:06.000Z","comments":true,"path":"2019/03/07/Ubuntu18.04 服务器部署与安装 Apache，PHP 7.2和MySQL/","link":"","permalink":"https://blogs.littlegenius.xin/2019/03/07/Ubuntu18.04%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%AE%89%E8%A3%85%20Apache%EF%BC%8CPHP%207.2%E5%92%8CMySQL/","excerpt":"","text":"简单说明本教程针对于在Linux系统的服务器上安装部署服务器环境，如果你恰好有一台服务器（无论是实体服务器还是购买的云服务器），并且使用的是Linux系统，那么你就可以参考本文来安装Apache（Web服务器）、PHP7.2、数据库（MySQL/MariaDB），并且进行一些有必要的配置，比如对PHP的加速、安装phpMyAdmin以及获取SSL证书使用https协议等。从而，这几种应用程序的经典组合Linux、Apache、MySQL、PHP即统称为LAMP 链接服务器如果你在服务器本机上操作，直接打开服务器命令行终端即可。 如果你是购买的云服务器或者使用其他电脑远程连接控制该服务器，那么你首先要做的就是链接到你得服务器。 Windows系统Windows系统不能直接链接Linux系统，需要使用一些辅助工具，这里推荐使用Putty。 下载地址：https://www.putty.org/ 下载完成后直接安装，然后打开，可以进入登录页面，填写你的服务器IP地址，端口号选择22，连接方式选择SSH，然后链接即可，这里本人使用的云服务器的IP地址为39.106.23.80，全篇都采用次地址。 进入之后输入用户名，一般是初始值root，然后输入登录密码，密码在输入过程中不会显示任何东西，这是Linux对密码的保护机制，不必惊讶，保证不输错就行。 一切顺利的话会进入Linux系统，当显示 ~# 时则表示可以输入命令了。 Linux系统Linux系统下可以直接链接Linux服务器，在命令行终端下，输入命令 ssh root@39.106.23.80 然后输入服务器的密码即可连接成功，同样出现 ~# 的符号 安装MySQL或MariaDB数据库目前有两种广泛使用的MySQL数据库系统可供选择，这是由Oracle开发的经典“MySQL”服务器，现在可以在5.7版本中获得，而MySQL分支名为MariaDB，由原始MySQL开发人员Monty Widenius开发。这两种数据库只需要也只能安装一种，也就是说如下的两个小节“安装MySQL 5.7”和“安装MariaDB 10”只需要参考其一完成即可。 安装MySQL 5.7使用命令 1apt-get -y install mysql-server mysql-client 整个过程中你可能会被要求填写密码、设置一些东西，按照步骤要求填写即可，第一步是设置数据库密码，然后剩下的可以一路选择 y 表示 yes就行，直到最后会出现 Success. All done! 表示安装成功。 安装MariaDB 10使用命令 1apt-get -y install mariadb-server mariadb-client 然后为MariaDB设置密码 1mysql_secure_installation 整个过程大概这样： 最后出现 Thanks for using MairaDB 即表示成功。 测试MySQL/MariaDB root登录使用命令 1mysql -u root -p 输入刚刚设置的密码，看是否登录到数据库中。 如果是MySQL数据库，会变成使用 mysql&gt; 开头的符号等待命名输入，如果是MairaDB数据库则会使用 MariaDB&gt; 开头的符号等待命令输入，使用命令 quit 即可退出数据库，下图是MariaDB的图示。 安装Apache使用命令 1apt-get -y install apache2 安装完毕后在浏览器中输入你的IP地址访问服务器，如果看到如下页面则表示Apache安装成功。 Ubuntu默认服务器的文档根目录是 /var/www/html ，主配置文件是 /etc/apache2/apache2.conf 配置系统的说明完整记录在 /usr/share/doc/apache2/README.Debian.gz 中 安装PHP 7.2部署PHP语言环境使用命令 1apt-get -y install php7.2 libapache2-mod-php7.2 然后重新启动Apache 1systemctl restart apache2 测试PHP并获取PHP安装信息在默认网站文档的根目录也就是 /var/www/html 下创建一个小小的php文件，并使用浏览器访问该文件来检测服务器和PHP语言环境是否正常运行。 使用vim编辑器新建并编辑一个php文件： 1vim &#x2F;var&#x2F;www&#x2F;html&#x2F;info.php 就会进入vim编辑器，如果你不会使用vim编辑器，请按照如下步骤进行：在输入上一条命令后在编辑器中按 I 键进入编辑模式，输入如下代码 12&lt;?phpphpinfo(); 然后按 Esc 键退出编辑模式，然后英文状态下输入 : ，会发现左下角出现了一个冒号，输入的光标指向了此处，此时输入 wq 然后按回车，即可返回命令行，同时文件创建编辑完毕。 回到命令行后，使用命令 1chown www-data:www-data &#x2F;var&#x2F;www&#x2F;html&#x2F;info.php 将 info.php 文件的所有者更改为www-data用户和组 然后在我们的浏览器中使用IP访问我们的服务器并在后面加入 /info.php 来访问刚刚写的php文件，如果出现如下内容即表示PHP和Apache正确运行。 链接PHP与MySQL/MariaDB数据库使用命令 1apt-cache search php7.2 和 1apt-cache search php- 注意：因为并非所有PHP软件包的名称中都有版本号7.2，可以选择你需要的，并像这样安装它们： 1apt-get -y install php7.2-mysql php7.2-curl php7.2-gd php7.2-intl php-pear php-imagick php7.2-imap php-memcache php7.2-pspell php7.2-recode php7.2-sqlite3 php7.2-tidy php7.2-xmlrpc php7.2-xsl php7.2-mbstring php-gettext 重启Apache 1systemctl restart apache2 刷新刚刚的 info.php 页面然后在下方看到数据库的信息后表示成功！ 安装Opcache + APCu PHP缓存来加速PHPPHP 7附带了一个内置的操作码缓存器，用于缓存和优化PHP中间代码，名称为“opcache”，可在包php7.0-opcache中找到。 强烈建议安装Opcache以加快PHP页面的速度。 除了opcache之外，我还将安装APCu，它是opcache的兼容性包装，提供APC缓存的功能，这是PHP 5.x版本中经常使用的缓存系统，许多CMS系统仍然使用它。 使用命令： 1apt-get install php7.2-opcache php-apcu 如果提示已经安装是正常的事情，然后重启Apache 1systemctl restart apache2 再次刷新 info.php 页面，如果找到下方的相关模块则表示安装成功 完成了刚才的测试后，可以及时删除杠杆创建的 info.php 文件，这个文件中包含了许多关键的信息，不希望被他人看到。 1rm -f &#x2F;var&#x2F;www&#x2F;html&#x2F;info.php 设置https协议在Apache中启用SSL网站SSL/TLS是一个安全层，用于加密网络浏览器和服务器之间的连接。也就是目前支持的https协议。我们可以在服务器上使用如下命令启用SSL支持： 12a2enmod ssla2ensite default-ssl 它启用SSL模块并在 /etc/apache2/sites-enabled 文件夹中添加一个符号链接到文件 /etc/apache2/sites-available/default-ssl.conf，用于将其包含到活动的apache配置中。 然后重启Apache： 1systemctl restart apache2 此时在浏览器中使用https协议访问你得IP地址，如我的是：https://39.106.23.80/ ，会出现如下的提示： 此时可以选择忽略警告继续浏览，可以进入我们原本的网站 为了避免出现类似的不安全警告，我们需要获取SSL证书 从Let’s Encrypt获取免费的SSL证书首先安装python3-certbot-apache包： 1apt-get -y install python3-certbot-apache 使用编辑器打开vhost文件 1vim &#x2F;etc&#x2F;apache2&#x2F;sites-available&#x2F;000-default.conf 并在“DocumentRoot”下面添加一行：记得将如下的域名替换成自己的域名 1ServerName www.littlegeniux.xin 保存后回到命令行，使用命令： 1certbot --apache -d www.littlegeniux.xin 然后需要输入一个邮箱地址 然后会经历一些步骤： 表示SSL证书配置成功： 此时通过 https://www.littlegenius.xin 或者 https://39.106.23.80 访问网站就不再有安全警告出现了。 设置加密自动更新由于SSL证书只在80天中有效，所以我们运行命令 1certbot --renew 来设置其自动更新 安装phpMyAdminphpMyAdmin是一个图形化管理数据库的工具，简单说是一个Web页面，你可以在其中可视化地管理你得数据库。 配置phpMyAdmin使用命令： 1apt-get -y install phpmyadmin 整个过程中会经历很多的设置，注意：这种设置是使用键盘的方向键进行选择，当移动到你想选中的位置后一定要按空格键才能将其选中，只移动方向键使它高亮并不是选中，一定要按空格键将其选中！选中后会有一个*号的标识。 之后会有一系列的内容要选择 对phpMyAdmin创建root权限在命令行中使用命令登录到数据库 1mysql -u root 使用如下代码创建一个名为“admin”密码为“123456”的新用户，根据自己的需求更改下方的账户和密码成为你的，注意命令尾部的分号。 1234CREATE USER &#39;admin&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;GRANT ALL PRIVILEGES ON *.* TO &#39;admin&#39;@&#39;localhost&#39; WITH GRANT OPTION;FLUSH PRIVILEGES;exit 配置上述内容后就可以在浏览器中使用 http://39.106.23.80/phpmyadmin/ 访问phpMyAdmin啦： 输入账号密码即可在phpMyAdmin中管理你得数据库！ 本地与服务器之间的文件传输服务器的搭建和配置任务全部完成了，最后你可能还需要知道如何实现本机与服务器之间的文件传输。 Linux系统如果你本机使Linux系统，很简单，使用命令行终端就可以完成：将本地文件 /home/test.txt 传输到服务器的 /var/www/html 目录下： 1scp &#x2F;home&#x2F;test.txt root@39.106.23.80:&#x2F;var&#x2F;www&#x2F;html 将服务器的 /var/www/html/test.txt 文件传输到本地的 /home 目录下： 1scp root@39.106.23.80:&#x2F;var&#x2F;www&#x2F;html&#x2F;test.txt &#x2F;home 将本地文件 /home 整个目录传输到服务器的 /var/www/html 目录下： 1scp &#x2F;home root@39.106.23.80:&#x2F;var&#x2F;www&#x2F;html 将服务器的 /var/www/html 整个目录传输到本地的 /home 目录下： 1scp root@39.106.23.80:&#x2F;var&#x2F;www&#x2F;html &#x2F;home Windows系统如果你是用Windows系统，那么你可以使用WinScp工具来完成这个过程. 下载地址：https://winscp.net/eng/index.php 下载好后安装，然后和putty的界面和操作类似，输入IP地址，端口号设置为22，然后输入用户名与密码 如果经常使用可以选择保存将这个IP保存，下次就不需要再输入一次了 连接建立后就会出现如下的界面，很简单，左边是你的Windows目录，右边就是你的服务器目录，需要进行文件传递只需要将文件或者文件夹从左侧拖动到右侧或者从右侧拖动回左侧即可。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blogs.littlegenius.xin/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blogs.littlegenius.xin/tags/Linux/"},{"name":"技术指南","slug":"技术指南","permalink":"https://blogs.littlegenius.xin/tags/%E6%8A%80%E6%9C%AF%E6%8C%87%E5%8D%97/"},{"name":"服务器","slug":"服务器","permalink":"https://blogs.littlegenius.xin/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"安装好Ubuntu双系统后的一些事情","slug":"安装好Ubuntu双系统后的一些事情","date":"2019-02-20T04:44:01.000Z","updated":"2019-02-20T05:15:42.000Z","comments":true,"path":"2019/02/20/安装好Ubuntu双系统后的一些事情/","link":"","permalink":"https://blogs.littlegenius.xin/2019/02/20/%E5%AE%89%E8%A3%85%E5%A5%BDUbuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B%E6%83%85/","excerpt":"","text":"创建root管理权限root管理权限即Linux系统的超级管理权限，他几乎可以做所有操作，新的Linux系统是需要设置root权限的，必须先设置root密码，这个密码可以和你登陆系统的密码不同。 打开命令行后输入：sudo passwd 然后会提示创建新的密码，输入过程中不会显示（Ubuntu之于密码都是这么处理的），然后会第二次输入确认密码，之后回车就可以创建了。这时候输入命令：su，即可进入超级管理权限哦（你可能会注意到，超级管理权限的命令行前是#打头，普通权限是$打头），输入命令：exit，即可退出超级管理权限. 之去掉桌面的垃圾桶图标很多人是不是看到干干净净的桌面上有一个回收站的图标深感不满，本教程关于如何去掉桌面上的回收站图标。 首先在应用商店中搜索寻找到“GNOME Tweaks” 确认是这个软件后点击“安装”: 安装完成后打开，在里边找到“桌面”也就是“Desktop”选项设置，右侧的“回收站”也就是“Trash”一项就可以选择是否显示了。 安装拼音输入法打开设置 找到“地区和语言”设置项，点击右边的“管理已经安装的语言” 这时候可能会弹出下边的窗口，可以点开细节查看发现是一些小语种，再次建议可以选择不安装，除非你有特殊需求，否则是没什么作用的。 此处选择“安装/删除语言”选项，点开这个选项时留意一下下边的是否是“IBus”，如果不是更改成为“IBus”（默认应该是这个选项）。 点开后找到汉语（简体）也就是“Chinese(simplified)”，在后边打勾，然后别忘了点击“应用”，也就是“Apply” 此时可以关闭这个设置卡，回到刚刚的设置，点击下边的“+”号。 此时，应该就可以看到“Chinese”了，双击这一行。 这时可以看到有我们安装的拼音输入法了，下边也有五笔输入，可以自行选择。选好后，点击右上角的“添加”，也就是“Add”，即可。 回到桌面，可以找到自己的两个输入法了，并且通过Shift键也可以在两个输入法之间切换。 开机启动引导页面的优化与美化不出意外地，安装好Ubuntu和Windows的双系统后应该是由Ubuntu的grub引导启动的，也就是开机的时候要我们选择进入那个系统的那个黑底白字的难看至极的页面，这篇文章的目的就是对grub引导进行设置和美化。 优化设置grub引导的设置文件是 /etc/default/grub ，对其进行修改可以得到我们想要的结果。 在命令行中输入：如果你会使用vim： sudo vim /etc/default/grub 或者如果你不会使用vim：sudo gedit /etc/default/grub 然后我们就可以对设置文件进行编辑了 一般我们需要更改其中的 GRUB_DEFAULT（默认启动项：这个编号是你开机时看到的若干个启动项从上到下的依次编号，记住！程序员世界的编号从来都是从0开始的，意思是，第一项是0，第二项是1，以此类推）、GRUB_TIMEOUT_STYLE（是否显示倒计时，hidden的属性表示不会显示倒计时）、GRUB_TIMEOUT（等待时间，单位是秒）、GRUB_GFXMODE（屏幕的显示像素，可以不用管这一项） 按照自己的需求更改，其他的很多配置如果你还需要更改可以去查询每一项的具体含义和属性值。 注意一点，如果你更改的属性语句前边有#符号，一定要将其去掉这一句才会起作用。 完成后记得保存离开，然后再命令行输入： sudo update-grub ，对刚才的设置进行更新。整体下来大概是这个样子： 页面美化这个黑底白字的启动引导页面说实话还是极其丑陋的，不过好在我们可以对其进行美化。如果你是可以完成自己修改源码或者加上样式的大神，不用我多说，但是如果你想省事或者不会自己写页面样式，可以去这里下载一款你喜欢的风格的页面样式给自己使用就好： （可能需要翻墙，如果需要请移步我的其他有关科学上网的文章），点击左侧的GRUB Themes 这里你就可以看到各种各样的主题了，选择自己喜欢的一个，我以这个“Poly lignt”为例，选择它并下载。 如果你实在无法打开这个页面，可以来我的百度云分享的这个文件出下载：https://pan.baidu.com/s/1HEhEGK_qK9-0o826CePqrQ 提取码：x1hl 下载好后得到了一个压缩包，将其解压 创建一个文件夹：sudo mkdir /boot/grub/themes/ 将整个解压出来的文件夹拷贝到刚刚创建的文件夹下：sudo cp -R poly-light-master /boot/grub/themes/ 接下来编辑文件：/etc/grub.d/00_header，即输入命令：sudo gedit /etc/grub.d/00_header 如果你发现自己更改内容之后无法保存文件，说明你权限不够，可以进入root权限再次编辑 在打开的 00_header 文件中，加入如下两行： 12GRUB_THEME&#x3D;”&#x2F;boot&#x2F;grub&#x2F;themes&#x2F;poly-light-master&#x2F;theme.txt”GRUB_GFXMODE&#x3D;”1920×1080” 第一句根据你下载的主题改成自己刚刚拷贝到themes文件夹下的主题包中的theme.txt文件，第二句是你屏幕的分辨率。 保存后记得要更新一下grub： sudo update-grub 好了，此时再次重启你的电脑就可以看到好看的开机页面啦！","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blogs.littlegenius.xin/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blogs.littlegenius.xin/tags/Linux/"},{"name":"技术指南","slug":"技术指南","permalink":"https://blogs.littlegenius.xin/tags/%E6%8A%80%E6%9C%AF%E6%8C%87%E5%8D%97/"}]},{"title":"Unity中使用Playground框架轻松制作2D游戏","slug":"Unity中使用Playground框架轻松制作2D游戏","date":"2019-02-20T02:06:51.000Z","updated":"2019-02-20T03:53:04.000Z","comments":true,"path":"2019/02/20/Unity中使用Playground框架轻松制作2D游戏/","link":"","permalink":"https://blogs.littlegenius.xin/2019/02/20/Unity%E4%B8%AD%E4%BD%BF%E7%94%A8Playground%E6%A1%86%E6%9E%B6%E8%BD%BB%E6%9D%BE%E5%88%B6%E4%BD%9C2D%E6%B8%B8%E6%88%8F/","excerpt":"","text":"简单的介绍与起步Unity的Playground是一个用来制作拥有物理引擎的2D游戏开发框架（framework），可以说非常适合初学者了，而且使用Playground框架制作2D游戏不需要编码的工作，单纯在Unity的编辑器中就可以完成，因为Playground提供了很多但任务化的Components，这些Components很容易被结合起来使用，从而得到各种各样的功能。 开始创建游戏创建游戏的过程和上一节中的创建方式一样，只是要将游戏设置为2D，这里我们创建一个名为Playground2D的游戏项目。 创建一个2D游戏项目 引入Assets资源为了使用Playground框架，需要在Asset Store中搜索Unity Playground并下载引入其资源包，在顶部菜单栏的Window中选择Asset Store即可进入资源商店，搜索找到Unity Playground选择下载（Download）然后引入（Import），再进行一系列操作后一气呵成。 注：在Asset Store下载的资源的默认保存位置：C:\\Users\\你的用户名\\AppData\\Roaming\\Unity\\Asset Store-5.x（AppData这个文件夹一般情况下是隐藏的。） 引入Playground框架 引入Playground框架 引入Playground框架 引入Playground框架 引入Playground框架 引入成功后，可以看到Playground框架已经为我们准备了很多资源，主要的资源集中在Scripts，打开这个文件夹可以发现很多已经写好的可以直接使用的脚本。 引入Playground框架后得到的Assets 创建游戏背景在上一篇文章中出现的内容将不详细介绍，这里将SampleScene重命名为MainScene并保存于Scenes目录下，保留Main Camera。 选择Assets-&gt;Images-&gt;Backgrounds下的BG_Space背景图，拖动到Hierarchy面板中。 引入背景图片 在Inspector面板中的Sprite Renderer（着色器）中将起Draw Mode（绘制模式）改为Tiled（平铺），还可以扩大它的大小，这里将其X、Y的Size值均设置为100。然后展开Visibility Options（可视化选项），将Sorting Layer（排布布局）设置为Background（背景），这样可以使得其他所有的GameObject均在其上方。 设置背景参数 添加Player选择Assets-&gt;Images-&gt;Spaceships下的一个图像作为Player，这里选择了一个红色的飞船，并将其拖动到Hierarchy面板中。在Inspector面板中，为了让飞船实现碰撞等物理效果，为其添加刚体属性，只不过这里我们选择添加Rigidbody 2D，即选择Add Component，找到或者搜索该Component之后添加。显然，我们需要将它的Gravity（重力）置零，为了不让其在受到一小点点的力后运动起来停不下来，将其Friction（摩擦力）设置一个合理的值，这里设置为2，Angular Friction（角摩擦）可以保持0.05的预设值。 设置刚体参数 接下来就可以体会到Playground框架的强大之处，因为它为我们准备了各种各样的脚本，运用这些脚本可以直接实现很多游戏情景，而我们要做的只是将对应的脚本添加给对应的GameObject，并且设置脚本需要的public属性的值，也就是在Inspector面板中设置这些值即可。首先，为了让飞船能够运动起来，为其添加一个推动力的脚本：Push，你可以选择从Assets中的Scirpts目录下找到这个脚本拖动到Inspector面板中，也可以在Add Component中直接搜索添加该脚本。然后更改Push Strength（推力大小）为适当的值，这里置为8，Axis（推力的方向）为Y。此时运行游戏可以通过按下空格键使飞船运动起来。 添加Push脚本并设置参数 再添加Rotate脚本，这个脚本可以设置飞船的旋转，很明显Type Of Control设置控制方式，这里选择WASD控制，Speed选项控制旋转速度，这里设置为2，因为我不喜欢操作太灵敏。 设置Rotate脚本参数 这里还给飞船增加了一点儿可爱的属性，找到Assets-&gt;Prefabs-&gt;Particles下的P_Flame，拖动到Hierarchy成为飞船的子物体，让其跟随飞船运动，然后通过选择和平移调整一个合适的位置加到飞船的尾部。 为飞船添加喷射火焰 设置Camera设置Camera，改变其视野范围（调整Frame Size，此处设置为10），并添加一个Follow脚本使其固定跟随一个物体，直接点击Camera中的Add Camera Follow script即可添加，然后将我们的Player也就是飞船拖动到Target作为其参数即可。 设置Camera自动跟随脚本 注：如果想要回到最原始的Components，可以在顶部菜单栏的Playground下选择Turn Playground Off 可以设置关闭Playground框架 添加障碍物选择Assets-&gt;Images-&gt;Asteroids下的一个石头图像作为障碍物，同样需要为其添加Rigidbody 2D属性，修改其中的值。在物理学中我们知道，如果一个物体没有受到任何摩擦力，在其受到一个力从而获得一个初速度后会一直以这个速度运动下去，所以为了避免这种情况的发生，我们还是需要为其Friction赋予一个合理的值。 添加障碍物的刚体属性 添加Collider为了有碰撞效果，为飞船和石头均添加Collider属性 添加障碍物的Collider属性 此时运行游戏，会发现飞船可以撞动石头 添加障碍物后测试运行成功 添加计分机制为飞船添加一个Health System（健康系统），其实就是我们常说的这个东西还有多少滴血，直接添加Health System脚本就行，可以看到，我们可以预设生命值，这里默认为3 添加生命值系统 飞船碰撞到了石头，飞船的生命值就减少一，这需要我们为石头添加Modify Health脚本，然后看到有两个可选参数，第一个Destroy When Activated（起作用时销毁）如果选中的话就会在石头起到“减血”作用后销毁石头，这里不选中，第二个Health Change即为对生命值的变化，这里设置为-1很合理。 设置石头的减生命值功能 添加UI为了让生命值和分数显示出来，我们为Hierarchy目录添加Assets下的Prefabs下的UserInterface，UI自动显示在了游戏界面中。 添加UI 为了让Untiy清楚生命值和分数都记录的是谁的，这里需要为Player添加一个Player的Tag，添加Tag已经在上一篇中详细地提到了。 添加Player的Tag 此时运行游戏，会在你的生命值消耗完时显示Game Over 运行游戏检测游戏结束UI 添加胜利条件到什么时候才算胜利呢？UI Script处可以设置，比如这里默认的为一个玩家、计分制、5分为胜利： 添加胜利条件 创建打击物体为了不让我们的飞船显得太过于脆弱，为其添加发射激光的功能。 这里选择Assets-&gt;Images-&gt;Projectiles下的LasersMid作为发射的激光，拖动到Hierarchy下。 为其添加Rigidbody 2D和capsule Collider 2D（胶囊状的碰撞器）使其拥有碰撞属性，正如上一篇中所提到的，还需要选中Is Trigger一项。 基本的Components Playground框架还为我们准备了Bullet（子弹）脚本使其在特定条件下产生一个该对象的引用，即发射一发子弹。添加了Bullet脚本后的激光束，将其拖动回Assets下的Prefabs目录下成为一个预设体。 添加Bullet脚本 现在有了子弹，还需要一个发射子弹的机枪，我们在飞船下新建一个空的子物体，将其命名为BulletShooter，将其拖动至飞船的顶部也就是发射的地方。 创建一个“机枪” 为刚创建的BulletShooter添加一个Object Shooter的脚本，在Inspector面板中设置其参数。Prefab To Spawn（要发射的预设体）当然是拖动我们已有的Prefab下的子弹预设体到这里作为参数，Key To Press是发射的按键，这里设置为W键，Creation Rate是产生的速度，这里设置为0.2，Shoot Speed为发射速度，这里设置为10，shoot Direction为发射方向，显然是沿Y方向发射，所以将X设为0，Y设为1。 设置Shooter脚本 射击中石头时石头就需要消失并且我们要得分，所以为石头再添加一个脚本：Destory For Points，这个脚本使得物体被击中时销毁并为我们的Player增加分数，Points Worth即其所价值的分数，这里我们设置为0，因为并不想在击中石头后得到分数。 被击中时销毁物体 添加收集体为游戏添加一些在太空中漂浮的外星人，用我们驾驶的飞船去收集这些外星人，收集到的外星人就进入飞船（消失），看起来很简单了。 选择Assets-&gt;Images-&gt;Creatures下的Alien1作为外星人，显然它需要拥有以下的Component： Rigidbody 2D：刚体属性 添加刚体属性 Polygon Collider 2D：碰撞机属性 添加碰撞机属性 Auto Rotate：自动旋转 添加自动旋转属性 再添加一个Collectable（可收集的）脚本，这个脚本表示这是一个可以被收集的物体，Points Worth表示收集到后得到的分数，这里默认1不变。 添加Collectable脚本 这时候运行游戏看一下会发现收集外星人后Score会增加。 收集外星人Score增加 完善游戏最有就很简单了，对石头和外星人进行复制（Duplicate），然后任意摆放，如何设计游戏关卡就是见仁见智的问题了，为了能够胜利，要使得外星人的个数多于在UI中设计的胜利条件的数值哦。 完善游戏 关于文档在引入Playground框架后，可以在Assets文件夹下发现Documentation目录，该目录有关于Playground框架的每一个脚本的具体功能和参数的设置方法，非常值得参考。 参考文档 Cheatsheets Cheetsheets Cheetsheets Cheetsheets Cheetsheets Cheetsheets Cheetsheets Cheetsheets 参考资料：https://unity3d.com/learn/tutorials/s/unity-playground 本节内容的完整官方教程视频（英文无字幕）与官方文档分享：https://pan.baidu.com/s/1MyITuPbK6_zO8rtK_i81pg 提取码：7xti","categories":[{"name":"Unity3D","slug":"Unity3D","permalink":"https://blogs.littlegenius.xin/categories/Unity3D/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Unity3D","slug":"Unity3D","permalink":"https://blogs.littlegenius.xin/tags/Unity3D/"}]},{"title":"超详细！Win10（UEFI启动）安装Ubuntu18.04双系统","slug":"超详细！Win10（UEFI启动）安装Ubuntu18-04双系统","date":"2019-02-15T12:56:58.000Z","updated":"2019-02-20T03:09:34.000Z","comments":true,"path":"2019/02/15/超详细！Win10（UEFI启动）安装Ubuntu18-04双系统/","link":"","permalink":"https://blogs.littlegenius.xin/2019/02/15/%E8%B6%85%E8%AF%A6%E7%BB%86%EF%BC%81Win10%EF%BC%88UEFI%E5%90%AF%E5%8A%A8%EF%BC%89%E5%AE%89%E8%A3%85Ubuntu18-04%E5%8F%8C%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"Windows10&Ubuntu18.04双系统 UEFI模式首先必须说明的是，有两种不同的启动模式，在安装双系统的时候的操作也不尽相同，本文是针对UEFI启动模式的安装双系统的成功案例。如果您的计算机的启动模式是Legacy，请参考其他文章。 如何知道自己的电脑是哪种启动模式找到“运行” -&gt; 在“运行”中输入：msinfo32 -&gt; 查看右边的信息，找到“BIOS模式”，如果后边是“UEFI”，那么这篇文章就可以应用到你的计算机上啦 -&gt; 顺便看一下计算机的“已安装的物理内存（RAM）”，几下这个数字可能会对你有所帮助。 查看电脑的启动模式 查看电脑的启动模式 准备工具Unbutu18.04.1 LTS镜像到Ubuntu官方网站下载最新版Ubuntu LTS镜像：https://www.ubuntu.com/download/desktop 下载Ubuntu18.04镜像 UltraIOS这是一个用于将镜像写入U盘制作系统安装盘，到官方网站下载（试用版足够）：https://cn.ultraiso.net/xiazai.html 下载UltraIOS 装机U盘一个大于2G的空U盘，并且提前将U盘内容备份，U盘需要格式化，格式化后其中的所有东西将被删除。之后将U盘格式化：在插入的U盘上右键选择“格式化” -&gt; 文件系统选择FAT32（默认） -&gt; 开始 制作装机系统U盘插入我们格式化好的U盘，打开UltraIOS，点击上方的“打开”图标，选择刚刚下载的Ubuntu18.04镜像文件 制作装机系统U盘 制作装机系统U盘 看到打开之后的内容大概如下： 制作装机系统U盘 点击“启动” -&gt; “写入硬盘映像” 制作装机系统U盘 这时可以看到上边出现了我们的U盘选项，如果还有别的选项，千万不要选错，一定要点击我们的U盘！下边的写入方式是“USB-HDD+”，右下角是“便捷启动”。检查好这三项之后点击下边的“写入”。经过确认之后会进入等待阶段。 制作装机系统U盘 制作装机系统U盘 制作装机系统U盘 制作装机系统U盘 直到出现了“刻录成功”，直接点击“返回”即可。 制作装机系统U盘 磁盘分区在“此电脑”上邮件打开“管理” 点击左边的“磁盘管理” -&gt; 出现右边的磁盘分区详情 磁盘分区过程 你需要选择将你的一个磁盘分出来一部分空间用来安装双系统，根据你的实际情况选择使用哪个磁盘以及分出多大的空间，我分出了50G（1G=1024M）。在选择好的磁盘上右键，选择“压缩卷”。 磁盘分区过程 填写你要分出的大小，（这里的图片和后续步骤有差异，因为整个过程笔者做了两遍，第一次分配了如图所示的50G空间发现不够用后来第二次更改成了90G，这和后续步骤一致，请根据自己的需求配置此处数值和后续步骤中的数值，特此说明）单位是M，点击“压缩”。 磁盘分区过程 只要你刚刚压缩出来的区域显示“未分配”，说明你压缩成功了！ 设置BIOS此时可以关机重启，在按下电源后及时按住快捷键进入BIOS（联想拯救者是F2），（不同型号的笔记本进入BIOS的快捷键不同，可以百度一下）。将“安全启动”和“快速启动”都关闭（Disable），将“USB启动”设置为开启（Enable） 设置BIOS 开始安装Ubuntu关机，插入U盘，（有多个USB接口的请注意，并不是每一个插口都可以作为USB启动，如果进入boot后没有找到USB启动项，可以换一个插口试试），开机后按住快捷键进入boot（联想拯救者是F12），不同型号的笔记本进入boot的快捷键不同，可以百度一下）。然后选择USB启动那一项。 选择boot从U盘启动 之后会进入一个黑底白字的页面，可以默认选择第一个（Try Ubuntu）进入Ubuntu的试用页面。此时可以随便体验一下，然后可以点击桌面上的安装程序安装Ubuntu系统。 选择语言，我这里选择的英语，可以根据自己的需求选择，接下来的教程中也是英语模式，如果你不懂英语，可以直接看位置，每个窗口的分布和每个窗口的位置都是相同的。 选择语言 选择键盘模式，我们当然选择English(US) 然后会让你选择连接网络，你可以选择连接与不连接。（如果你有一个比较好的网络环境，我倒是建议你可以直接联网，网上说联网环境下安装需要下载比较多的东西，会卡死或者很慢，不过我现在没有遇到这个问题，Ubuntu在国内的服务线路也比较完善了，应该不必担心） 安装方式建议选择“最小安装”，因为这样可以安装一个干净整洁的系统，没有多余的软件，而且安装快，不用边安边下载。下边的“其他选项”根据自己的情况选择，如果联网了可以选择第一个，如果没有联网是没有可选项的。 选择安装内容以及是否在安装过程中下载 安装方式！重中之重！一定要选择最下边的“其他方式”（Something else）！一定要选择最下边的“其他方式”（Something else）！一定要选择最下边的“其他方式”（Something else）！否则你可能会删除原有的Win10系统！ 选择安装方式 再三确认之后，进入下一步，可以在这里找到你刚刚分出来的“空闲空间”，对照一下后边的大小是否是你分出来的大小，选好它之后点击下边的“+”号。 设置Ubuntu的分区空间 接下来就是分区了，每一次分区有四到五个可选项。 挂载“/”，类型为“EXT4日志文件系统”，选中“主分区”和“空间起始位置”。这个空间可以理解成共用空间，尽量大一些，因为有些软件是无法更改他的安装位置到自己的个人目录下的，只能放在这个空间里边。 swap交换空间，这个也就是虚拟内存的地方，选择“逻辑分区”和“空间起始位置”。其大小最好和你的物理内存相等。 设置Ubuntu的分区空间 新建EFI系统分区，选中“逻辑分区”和“空间起始位置”，大小最好不要小于256MB，系统引导文件都会在里面，可以给512MB。重点！分配完之后去上边的列表里找一下，刚刚这个分区的盘符一会儿会用到哦 设置Ubuntu的分区空间 挂载“/home”，类型为“EXT4日志文件系统”，选中“逻辑分区”和“空间起始位置”，这个相当于你的个人文件夹，类似Windows里的User，建议最好能分配稍微大点，因为你的图片、视频、下载内容、有些自定义的软件安装路径基本都在这里面，这些东西可不像在Win上面你想移动就能移动的。 重点来了！此时千万不要点“安装”！找到你刚刚EFI分区的盘符（对照一下后边的大小是否是刚刚分配的大小，然后看看上下文是你分出来的其他分区，再三确认！）记住你的分区的名字，比如我的是图中的“/dev/sda8”更改下边的“安装引导启动器的设备”！千万不要用默认的！改为你刚刚记下的EFI分区的盘符！更改下边的“安装引导启动器的设备”！千万不要用默认的！改为你刚刚记下的EFI分区的盘符！更改下边的“安装引导启动器的设备”！千万不要用默认的！改为你刚刚记下的EFI分区的盘符！ 设置Ubuntu的分区空间 可以点击“安装”了，再次确认一下你的分区。 设置Ubuntu的分区空间 下一步，选择时区 设置时区 最后一步，填一下你的用户名、设备名、密码等等 设置账户与密码 好了，最终进入了你的安装过程 一定的等待时间之后，就会提示安装完毕要求重启，点击重启计算机即可。 安装完毕 等待安装完毕后就可以使用你的Ubuntu啦！此时可以关机重开试试，会在开机后进入引导页面哦然后选择你想进入的系统","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blogs.littlegenius.xin/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blogs.littlegenius.xin/tags/Linux/"},{"name":"技术指南","slug":"技术指南","permalink":"https://blogs.littlegenius.xin/tags/%E6%8A%80%E6%9C%AF%E6%8C%87%E5%8D%97/"}]},{"title":"从“滚球游戏”初步体验Unity3D","slug":"从滚球游戏初步体验Unity3D","date":"2019-02-10T09:45:39.000Z","updated":"2019-02-20T03:09:08.000Z","comments":true,"path":"2019/02/10/从滚球游戏初步体验Unity3D/","link":"","permalink":"https://blogs.littlegenius.xin/2019/02/10/%E4%BB%8E%E6%BB%9A%E7%90%83%E6%B8%B8%E6%88%8F%E5%88%9D%E6%AD%A5%E4%BD%93%E9%AA%8CUnity3D/","excerpt":"","text":"从创建项目开始创建一个项目打开unity，在Projects中可以查看当前的本地项目或者云端项目，点击New project或者右上角的New都可以新建项目。 创建一个项目 然后在1处填写创建项目的名称，2处选择创建地址，3处选择Template（模板），可以选中3D或者2D。 创建一个项目 稍等片刻即可进入unity的主页面。 保存Scene并管理Assets进入unity之后，可以看到已经预设的SampleScene和其中的Main Camera（主摄像机）和Directional Light（平行光）组件，如果你不喜欢这些预设的名字，直接点击修改并使用Ctrl+S保存你的修改即可。 保存Scene 为了使我们的Assets文件夹管理地更加井井有条，推荐对不同的assets进行分文件夹管理，这时一些文件夹的命名可以自己定义，但通常可以遵循一定的不成文的规定，比如通常将场景存放在Scenes目录、将脚本存放在Scripts目录等等，要根据自己来管理好Assets目录，以后对于大量的assets可以很方便快捷。 创建游戏场景创建Plane可以使用unity的内置GameObject的Plane（平面）类型来作为游戏场景的“地面”。可以在Hierarchy视窗下右键选择3D Object下找到Plane创建，也可以在顶部菜单栏的GameObject下的3D Object下找到Plane创建。当然也可以看到unity为我们创建了很多预置的Game Object，比如3DO bject、2D Object、Effects、Light、Audio、 Video、UI、Camera等等，当然每一个分类下还有更详细的分类，这些都可以直接拿来使用，非常方便，一些重要的Game Object以后还会慢慢使用。 新建GameObject的Plane 这里只需要创建一个Plane并将其命名为Ground来作为我们游戏的“地面”，可以看到Plane出现在了MainScene中，同时我们可以注意到Hierarchy视窗中的MainScene右上角出现了一个*号，这就表示该Scene处于待保存的状态，可以通过菜单栏的File-&gt;Save或者快捷键Ctrl+S保存Scene。 待保存的Scene 选中刚刚创建的Ground，Inspector视窗中就会出现其所有的Components，这些都是预先被untiy设置给Plane的，点击Transform这一Component的右侧的齿轮状图标，可以选择Reset（重置）选项，这样，刚刚创建的Plane的Transform就会被重置为初始值，它的Position会被设置为（0，0，0），这是整个游戏世界的原点坐标，游戏中的所有GameObject的坐标都是基于此原点进行计算的。 初始化Transform 选中任何一个GameObject，比如选中Ground，然后按F键，或者在菜单栏中点击Edit-&gt;Frame Select可以快速地调整Scene的角度，让我们有一个非常合适的角度来观察Ground的全貌。 改变Transform改变Transform的三组值的方法有很多。 直接赋值可以在Inspector面板中对Transform的九个值直接输入数值来设置 在Inspector面板中设置Transform的值 拖动输入框调节当我们把鼠标指向每一个值的输入框的左侧边界时，就会发现鼠标成为了一个左右双箭头的形状，此时按下鼠标左键所有拖动，就会发现该输入框变成了蓝色，并可以随着拖动改变它的值。 拖动输入框 在Scene窗口中改变在左上方有六个按钮，分别表示对Scene中GameObject的操作。这里提一句：不管选中六个按钮中的哪一个，只要按住Alt键在Scene中拖动鼠标就可以转动视角，只要滚动鼠标滚轮即可放大/缩小视角。这六个按钮从左到右依次为： 六个改变Scene中GameObject的选项 第一个：拖动Scene的视角 第二个：选中后，再选中Scene中的任何一个GameObject，就可以通过拖动它的三个方向箭头（x、y、z）以及三个平面（xy平面、xz平面、yz平面）来改变Position的值。 改变Position 第三个：选中后可以在Scene中对选中的GameObject改变其Rotation的值 改变Rotation 第四个：选中后在Scene中可以对选中的GameObject进行三个方向的Scale的调整 改变Scale 第五个：选中后可以在Scene中对选中的GameObject进行顶点的位置调整从而改变Scale的值 改变Scale 第六个：选中后可以同时改变Position、Rotation、Scale的值，是第二三四个的结合。 同时改变所有的Transform 创建游戏对象创建Sphere接下来创建小球，同样地，在MainScene下右键-&gt;3D Object-&gt;Sphere来创建一个unity预置的Sphere（球体），命名为Player，并通过reset其Transform来使其位置重置到原点。 新建一个Sphere 这样我们看到小球的中心已经被定位到了（0，0，0）处，为了让小球能在平面上滚动，我们需要将小球放到平面上。观察小球的Transform我们可以得到，它的Scale的值为（1，1，1），也就是说它的三个方向的大小都为1单位，为了让小球放到平面上边，显然我们需要将其向上移动半个球的距离，即将Position的Y值设置为0.5，小球就刚好在平面上了。 将小球放到平面上 关于光源其实我们可以看到小球是有影子的，这是最开始unity为我们准备的Directional Light作用的结果，我们可以看到Scene中的一个小太阳的标志，这个就是我们的光源，使用Directional Light来模拟太阳的平行光。它的Transform则显示了光源的位置、角度（也就是平行光的照射方向），如果我们将这个GameObject去掉的话就没有了光的效果。当然通过改变Rotation的值就可以调节光源的方向，比如为了效果我将Rotation的Y值改为60。 关闭光源后的效果 创建Material为了使GameObject美观，我们通常会对其表面进行一系列装饰，而其表面的表现是通过为这个GameObject添加Material（材料）来实现的。接下来为我们的Ground和Player添加最简单材料：纯颜色。在Assets下新建Materials目录用于管理各种材料，然后右键该目录选择Create-&gt;Material新建一个材料命名为Background。 新建一个Material 选中Background，就可以看到它的Inspector面板了，我们在Albedo（反射率）一栏中可以选择一种颜色，在下方的预览中就可以看到效果了，这里我们选择RGB色（0，32，64）作为我们的Background的颜色。 为Material选择颜色 想要将创建的Material运用在某个GameObject上，很简单，只需要拖动该Material到Scene中的目标GameObject上或者拖动到Hierarchy的该GameObject上即可。 将Material运用到Scene中 可以看到我们的Ground已经变成了蓝色 成功改变Plane的颜色 让小球滚动起来让小球拥有成为刚体为了让小球有滚动的效果，我们需要小球拥有一系列的物理属性，物理属性已经由unity内置，我们只需为需要增加物理属性的GameObject添加一个Rigidbody的Component即可。如上一节中所示，选中Player，在Inspector面板中通过Add Component中找到Physics下的Rigidbody即可。 添加Rigidbody属性 为小球添加控制脚本有了刚体属性的小球需要在我们的控制下滚动，比如我们规定使用W，S，A，D四个按键来控制小球的方向，那么对于一个有物理属性的刚体来说，为了能够动起来，当然需要力（Force）作用在物体上，这些有关于如何控制GameObject的方法需要我们使用脚本（Scripts）来完成，假如你已经拥有了一定的C#编程基础。同样我们在Assets下创建Scripts目录来管理脚本，在该目录处右键-&gt;Create-&gt;C# Script创建一个脚本，这里我们命名为PlayerController。 新建脚本 为了让我们创建的脚本与Player联系起来，可以在Player的Inspector面板下选择Add Component，在其中搜索我们的脚本名字就可以找到该脚本，根据unity的命名规范，喜欢将脚本各个单词使用“驼峰法”并且首字母同样大写的方式，有趣的是，unity对于这些脚本通常都会在每个大写字母处将这些单词分开，我也不知道为什么。简单点儿的话可以直接将Assets中的脚本拖到Inspector面板下，就可以添加成功。 将脚本添加给GameObject 打开脚本编辑脚本需要编辑器，Visual Studio是较好的选择，它和unity之间有很好的合作关系，使用起来也很方便。双击脚本文件或者在Inspector面板中点击脚本的右上角的齿轮图标选择Edit Scrpit都可以打开编辑器对其进行编辑。 Unity的预置脚本内容 unity已经为我们预置好了脚本的最基本结构，最基本的，我们可以看到所有的unity脚本都继承自MonoBehaviour类，然后有两个预设函数，Start函数是在第一帧开始渲染前调用，Update函数在每一帧刷新前调用，都是非常常用的函数。接下来思考我们要做的事情，我们需要检测用户的输入，并且通过输入的按键来控制小球的滚动方向，检测用户的输入同时也需要识别输入的是哪一个按键，除此之外我们还需要一些物理学有关的逻辑，比如我们需要添加一个力来控制小球的移动，这就是物理学逻辑，这些逻辑当然是每一帧都要进行一次，所以我们需要将这些逻辑写在每一帧更新都要执行的函数中。显然我们可以写到Update函数下，因为Update函数是每一帧刷新前都会调用的，同时我们还有另外的选择，即使用FixedUpdate函数，它在每一次进行物理学运算的时候调用，每次检测到用户输入都需要进行物理学运算，所以我们可以将逻辑写到FixedUpdate函数下。 开始编写脚本首先我们需要创建一个对于这个Player小球的引用，这样才能知道我们控制的是哪个小球，这里小球是刚体，所以我们创建一个刚体（Rigidbody）的引用，并且需要在第一帧开始渲染之前通过GetComponent方法来找到小球创建刚体的引用，这一逻辑自然就需要写到Start函数中了。 123456private Rigidbody rigidbodyPlayer;void Start()&#123; rigidbodyPlayer = GetComponent&lt;Rigidbody&gt;();&#125; 接下来对用户输入的读取就需要写到FiexedUpdate函数中了，我们使用Input类的GetAxis方法来获取水平或者垂直的运动轴，这个方法会返回一个float值作为该轴的移动距离。 12float moveHorizontal = Input.GetAxis(\"Horizontal\");float moveVertical = Input.GetAxis(\"Vertical\"); 通过以上两行代码我们就可以将用户的W，S，A，D输入转化为水平轴和垂直轴的移动距离，分别存储在moveHorizontal和moveVertical两个float类型的变量中。 接下来通过Rigidbody类的AddForce方法可以为刚体添加作用力，AddForce方法接受一个三维向量（Vector3）参数，这个三维向量就可以表示力，显然我们的三维向量可以用刚才的moveHorizontal和moveVertical两个变量作为X值和Z值，同时我们是不需要小球在Y方向上移动的，也就是将Y方向的力作用设置为0.0f即可，经过调试我们会发现小球的移动速度过慢，为了方便调节小球的速度，只需要在表示力的三维向量前乘以一个倍数即可，为了方便调整，我们设置一个public的float类型的变量speed来调节这个乘积。这里必须说明的是，凡在unity的脚本中被声明为public类型的变量，在unity的Inspector界面中的该脚本的Component下都会出现一个可以设置的值的方框。 123456public float speed;void FixedUpdate()&#123; Vector3 movement = new Vector3(moveHorizontal,0.0f,moveVertical); rigidbodyPlayer.AddForce(movement*speed);&#125; 更改public的Speed的值 此处我们将speed的值设为10比较合理，运行游戏就会发现通过W，S，A，D的控制，小球动了起来。 让小球滚动起来 完整的代码：123456789101112131415161718192021222324using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerController : MonoBehaviour&#123; private Rigidbody rigidbodyPlayer; public float speed; void Start() &#123; rigidbodyPlayer = GetComponent&lt;Rigidbody&gt;(); &#125; void FixedUpdate() &#123; float moveHorizontal = Input.GetAxis(\"Horizontal\"); float moveVertical = Input.GetAxis(\"Vertical\"); Vector3 movement = new Vector3(moveHorizontal,0.0f,moveVertical); rigidbodyPlayer.AddForce(movement*speed); &#125;&#125; 当然你也会发现，小球超出了Plane的边界居然掉了下去，其实这是合理的，因为小球为刚体，也就拥有物理引擎，当然受到重力的影响，在没有Plane的向上的作用力的情况下自然会下落。 设置摄像机可以发现，我们的Camera的角度和位置都比较刁钻，这导致我们的游戏看到的画面并不完整，接下来我们对Camera进行设置，使其能够跟随我们的小球滚动来同时移动。首先调节Main Camera的Position和Rotation使得画面和角度比较合适，比如这里将Position的Y值设为6，Z值设为-6，将Rotation的X值设为45得到了一个较为合适的位置。 改变摄像机的Transform 接下来通过脚本控制Main Camera跟随小球Player一同移动，即在Position上保持相对静止。可能你会想到，只需要将Main Camera拖动给Player使其成为Player的子物体不就可以保持两者相对位置不变化了吗？但是问题在于球体Player是滚动的，如果两者的位置完全相对静止，就会导致球滚动时Main Cmaera也会跟着球滚动，有一种天旋地转的感觉。感兴趣的话可以尝试一下。新建脚本CameraController并添加给Main Camera做一个Component。为了使Main Camera的Transform的Position和Player的保持相对静止，Rotation并不和其保持一致，可以想到一个办法：设置一个偏移量，这个值初始化为游戏开始时Main Camera和Player之间的Position的差值，然后在球滚动时，每一次滚动都改变Main Cmaera的Position，使其新的Position等于现在球的Position的值加上刚才的偏移量，这样就会在每次球的位置改变时Main Camera都会跟上它的步骤。显然，偏移量的设置需要在Start函数中完成，每一次球的位置发生变化时的逻辑可以在Update函数中完成，但还有一个更好的选择，就是LateUpdate函数，该函数在每次有GameObject发生变动时才会调用。同时，我们的脚本使加在Main Camera上的，所以Main Camera的Transform可以直接调用，但是球的Transform则需要单独获取，这里我们设置一个public的GameObject量，然后在unity中将球Player拖动到这个量处作为参数即可。 123456789101112private Vector3 offset;public GameObject player;void Start()&#123; offset = transform.position - player.transform.position;&#125;void LateUpdate()&#123; transform.position = player.transform.position + offset;&#125; 添加Player实例 这时候运行游戏就可以发现Main Camera的位置随着球的改变而发生了改变。 MainCamera成功跟随小球变化位置 完整的代码：12345678910111213141516171819using System.Collections;using System.Collections.Generic;using UnityEngine;public class CameraController : MonoBehaviour&#123; private Vector3 offset; public GameObject player; void Start() &#123; offset = transform.position - player.transform.position; &#125; void LateUpdate() &#123; transform.position = player.transform.position + offset; &#125;&#125; 建立围墙为了不让小球总是滚落到Plane之外，可以在其四周围建立起一圈儿围墙，很简单，使用预设的Cube就可以了。为了更好的管理四个围墙，我们可以先创建一个空的GameObject，将其命名为Walls，Reset使其重置位置，然后在其上右键新建一个Cube，并命名为WestWall，这样这个Cube就成为了Walls的子物体。 新建Cube 接下来如何调整这面墙的大小、位置就很简单了，可以在Inspector中直接输入具体数值，也可以直接在Scene中拖动和缩放，最好我们可以得到这个墙体结构。 改变Cube的Transform 为了简单方便，只要选中WestWall，在菜单栏的Edit中选择Duplicate（复制）（快捷键：Ctrl+D）即可，然后将复制好的墙拖动到适合的地点，在复制，最后可以得到四面墙。 复制Cube建立围墙 接下来测试游戏，墙起作用了！ 围墙正常运行 创建碰撞小立方体新建Cube我们在游戏场地中加入一些旋转的小方块儿，然后由球来碰撞这些小方块儿，碰撞之后就加一定的分数。很简单地，创建一个Cube，并命名为PickUp，使其Reset，然后我们调整一下它的Rotation和Scale，使得其变成一个斜放的小立方体，（为了方便看，这里暂时隐藏了Player，只要在Player的Inspector面板中将其前边的对勾打掉它就会隐藏）。 建立小立方体并改变其角度 让小立方体旋转起来为了让小方块儿更有趣，我们来添加一个脚本让他旋转起来，新建脚本Rotator，并添加给PickUp，编辑此脚本。这个逻辑中是不需要Start函数的，我们只需要每一帧都让小方块儿转动一下，所以将逻辑写到Update函数中，这里使用Ratate方法，需要一个Vector3作为参数，为了不让旋转过快，我们给每一帧都乘以一个小的时间量。 123456private Vector3 rotation = new Vector3(15,30,45);void Update()&#123; transform.Rotate(rotation * Time.deltaTime);&#125; 保存脚本，运行游戏可以看到小方块旋转起来了。 让小立方体旋转起来 创建Prefab接下来我们需要多放置一些立方体在游戏的平面上，在此之前，我们需要把这个设计好的立方体生成一个Prefab（预设体），让它变成一个asset，这样我们可以从prefab创建这个立方体的实例，这样我们才能分别控制每一个由prefab生成的实例或者控制prefab本身，在这个游戏中，被小球碰撞到的小立方体会消失，这也就是我们需要更新每一个小立方体的状态，所以我们需要创建一个Prefab。 a prefab is an asset that contains a template, or blueprint of a game object or game object family.（预设体是包含游戏对象或游戏对象族的模板或设计大纲的一种资源。） 在Assets下新建Prefabs目录来管理预设体，只需要将MainScene中的PickUp拖拽到新建的目录下就可以生成对应的asset了，这时也会看到MainScene中的PickUp变成了一个蓝色的图标。 创建一个Prefab 此时在MainScene中新建一个空的GameObject来管理所有的小立方体，命名为PickUps，将刚刚的第一个PickUp拖拽到它的上边使其成为其子物体。 调整父子GameObject的关系 放置更多的立方体接下来放置小立方体，为了调整一个好的视角，我们可以点击Scene中右上角的方位标志的Y轴的小锥体，就会调整视角到俯视的角度，这是一个便捷的小技巧。 调整视角成俯视 由于我们的小立方体是一个斜放的立方体，在原本的坐标轴下很难调整立方体在水平面上的位置，这里还有一个小技巧，我们点击右上角的Local变成Global，这样就会在Global的坐标中对小立方体进行调整了，可以看到，小立方体的三个坐标轴变成了只有两个方向的轴，非常方便就可以调整了。 将坐标改为Global 接下来只需要Duplicate几个或者使用Ctrl+D来重复放置一些小立方体即可。这里粗略地摆放了八个小立方体。 摆放8个小立方体 为小立方体涂色让后再通过添加一种Material的方式将他们涂成黄色。这里可以通过两种方式完成。第一种，将Material拖拽给任意一个PickUp立方体，然后再该PickUp的Inspector的Prefab的Overrides（重载）下选择Apply All来让所有PickUp都被涂成黄色。 为小立方体涂色 第二种方法会更加简单，直接将Material用于Assets中的小立方体的Prefab就可以啦，找到Assets中的PickUp的Prefab，点击Inspector面板中的Open Prefab，就会在Scene窗口中预览该Prefab，这是再拖动黄色的Material到他上边，这个Prefab就会被染成黄色了。 为小立方体涂色 为小立方体涂色 完成碰撞为PickUp添加标签如果小球碰撞了旋转的立方体，那么小立方体就会消失。那么如何识别我们的小球Player碰撞的是小立方体呢？我们通过为PickUp添加特定的标签来识别。添加标签再Prefab上，在Assets中找到我们的Prefab并打开它，可以在它的Inspector面板中发现它还没有添加标签（Untagged），点击Tag后的按钮选择Add Tag…，来添加一个名为PickUp的标签，然后再回到最开始的面板处选择新添加的这个标签，这样PickUp的标签就添加好了。 新建并添加PickUp标签 完成碰撞逻辑重新编辑PlayerController的脚本，这里我们将碰撞发生的逻辑写到函数OnTriggerEnter中，这个函数在发生碰撞事件的时候调用，而且用碰到的Collider（碰撞机）作为参数，也就是我们的Player碰到的Collider。可见，如果要检测到的碰撞，被碰撞的物体需要由碰撞引擎，也就是要有Collider的属性，其实我们会发现，作为Cube保存的一个Prefab在创建之初就已经有Box Collider的这一Component了，所以不再需要我们自己添加。 Box Collider属性 OnTriggerEnter函数用其碰撞到的Collider作为参数，现在就需要我们识别这个碰到的Collider是不是一个PickUp了，显然可以使用Tag来鉴别，这里使用gameObject的CompareTag方法来完成，该方法以一个字符串作为参数，返回一个布尔值，如果gameObject的Tag和字符串一致，就返回true。接下来完成控制小立方体消失的逻辑，很简单，使用gameObject的方法SetActive来完成，这个方法控制的就是我们在Inspector面板中看到的每一个GameObject前的小对勾，该方法接受一个布尔值作为参数来控制GameObject的消失与显现。完整的代码如下： 1234567void OnTriggerEnter(Collider other)&#123; if (other.gameObject.CompareTag(\"PickUp\")) &#123; other.gameObject.SetActive(false); &#125;&#125; 关于碰撞的简单原理此时运行游戏，在小球碰到小立方体的时候小立方体并没有像我们像的那样消失，这里的原因需要我们了解一定的Unity对与碰撞到原理。Unity将Collider（碰撞机）分为静态碰撞机（Static Collider）和动态碰撞机（Dynamic Collider）两种。静态的碰撞机比如墙面、地板等一些列静态的物体，与他们碰撞时，不允许两个Collider相互重合，也就是说会发生反弹，而为了让我们的碰撞能够实现，我们需要将立方体设置为动态的（Trigger）触发器，成为Trigger的Collider是可以被穿过的，这样才会引发我们的“碰撞事件”的逻辑。这里我们找到PickUp的Prefab，在它的Box Collider的Component中，勾选Is Trigger选项，这样它就成为了一个触发器。 选择Trigger属性 此时运行游戏可以发现，小立方体在受到碰撞后完美消失。 小立方体被碰撞后消失 优化这里有一个有关物理引擎的优化，首先我们区分了静态碰撞机和动态碰撞机，Untiy对于静态碰撞机，会将它们的体积记录在一个缓存中，这是很合理的，因为静态即不动，所以并不需要在每一帧都计算器和重新绘制它的体积，而动态的则不同，因为它是运动的，所以必须在每一帧处都计算和绘制，这个过程是需要耗费资源的。 Any game object with a collider and a rigid body is considered dynamic.Any game object with a collider attached but no physics rigid body is expected to be static.（任何同时带有Collider和Rigidbody属性的GameObject称为动态的，任何只有Collider而没有Rigidbody属性的GameObject称为静态的） 为了让PickUp成为动态的，这样不需要每一次都计算它的体积，我们为PickUp的Prefab添加Rigidbody属性，运行游戏，发现神奇的事情发生了，所有的PickUp居然掉了下去，这当然是由于所有的刚体都受到了重力的影响，所以PickUp会下落。 小立方体受到重力下落 为了解决这一问题，移步到PickUp的Prefab下刚刚添加的Rigidbody属性处，会发现有两个选项，分别是Use Gravity和Is Kinematic。 更改其成为Kinematic Rigid body 显然，我们可以直接将Use Gravity的对勾打掉，这样它不再受重力，自然不会下落，这是一个解决办法，但是并不完美，因为这里我们只取消了重力，但对于一个刚体来说，还会受到其他的力从而使其改变Transform，所以更好的做法是选中下方的Is Kinematic选项，接下来解释Kinematic：Kinematic Rigid body（运动刚体）的含义是它的Transform也就是位置、角度、大小不会随着力的作用而改变而是单纯地根据Transform设置的值来改变，也就是说我们不能通过对其作用力来改变它的Transfrom，改变的唯一方法是直接调节其Transform下的各个值。运行游戏，完美！ 添加计分机制添加计数器接下来添加一个计数器，每撞到一个小球就使计数器数值增加一，自然需要编辑PlayerController脚本，声明一个int类型的变量，在Start函数中初始化为0，在每一次碰撞到小立方体后都增加一，这似乎是一个很简单事情，这里还特地将count每次更新后的值都打印到控制台来验证其正确性。 123456789101112131415private int count;void Start()&#123; rigidbodyPlayer = GetComponent&lt;Rigidbody&gt;(); count = 0;&#125;void OnTriggerEnter(Collider other)&#123; if (other.gameObject.CompareTag(\"PickUp\")) &#123; other.gameObject.SetActive(false); count++; Debug.Log(count); &#125;&#125; 控制台显示计分结果 添加UI在游戏界面中显示分数显然，将分数显示在游戏界面中才是更好的选择，这里需要用到UI组件。在Hierarchy面板中右键，选择UI-&gt;Text，就会创建一个UI组件，但是我们会发现其实Text外还有一层Canvas（画布），下方还出现了一个EventSystem，这些都是Unity为我们自动创建的，这是因为： The single most important thing to know about these additional items is that all UI elements must be the child of a canvas to behave correctly.（所有的UI元素都必须是一个Canvas（画布）的子元素才能正常工作） 这里将Text命名为CountText，这时候的CountText处于一个非常奇怪的位置，接下来我们来调整Text的位置。 新建Text和Canvas 在Inspector面板中，我们可以调整Text显示的内容，字体的样式，字体颜色以及这个UI组件的位置，先把文字显示改为Count Text，接下来改变其字体颜色为白色。 改变字体颜色 接下来调整Text的位置，找到Inspecctor的Rect Transform，可以看到UI的Transform和一般GameObject的定位方式不同，这个位置的确定是相对于游戏屏幕的，点击左边的这个方框，展开位置选择的面板，根据提示：按住Shift键选择中心轴（pivot），按住Alt键选择位置（position）。我们选择同时按住Shift和Alt键，将Text放到Canvas的左上角： 更改Text的位置 这样就可以看到Count Text放置到了Game窗口的左上角。接下来可以改变Rect Transform的Pos X的值和Pos Y的值让Count Text稍微离左边缘和顶部边缘一段距离： 加入偏移量 编辑脚本来显示分数接下来当然是将分数显示到Text中，继续编辑PlayerController脚本，首先需要添加新的Namespace： 1using UnityEngine.UI; 然后自然需要创建一个Text变量来表示CountText的一个引用，我们将此Text变量声明为public的类型，为了可以在Inspector中对其进行直接的赋值。接下来要初始化CountText中所显示的文字，使用Text的text变量即可，在Start函数中进行初始化，然后再每一次碰撞到小立方体的时候再重新更新Text的内容： 12345678910111213141516public Text countText;void Start()&#123; rigidbodyPlayer = GetComponent&lt;Rigidbody&gt;(); count = 0; countText.text = \"Count: \" + count.ToString();&#125;void OnTriggerEnter(Collider other)&#123; if (other.gameObject.CompareTag(\"PickUp\")) &#123; other.gameObject.SetActive(false); count++; countText.text = \"Count: \" + count.ToString(); &#125;&#125; 保存脚本回到Unity，将CountText拖动到Inspector中新产生的这个Text变量处来实例化它即可。 实例化Text 运行游戏，完美！ 游戏正常运行 添加完成提示最后，当所有的小立方体都被收集后，再屏幕中心显示“You Win！”的字样，这看起来就很简单了，同样是：添加一个新的Text组件、命名、改变字体颜色大小和位置、在脚本中新建一个Text变量、在Start函数中将其初始值设为空、满足count值大于等于8的时候即显示“You Win！”、将新的Text拖动到Inspector面板中的变量处。主要的代码： 123456public Text winText;winText.text = \"\";if (count &gt;= 8)&#123; winText.text = \"You Win!\";&#125; 运行游戏，完美！ 添加You Win！的信息 Build游戏最后就是创建我们的游戏了！Unity创建游戏的平台非常广泛，我们可以无需任何其他插件的前提下创建Windows、Mac和Linux平台下的游戏，但是如果创建诸如Android、IOS端的游戏需要额外的工作，比较复杂，以后会单独提到，这里先创建一个Windows平台的.exe文件。先保存Scene，然后选择File下的Build Settings…。 进入Build Settings 默认即PC，Mac &amp; Linux Standalone，这里还需要我们通过Add Open Scene来选择我们需要创建的Scene，不过本游戏只有一个Scene，不进行选择也是可以的。点击Build，选择要保存到目标目录，然后稍等片刻，就会得到了最终的.exe文件。 Build游戏 打开文件即可直接运行，整个游戏的所有工程也就全部完成了！ 打开游戏程序 游戏完美运行！ 参考资料：https://unity3d.com/learn/tutorials/s/roll-ball-tutorial本节内容的完整官方教程视频分享（英文无字幕）：https://pan.baidu.com/s/1TNMMFjs7pZqLPhGQZ1tPqQ 提取码:1u70","categories":[{"name":"Unity3D","slug":"Unity3D","permalink":"https://blogs.littlegenius.xin/categories/Unity3D/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Unity3D","slug":"Unity3D","permalink":"https://blogs.littlegenius.xin/tags/Unity3D/"}]},{"title":"入门Unity3d","slug":"入门Unity3d","date":"2019-02-09T14:21:27.000Z","updated":"2019-02-20T03:09:32.000Z","comments":true,"path":"2019/02/09/入门Unity3d/","link":"","permalink":"https://blogs.littlegenius.xin/2019/02/09/%E5%85%A5%E9%97%A8Unity3d/","excerpt":"","text":"Play 和 Edit 模式Scene 窗口 Scene窗口 Scene窗口可以看成一个“容器”，整个游戏的所有东西（如地图、道具、角色等）都会包含在这个“容器”中，也就是说我们可以通过Scene窗口看到整个游戏世界，通过一些操作（如后续陈述）我们可以改变观看这个世界的角度、远近等，还可以拖动任何一个可动的元素，调整其位置角度大小，从而通过Scene窗口观察和安排游戏内容，称这个模式为Edit模式。 Game 窗口 Game窗口 Game窗口所展示的内容即“玩家”看到的内容，也就是说Game窗口是从玩家角度来看我们的游戏世界的。因为玩家所看到的内容是取决于Camera的角度和视野的，所以尽管我们可以在Scene窗口中随意变化观察的角度，但是Game窗口的内容却只取决于Camera所看到的内容。同时如果运行游戏的话还可以在Game窗口中直接“玩”我们的游戏，从而达到调试的目的。 运行游戏 上方的这个按钮即可运行游戏，就进入了Play模式，然后我们就可以“玩”/调试我们的游戏了。 游戏开始运行 再次点击此按钮退出Play模式 退出运行中的游戏 GameObjects 和 Components所有Scene窗口中可见的东西都可以成为GameObject（游戏对象），GameObjects是搭建游戏的最基础的模块，但是任何一个GameObject本身并没有任何作用，他的属性以及行为都是由这个GameObject所拥有的Components（元件）决定的，Components从属于GameObject，从而告诉了每一个GameObjects应该表现哪些行为以及拥有哪些属性。 为GameObject添加Components举个例子：如果我们给某个GameObject添加一个Rigidbody（刚体）的Components，那么这个GameObject就拥有了刚体的物理特性（比如受到重力等），Rigidbody是集成与unity中的，不需要我们规定其相关逻辑，只要我们给某个GameObject添加了这种Component，那么他就有了刚体该有的属性。首先在Scene窗口中选中一个GameObject，然后这个GameObject的所有信息、其拥有的所有Components就会被显示在Inspector窗口中，在这个窗口中，我们可以管理这个GameObject的所有Components。 在Scene窗口中选中GameObject 另外，在Hierarchy窗口中，列出了所有Scene中的GameObjects以及他们的层级关系，点击此处的任何一个GameObject也可以选中它，并且点击选中后，对应的Scene窗口中该GameObject也会高亮，两者相互呼应。 在Hierarchy面板中选中GameObject 此处就为此GameObject添加一个Rigidbody，点击最下方的Add Component，在Physics中可以找到Rigidbody一项。 添加Rigidbody 添加完成后出现了Rigidbody 添加后的Rigidbody 更改Components的参数值每个Components都有可能会有很多可以设置的values（参数值），通过设置这些参数值，就可以改变该Component的属性从而改变GameObject的属性，比如上图中的Mass、Drag、Angular Drag等都可以改变参数值。 Transform任何一个GameObject都拥有Transform的Component，Transform规定了它的Position（位置）、Rotation（旋转角度）、Scale（放缩大小），他们的值可以通过在Inspector中直接修改来设置也可以通过在Scene窗口中直接拖拽、旋转来设置。 Prefabs有些在Scene窗口中出现的GameObjects我们以后可能会经常用到，比如游戏中的一面墙，我们为其设置好了很多Components以及其对应的值，我们肯定不希望每一面墙都重新添加一遍这些Components并重新设置参数值，那么此时我们就可以将一些GameObjects保存成为Prefabs（预设体），下次用到可以拿来即用，也就是说Prefabs可以生成很多的同样的GameObjects。 Assets我们可以找到Project窗口，这个窗口中所列出和管理的东西统称为assets（资产），assects可以是3D models（3D模型）、audio files（音频文件）、scripts（脚本）等等，显然，Prefabs也是一种assets，这些资产可以看成是游戏的原材料，我们的游戏中想要有的东西都可以从这里找到。 Project面板 将Prefabs实例化可以通过将任何一个prefab拖动至Hierarchy窗口中，这样就会创建了该prefab的一个实例（instance），可以认为是复制了一份prefab成为了GameObject添加到了游戏的Hierarchy中。 实例化Prefab untiy的几个重要的视窗（View）在上述内容中我们间接地提到了unity的几个重要的视窗（View），在此做一个总结。 这些视窗的位置可以随意调节，比如下图是我比较喜欢的一种安排方式，不过也需要根据不同需求随时做一些调整。 Unity编辑器的视窗分布 Scene窗口用来看游戏的全局，可是换地查看和管理所有的GameObjects Hierarchy窗口展示了Scene窗口中的所有GameObjects以及它们的层级关系 Game窗口展示了真正游戏的所见内容，可以在这里进行游戏调试 Inspector窗口列出了所选中的GameObject的所有Components，这里可以对他们进行管理并且更改参数值 Projects窗口列出了所有assets Console窗口即是控制台所打印的信息，可以用来调试C#脚本或者其他内容 有时需要在Unity的商店中下载资源，就需要用到Assets Store窗口 参考资料：https://unity3d.com/learn/tutorials/s/interactive-tutorials","categories":[{"name":"Unity3D","slug":"Unity3D","permalink":"https://blogs.littlegenius.xin/categories/Unity3D/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Unity3D","slug":"Unity3D","permalink":"https://blogs.littlegenius.xin/tags/Unity3D/"}]},{"title":"OpenGL使用VS2017和CMake配置GLFW和GLAD","slug":"OpenGL学习笔记（一）使用VS2017和CMake配置GLFW和GLAD","date":"2019-01-24T07:48:53.000Z","updated":"2020-01-13T12:51:20.670Z","comments":true,"path":"2019/01/24/OpenGL学习笔记（一）使用VS2017和CMake配置GLFW和GLAD/","link":"","permalink":"https://blogs.littlegenius.xin/2019/01/24/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E4%BD%BF%E7%94%A8VS2017%E5%92%8CCMake%E9%85%8D%E7%BD%AEGLFW%E5%92%8CGLAD/","excerpt":"","text":"简单的介绍OpenGLOpenGL（Open Graphics Library，开放图形库），一般被认为是一个API(Application Programming Interface，应用程序编程接口)，包含了一系列可以操作图形、图像的函数。其实，OpenGL本身并不是一个API，它仅仅是一个由Khronos组织制定并维护的规范(Specification)。OpenGL规范严格规定了每个函数该如何执行，以及它们的输出值。至于内部具体每个函数是如何实现(Implement)的，将由OpenGL库的开发者自行决定。 GLFW在我们使用OpenGL进行绘制图形之前，首先要做的就是创建一个OpenGL上下文(Context)和一个用于显示的窗口。然而，这些操作在每个系统上都是不一样的，OpenGL有目的地从这些操作抽象(Abstract)出去。这意味着我们不得不自己处理创建窗口，定义OpenGL上下文以及处理用户输入。 GLFW是一个专门针对OpenGL的C语言库，它提供了一些渲染物体所需的最低限度的接口。它允许用户创建OpenGL上下文，定义窗口参数以及处理用户输入。这也就节省了我们书写操作系统相关代码的时间，提供给我们一个窗口和上下文用来渲染。 官方网址：https://www.glfw.org/ GLAD因为OpenGL只是一个标准/规范，具体的实现是由驱动开发商针对特定显卡实现的。由于OpenGL驱动版本众多，它大多数函数的位置都无法在编译时确定下来，需要在运行时查询。所以任务就落在了开发者身上，开发者需要在运行时获取函数地址并将其保存在一个函数指针中供以后使用。取得地址的方法因平台而异，所以非常繁琐。幸运的是，有些库能简化此过程，其中GLAD是目前最新，也是最流行的库，它是一个开源库，可以在其提供的在线服务中配置。 CMakeCMake是一个工程文件生成工具。用户可以使用预定义好的CMake脚本，根据自己的选择生成不同IDE的工程文件。这也就允许我们从GLFW源码里创建一个Visual Studio 2017工程文件，之后进行编译。 官方网址：https://cmake.org/ 在Windows下使用VS2017的配置过程注：为了给大家提供方便，我已经将前几步整合好的Packages包打包，需要的话可以直接下载： 下载链接：https://pan.baidu.com/s/1iwJhRHecTnn6GtVYSewrQg 提取码：s733 如果你已拥有了这个包，可以直接跳到“创建一个工程并将Packages的内容引入”一节，如果你想亲手经理一边整个配置过程，就可以继续从头阅读下去。 下载GLFW库下载页面：https://www.glfw.org/download.html 在下载页面，我们下载其源码，然后使用CMake自己进行编译，以获得Visual Studio 2017可用的工程文件。 下载GLFW 下载后解压得到的文件如下： GLFW解压文件 下载CMake下载页面：https://cmake.org/download/ 这里下载的是3.13.3版本的Windows64位安装包： 下载CMake 使用CMake和VS2017生成解决方案下载完成后正常安装，并且打开已经安装成功的CMake。这里我们可以选择用GUI打开或者通过Command Line使用，为了简单直观，使用GUI来运行CMake。 将源代码一栏定位到刚刚下载好的GLFW源码文件夹下，然后选择一个生成的目标文件夹，之后点击下方的“Configure”进行设置。 使用CMake生成VS2017工程文件 默认其选项即可： 使用CMake生成VS2017工程文件 然后依次点击Configure、Generate： 使用CMake生成VS2017工程文件 使用CMake生成VS2017工程文件 看到最后输出成功即可。 使用CMake生成VS2017工程文件 此时可以在刚刚设置的目标文件夹下找到已经生成的.sln文件，双击使用Visual Studio 2017打开该解决方案，即可直接进行编译。 找到生成的.sln文件 使用Visual Studio 2017生成解决方案 使用Visual Studio 2017生成解决方案 编译成功后，可以在刚刚目录的build\\src\\Debug\\目录下找到编译后的文件： 找到编译后的文件 下载GLAD库GLAD提供了一个在线服务地址，用来配置和生成GLAD库。 在线服务网址：https://glad.dav1d.de/ 可以按照如下的内容配置，在GL的版本上，只要选择一个3.3以上的版本即可，这里选择的最新版本4.6，Profile处要选择Core模式。 GLAD的在线配置 生成好后直接下载对应的压缩包即可。 下载GLAD包 解压后得到如下文件： 解压GLAD包得到的文件 将所需的文件打包为了方便，这一步我们将所有OpenGL用到的依赖包打包在一个文件夹下，这样这一个文件夹就包含了所有所需的外部依赖。当然你也可以跳过这一步，但是接下来你的每一个新工程的引入都还需要在所有地点将各个包引入。 新建一个文件夹，这里将其命名为Packages。 分别找到GLFW源码中include\\文件夹下的GLFW文件夹、下载的GLAD库放到一个新建的Packages\\include\\文件夹下： 创建Packages依赖包 创建Packages依赖包 将GLFW编译后的.lib库文件放在新建的Packages\\lib\\文件夹下： 创建Packages依赖包 将下载的GLAD库中的src文件夹中的文件放入Packages\\src\\文件夹下（你也可以直接将glad下的src文件夹放置在Packages文件夹下）： 创建Packages依赖包 最后得到的这个Packages即是我们整合好的包，这个包的最终结构大概如下面这个样子，接下来只需要将这个包进行引入即可。 Packages依赖包的结构 注：为了给大家提供方便，我已经将整合好的Packages包打包，需要的话可以直接下载：https://pan.baidu.com/s/1iwJhRHecTnn6GtVYSewrQg 提取码：s733 创建一个工程并将Packages的内容引入这里使用Visual Studio 2017，创建一个C++的空项目。 创建一个C++空项目 接下来配置是为了是我们的GLFW库和GLAD库在我们新建的项目中起作用。在项目处右键，选择属性，先切换到“VC++目录”下： 引入GLFW库和GLAD库 先引入“包含目录”： 引入GLFW库和GLAD库 引入GLFW库和GLAD库 再引入“库目录”包： 引入GLFW库和GLAD库 引入GLFW库和GLAD库 最后转到“链接器”的“输入”选项，添加附加依赖项：opengl32.lib和glfw3.lib，这个地方直接输入即可： 引入GLFW库和GLAD库 引入GLFW库和GLAD库 最后在项目的“源文件”中添加Packages包中的src\\glad.c： 引入GLFW库和GLAD库 找到Packages\\src\\glad.c，将其加入即可： 引入GLFW库和GLAD库 验证配置是否成功以上，一切准备工作都做好了！如果你想检测一下配置的结果是否可用，可以新建一个main.cpp文件，然后在头文件处加入： 12#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt; 如果没有报错，很大程度上讲应该是成功了！","categories":[{"name":"OpenGL学习笔记","slug":"OpenGL学习笔记","permalink":"https://blogs.littlegenius.xin/categories/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://blogs.littlegenius.xin/tags/OpenGL/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://blogs.littlegenius.xin/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"使用vscode编写markdown的一些小插件","slug":"使用vscode编写markdown的一些小插件","date":"2019-01-22T12:32:21.000Z","updated":"2019-02-20T03:09:28.000Z","comments":true,"path":"2019/01/22/使用vscode编写markdown的一些小插件/","link":"","permalink":"https://blogs.littlegenius.xin/2019/01/22/%E4%BD%BF%E7%94%A8vscode%E7%BC%96%E5%86%99markdown%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8F%92%E4%BB%B6/","excerpt":"","text":"vscode与markdownvscode是一款非常轻量级的编辑器，你可以通过安装甚至自己编写一些小的插件来满足各种不同的使用需求，使用起来非常简洁方便。vscode 官方网站（无需翻墙）：https://code.visualstudio.com/vscode 下载链接：https://code.visualstudio.com/Download Markdown是一种轻量级标记语言，它以纯文本形式(易读、易写、易更改)编写文档，并最终以HTML格式发布。Markdown也可以理解为将以MARKDOWN语法编写的语言转换成HTML内容的工具。 markdown的好处在于： 它是易读（看起来舒服）、易写（语法简单）、易更改纯文本。处处体现着极简主义的影子 兼容HTML，可以转换为HTML格式发布 跨平台使用 越来越多的网站支持Markdown 更方便清晰地组织你的电子邮件 markdown 的中文文档：https://markdown-zh.readthedocs.io/en/latest/ 使用vscode编写markdown理论上，vscode 在没有安装任何插件的情况下是可以直接编写markdown文档的，但是为了能够得到一些更加丰富的功能和有好多体验，可以通过增添新的插件对其功能进行完善。 在不使用插件的情况下编写markdown1.首先创建一个markdown文档：在vscode工作区中新建一个以.md为后缀的文档，即可创建一个markdown文档。 创建新的markdown文档 接下来就可以编辑文档内容了。比如以下面的内容为例： 12## Helo world欢迎来到 [小天才的GitHub主页] (https:&#x2F;&#x2F;github.com&#x2F;mhz2180572509 &quot;小天才的GitHub主页&quot;) 2.同步预览：点击工作区右上角的同步预览按钮，即可实时浏览所写的内容。 点击预览按钮 分屏同步预览 使用插件Markdown Preview EnhancedMarkdown Preview Enhanced是一个很好用的完善预览功能的插件，可以更加形象的展示所编写的pdf格式的文档样式。在插件库中搜索markdown即可找到该插件，然后点击安装后重新加载。 安装Markdown Preview Enhanced插件 你会发现工作区的右上角多了一个预览按钮，这个按钮就是Markdown Preview Enhanced插件产生的，尝试点击之后看到更加接近pdf文件格式的预览效果。 Markdown Preview Enhanced插件启动按钮 使用Markdown Preview Enhanced预览 你同样可以直接在编辑界面右键即可开启Markdown Preview Enhanced插件的预览功能。 右键开启Markdown Preview Enhanced预览功能 你还可以通过快捷键打开：先按（Ctrl+k）然后紧接着按（v）即可 Markdown Preview Enhanced的官方网站：https://shd101wyy.github.io/markdown-preview-enhanced/#/ 使用插件 Maridown pdf 将.md文件转换成其他格式Maridown pdf插件可以简单的将编写的.md文件转换成其他格式的文件，一样地，在插件库中搜索安装 Maridown pdf 插件即可使用。 安装Maridown pdf插件 在编写.md文件的工作区直接右键即可看到由Maridown pdf插件产生的功能项，选择需要转换的格式即可生成需要的文件，生成的文件将会直接保存在.md的文件目录下。 右键选择生成文件格式 生成破地方文件 已经生成的pdf文件 （温馨提示：如果希望在vscdoe中直接打开浏览pdf格式的二进制文件，可以通过安装 vscode-pdf 插件来达到该目的） vscode-pdf插件 在vscode中打开浏览pdf文件","categories":[{"name":"markdown","slug":"markdown","permalink":"https://blogs.littlegenius.xin/categories/markdown/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://blogs.littlegenius.xin/tags/markdown/"},{"name":"vscode","slug":"vscode","permalink":"https://blogs.littlegenius.xin/tags/vscode/"}]}]}